 Welcome to you all. I'm going to tell you today about quantum mechanics. That's the objective of  today's video. And so we'll start with the reason why. Why am I going to tell you about quantum  mechanics? Well, in the past year, the past couple of years, we've witnessed an extraordinary  situation where quantum mechanics and computation are coming together and they're giving birth to  quantum computation. And not just theoretically, the first real world devices that are capable of  performing quantum computation have been developed. They are now available. And this has generated an  extraordinary amount of excitement, both inside physics, but also outside physics. And the reason  I'm going to tell you about quantum mechanics today is because I have in mind that you are  participating in this video and people watching this video will be people who are not necessarily  physicists. So the aim of today's video is to gently give you a background, enough background  in quantum mechanics so that you could potentially jump in to the field of quantum computation.  And so I should then move to the who. Who do I have in mind for today? So today's presentation  is not really intended for physicists to know everything there is to know about quantum  mechanics. That's not the objective of today's video. The people who I have in mind are people  who are trained at an undergraduate level in a natural science, potentially information theory,  potentially chemistry or some other related field, biology, where you've had some exposure  to a little bit of mathematics, a little bit of physics, but not necessarily quantum mechanics at  all. So this is the target audience for today. People who are knowledgeable of maths and perhaps  physics at an undergraduate level, but who haven't seen quantum mechanics. So if you have seen quantum  mechanics, maybe you'll be curious to see how I'll be presenting quantum mechanics to a general  audience. But the audience today is not physicists. It's really people who have really  barely any working knowledge of quantum physics. What do I presume? What do you need to bring?  What to understand in today's video? I'm going to, you know, you're going to need to bring two  ingredients in order to best benefit from today's video. So the first thing you're going to need to  do is bring a basic, I repeat basic, working knowledge of probability theory. So I will assume,  and I won't bother to define notions such as probability distribution, expected value,  average value, sample space, random variable. These notions will be assumed. And if you're  uncomfortable with these notions, then please do go ahead and look at the numerous videos that are  available actually on YouTube and beyond that will give you a good grounding in probability  theory. So probability theory is really a must for enjoying the content for today. Another must  is linear algebra. So linear algebra is a more demanding prerequisite.  It's, and it's something I'm just going to assume. So I do encourage you if you're not  comfortable with linear algebra, maybe to take a little while to review the basic,  the basic concepts of linear algebra in particular, it's going to be essential that  you know the notion of a vector space. Okay. That's the basic part of linear algebra. I also  will assume you know about matrices. I'll assume that you know about diagonalization of matrices.  There's one potentially advanced topic that you may not be familiar with, and that's the  Kronecker or tensor product. I will partially review this. That's something you do need to have  fair, fairly, need to be fairly comfortable with, and hopefully you will be by the end of this video  anyway. So why are we here? To teach you quantum mechanics. Who's this aimed at? People who are  who's this aimed at? People with a broad scientific background who at least are comfortable  with probability theory and linear algebra. And well, let's get right to it. So what I'm going  to do is present to you quantum mechanics, but I'm not going to teach you all of quantum mechanics.  That takes a full semester at the, at the end of an undergraduate degree. I'm going to tell you  about not quantum mechanics, but I'm going to tell you about something that we could call  simplified quantum mechanics. Now I'll try and be very precise about what is being simplified here  and what you're missing out on and what you're gaining. So to teach quantum mechanics properly,  you do need a good grounding in all of physics. So you can sort of place the theory of quantum  mechanics in context, and that takes many, many years of an undergraduate degree.  However, and further, you need to be comfortable, you need to really engage with  infinite dimensions to do quantum mechanics as a physical theory justice. Now, these two  prerequisites usually mean that quantum mechanics is incredibly hard to learn because, okay, it may  be easy to learn probability theory and linear algebra, but the minute you talk about infinite  dimensional vector spaces and fitting this all in the context of a broader theory of physics,  that places a massive hurdle to entry, a massive barrier to entry when learning quantum mechanics.  However, it turns out that for the purposes of quantum computers, learning about enough quantum  mechanics to understand how quantum computers operate, or at least how to model quantum  computers, you don't need to know about infinite dimensional vector spaces. This is not required.  And you don't really lose anything by not knowing that part of the quantum canon. And secondly,  if you're willing to accept a couple of postulates on faith, you don't actually need to know the full  baggage of all the historical development of quantum mechanics and other physical theories  on which the development of quantum mechanics was built. So this is why we can teach  the elements of quantum mechanics without this huge barrier to entry. The price we pay is that  you're not going to quite learn about quantum mechanics as practiced by practitioners,  but you will learn enough that you really will be able to do almost all the calculations that we do  in our daily lives as quantum information theorists. You should be able to follow them  at a professional level after today's lecture. And that's where we're going to jump off from now,  the idea that I'm going to teach you quantum mechanics, not the full theory with infinite  dimensions, rather a simplified subset that's self-contained and will allow you to reason about  quantum computers. And before moving on to telling you what is quantum mechanics, because  I am going to tell you all the postulates of quantum mechanics, we're going to learn how to  work with quantum mechanics, I'm going to first mention by way of introduction what kind of thing  is quantum mechanics, and then we'll see how to define it and to work with it.  So the important take-home message that you should already be memorising  for the future is that quantum mechanics is a probabilistic theory. I'll tell you exactly what  that means in the sequel, a probabilistic theory. What does this mean? It means quantum mechanics  supplies us predictions, it's a theory of physics, we model physical systems and we solve our models  and we use our models to supply predictions, so that's what a predictive physical theory does,  but these predictions don't come in the form of the particle will be here at this time. No,  the predictions of quantum mechanics come in the form of probabilities.  So all that quantum mechanics can do as a theory is give you a probability of an event taking place.  So the predictions come in the form of probabilities.  And well, the minute you have probabilities, you need probability theory to reason about it,  and in that sense that's why probability theories are necessary prerequisite to talk  about quantum mechanics, because at some point quantum mechanics is going to hand you a prediction,  it's going to be a probability and you're going to have to reason about it.  Now to give you a high-level depiction of how a probabilistic theory, what does it look like,  you know, how do you work with a probabilistic theory, I'm going to show you every single  experiment that mankind has ever done in physics. So the way an experiment works is you have three  stages in an experiment. There's a preparation stage where you build up your apparatus and you  put the apparatus into a known state or a known configuration. So this is the first stage of any  experiment in physics, preparation. You start by building your system up and setting up all the  degrees of freedom in known configurations so that you can then proceed. You then allow your  system, depicted here as a line, to evolve. Maybe you change some aspects of it, maybe you  shine some laser light at it and then you turn the laser off or something. So what happens is  that after preparation there is a period of so-called dynamics, some time passes, things happen.  And then at the end of the experiment you measure, you perform a measurement, so there's  oops, and a measurement supplies us information.  And this information will typically come in the list of a bunch of  bits of information, so we have say classical bits.  So if you're sort of like struggling to imagine something that fits into this, imagine we have  some mirrors, we shine some very faint light into this collection of mirrors, the light bounces  around the mirrors, and then we have a photon detector somewhere, something that just detects  light, and this detector just clicks or doesn't click. Now that's actually a surprisingly good  representation for very many situations in experimental physics. And the information  you get when you measure light, or in particular is a photon there or not, is a click or a no-click.  In fact, it turns out that all the observables that quantum mechanics will give you predictions  about are of that form. Does event A happen or not happen? So that's why probability theory  will play a role. In terms of preparation here, usually there's some information required to  describe the preparation of your experiment. So we have a list of variables, A1 through to AM.  These are also classical bits, you can just take your information that describes the setup  of your apparatus and express it as a list of bits as well. So what you should be seeing here  is a picture where classical information is used to create a preparation for your experiment,  the experiment proceeds, and then there's a measurement and out comes classical information.  And so that's all experiments that we try and describe in physics. If you work hard enough,  you can reduce them to this abstract form here. And so the goal of quantum mechanics  is to describe the probability that we get a given outcome given a certain income.  So this is to predict the probability because we can't,  quantum mechanics will only deliver probabilities as predictions of an outcome  from x1 through to xn, so you get some string of bits given the setup A1 through to AM.  So we have something like this given A1 through to AM. That's all that quantum mechanics,  that's the goal of quantum mechanics to do this. And what I'm about to tell you now is I'm going  to give you a recipe book, you can take this recipe book and with a bit of practice and just  a little bit of extra knowledge, you'll be able to apply this recipe book to model an extraordinarily  large number of systems that occur in quantum computation. So that's the goal of quantum  mechanics and also our goal today. That's all very well, you might say, we have these probabilities,  great. You might be forgiven for thinking this all looks too abstract and the answer is indeed  it does look too abstract because I haven't told you what's the rules for preparation,  what's the rules of predicting the dynamics or modeling the dynamics of an experiment,  and what's the rules for getting measurement outcomes out of a quantum system. That's the  goal for today, to tell you what the rules are to allow you to produce one of these probabilities  as an outcome, as a prediction. And that brings us to simplified quantum mechanics.  If you are a German speaker, then you can benefit from my latest lecture series,  Theoretical Physics C, in which I go into much more detail about the laws of quantum mechanics.  I give the full postulates, no simplifying assumptions whatsoever, but also I can  recommend any number of videos that you might find on the internet. The essentials of quantum,  any lecture course on quantum mechanics will give you some version of what I'm about to show,  some superset of the version of what I'm about to show.  Right. Oh, it occurs to me that before I jump into these postulates, I should have a couple  of words about notation. Indeed, just so that you won't be too shocked when I start writing down things.  So we're going to talk about vector spaces a lot in quantum mechanics,  and we're going to talk about something called Hilbert spaces. So let me just set some notation.  I'm going to, the vector spaces that occur in simplified quantum mechanics all have a very  special form. They are all the form of the complex numbers to the d, which means this is just the  vector space of all column vectors with d entries, d complex numbers.  So hopefully you're familiar and comfortable with complex numbers. I didn't write that as  a prerequisite, but that is something that I'll also assume that you know. So vectors in my  notation, vectors are usually written with a V, with a line underneath to indicate that there's a  vector. So it's a column vector with d complex entries. So that's our vector spaces in simplified  quantum mechanics. We'll always be focusing on these kinds of things. We also have in simplified  quantum mechanics, an inner product. That's also pretty important to talk about this inner product.  As we'll see, it's got to do with the probabilities of quantum mechanics. Inner products, I will have  various notations for them, but this is the one that will stick to. V, W, an inner product. The  inner product we're going to use is going to be take the transpose of V, then take the complex  conjugate, which we could also write as star, and multiply it by W. That's the inner product we're  going to use when talking about simplified quantum mechanics. And so just a quick example,  just to set this notation. If we have one vector V, and this vector is like one I,  and we have another vector W, and this vector is like two I three. So these are two vectors in  the vector space V is C2, two column vectors. Then the inner product  can be calculated, and we're going to need to do this,  as follows. Well, we've got to take the transpose of V, and then the complex conjugate. So here's  the transpose of V, but I haven't done the complex conjugate yet. Now I'll do the complex conjugate.  So one stays, goes to one, but I goes to minus I, and we've got two I and three, and then at the  end we end up with two I minus three I, which is otherwise known as minus I. So that's the inner  product between V and W. We're going to use this inner product a lot, but we're going to use it  a lot. It's so-called sesquilinear, bilinear form. You don't need to know that. If you're just  happy to accept this definition, then that's something we're going to use a lot.  Good. Let's move on. I think that's all I need to say about  vector spaces. I have to tell you one final thing. It's going to come up a lot.  It's hard to talk about quantum mechanics without saying the word Hilbert space.  Now Hilbert spaces are, in infinite dimensions, a much more subtle concept than they are in finite  dimensions. But in finite dimensions, life is very easy, and that's why we take finite dimensional  systems. A Hilbert space is nothing other than a vector space V with this inner product  VW. Okay. That's what a Hilbert space is for today. That's enough for us in simplified quantum  mechanics. If you wanted to do it properly, then you have to worry about infinite dimensional  systems. We're not going to do that. So it's enough for us to focus on finite dimensions.  So now what I'm going to do is I'm going to list a bunch of postulates.  Now the thing about quantum mechanics is that you can't prove that quantum mechanics is correct.  In physics, you can't prove anything is correct. All you can do in physics is reject a hypothesis,  right? So we can't say we have proved with this experiment that quantum mechanics is correct.  All we have done is supplied evidence that it might be correct when we do an experiment, and  the outcome of the experiment matches what we would predict from quantum mechanics.  This is a serious component of physics. You can never prove that a theory is correct. All you can  do is reject hypotheses and therefore sort of accumulate evidence that this theory is the  correct one. It could be that tomorrow someone does an experiment which indicates that there's  a theory that's not quantum mechanics that matches all the experiments we've done up to now,  but in some way goes beyond quantum mechanics. I can't exclude that possibility. It's impossible  to exclude the possibility that there's another theory underlying everything that's  different from quantum mechanics. And so that's why we can't, I can't say to you,  this is, you can derive this. What we've done is through many decades of experience,  accumulated evidence that a certain mathematical structure seems to model the universe. And the  best way we have to describe this mathematical structure is via a list of postulates,  and the word postulate should indicate to you, this is something I can't prove,  it's something we take on faith, or rather not completely on faith, like we've worked pretty hard  to convince ourselves that these postulates are the correct way to quantify or to describe this  theory. Okay, postulate one. And oh, there's always some argumentation in the literature,  what's the right postulates? I'm going to show you the real professional postulates. I'm not  really pulling my punches here. This list of postulates are the ones that many working  physicists work with in their daily job, and I'm going to show you how we really work with  quantum states. This is where these list of postulates might differ from the average textbook,  which sort of presents things in a slightly indirect way. Okay, postulate one. Each type  of quantum system is assigned a Hilbert space H.  Okay, I'll immediately do an example to give you an example.  So, we're assigning a Hilbert space to each type of quantum system. Let me give you an example of  a type of quantum system. We're doing quantum computation here today. The most fundamental  atomic type of quantum system in quantum computation is the quantum bit or qubit,  and that is assigned the Hilbert space C2, the space of all column vectors with two complex  entries. This Hilbert space you shouldn't think of is directly leading to any predictions in  quantum mechanics. Rather, it's the kind of mathematical space upon which the structure  of quantum mechanics is built. So, it's the background set in which quantum mechanics  takes place. So, the qubit is one type of quantum system that you might think of as  the qubit. So, the qubit is one type of quantum system that you might encounter in quantum  computation. You might encounter the qubit. As the name suggests, the qubit is a D-level  quantum system, and it's assigned the Hilbert space or vector space within a product C to the  D. So, this is just the space of all column vectors with D entries. Okay, that's postulate  one. Each type of quantum system is assigned a Hilbert space H. You're not allowed to go to  postulate two until you've decided on postulate one. And then we move to postulate two.  Postulate two tells us about preparation processes. So, I'm going to go back up here.  Remember, every experiment in physics takes the form of a sequence of a preparation,  some dynamics, and a measurement. So, I have to tell you how we describe preparations  in quantum mechanics. A preparation is characterized by something called a state.  Now, in quantum information theory and in full quantum mechanics, a state is  represented by a thing called a density matrix. I'll tell you what that is in a second.  So, all preparations in quantum mechanics are characterized by things called states,  and states are represented by density matrices. What is a density matrix?  And this is where we get to probably the hardest mathematical prerequisites for this course  immediately. What is a density matrix? This is a positive operator. I'll explain what that is in a  second. Matrix, right? When I say operator, always replace it with the word matrix. It could be that  I just end up saying operator without thinking, but in simplified quantum mechanics, operator  equals matrix. So, I'll just put that as a parenthetic remark here. Operator equals  matrix in simplified quantum mechanics. You can add that to the dictionary of terminology that  you'll face. So, a preparation is characterized by a state or a density matrix. This is a positive  matrix. I'll explain what that is, with trace equal to one. Okay, what's a positive matrix?  So, I'll tell you what the matrix is. We almost always use the symbol rho for this matrix,  and with trace of rho equals one. All right, this is, in a sense,  this is the hardest mathematical step in understanding simplified quantum mechanics.  We have to make sense of the word positive. What does this mean? So, we'll just make an aside.  Positive. This means that all eigenvalues  of rho are greater than or equal to zero. That's one characterization of positivity  in finite dimensions. Another one is equivalent, and this is an exercise for you, just as  just as  for all, if you take your favorite vector, for all vectors in the vector space V,  oh, I should tell you one more thing in notation in a second. If you multiply this vector by the  transpose complex conjugate by rho by V, that's always greater than zero.  I didn't tell you how big this matrix was. That's embarrassing. It's a D by D matrix.  Why is it a D by D matrix? What I should have told you is that this matrix acts on our Hilbert space.  Rho maps from the Hilbert space to the Hilbert space. So, it's a square matrix,  so it's a square matrix, and if our Hilbert space has dimension D, then  it turns out that all Hilbert spaces in simplified quantum mechanics are of the form of the complex  numbers of D by D column vectors, D column vectors of complex numbers in quantum mechanics.  Then a positive matrix is a matrix, so it's got to have the right dimension, right? It's  going to be a D by D matrix. And positive means that no matter what vector you choose  in your Hilbert space, H, no matter what vector you choose, if you do  V transpose complex conjugate multiplied by rho multiplied by V, then that's always greater than  equal to zero. And now we have another symbol for V transpose complex conjugate. It gets so  annoying to write that all the time. So, we actually have a different symbol for that that  I'm going to start using called V dagger rho V is bigger than equal to zero.  Okay, that's just an aside. What does positive mean? It means if you work out all the eigenvalues,  they're either, they're all greater than equal to zero, or no matter what vector you choose from  your Hilbert space, if you form this product of a vector, a rho vector matrix, column vector,  it's always greater than equal to zero. Okay, very good. Let's do an example.  No, let's not do an example. Let's finish the postulate.  Because there's a special case that you have to be aware of,  because we're going to say these words a lot. Now, not all states are somehow the same. Some states  are purer than other states. The terminology that we use for such special states is pure state. A  pure state is one that cannot be prepared as a probabilistic mixture of two other states. We'll  come more to that in a minute. For pure states, those are represented,  for pure states, those are represented  as a one-dimensional projector. And that will need some comment, and I will give some comment  about that in a minute. So that means that your state rho is called pure if you can write rho  as a product of a column vector and a rho vector in this way.  Okay, I'll do some examples to illustrate this postulate in a second. Let's put the  whole postulate there. A preparation in quantum mechanics, simplified quantum mechanics,  is characterized by a state. A state is a density matrix. This is a positive matrix rho,  which acts on our Hilbert space and has trace one. And specifically for so-called pure states,  rho has a special form. It's the form of a one-dimensional projector, rho equals psi,  psi dagger. And so in other words, there's a one-to-one correspondence between one-dimensional  projectors and vector, otherwise known as pure states, and vectors in our Hilbert space.  Let's do some examples. We're going to go back to qubits here.  Okay, this qubit is a type of quantum system. The Hilbert space we assign to a qubit is C2.  Now, I'm telling you there's a thing called a preparation, and a preparation is represented  by a density matrix. So what's a density matrix? Well, it's got to be a two-by-two matrix, right?  It's acting on H and giving us something in H. So it's got to be, the only thing that fits,  right, is a two-by-two matrix. And here's an example of a density matrix. It's got the entry  a half here, the entry a half here, and the entry a quarter here times I, and an entry a quarter  minus times I here. That's our first example of a quantum state. It's a two-by-two matrix.  Let's check all the properties. Does it have trace one? So are we allowed to call this a  quantum state is the first question. A quantum state has to have trace one. Okay, let's check  that. So if you take the trace of rho, then you get a half plus a half, so that's one.  So that worked out. But now we have to also decide if this matrix is positive. That means  both eigenvalues greater than equal to zero. I'm going to take a sneaky side trick to prove that.  One way to do this is you look at the determinant of the matrix. This only works in two dimensions,  by the way, for qubits. And the answer we get here is a quarter minus 80 minus BC. So it's a 16th  times by minus one, because we've got I there, the complex number I.  So we get a plus 16, right? If I did it correctly. Did I do it correctly?  One quarter plus, I'll just do it slowly. The problem with doing things quickly  with too many I's on the board is that you miss a minus sign. And I think I did. So there's a  minus, goes to a plus here, and there's a minus here. Okay, I did miss a minus sign.  So it's a quarter minus a 16th. Now that number, whatever, if you care to work it out,  is greater than zero, right? And the determinant of a matrix is the product  of its eigenvalues. So we know that in this very special case here, the two eigenvalues of rho,  their product is positive, which means that they have to either both be negative or both be  positive. In this case, they are both positive because the trace is equal to one. And that's the  sum of the eigenvalues. You may not remember these little linear algebra tricks. And the reason I'm  actually doing the example like this is this kind of reasoning, especially about qubit states,  gets applied in practice very rapidly by practitioners. You'll often see practitioners  say things like, oh, that matrix is clearly positive. And you'll be like, I didn't work  out the eigenvalues. How do you know that? And the way people reason is they often use  these kind of linear algebra side tricks, that the trace is the sum of the eigenvalues of a  matrix that determines the product of the eigenvalues. And that way, you can reason  very rapidly about matrices. And so I don't expect you to see this as obvious. On the contrary,  you may be really struggling to remember where you saw this for the first time.  That's OK. But by repeating these kinds of reasonings, you'll get practice at them.  OK, that's an example of a quantum state. It turns out it's not pure.  And the reason we can say that so very quickly is that the eigenvalues of a pure  state, represented by a matrix like this, has one eigenvalue equal to 1 and the rest equal to 0.  And that would mean the determinant is 0. So I'm going to give you an example now of a pure state.  Let's see if I can just think one up. Here's one.  This is a pure state. Now, how can we convince ourselves of this fact? Well,  think about this trick I showed above. The determinant of rho is 0. So that's a good  starting point. It's positive because the trace is 1. But this doesn't tell us immediately that  the state is pure. Pure means that rho is a matrix which has specifically this form where  you can write it as a column vector times by a row vector. And I'm going to do that right now.  You can write rho in this form here, root 2, 1 over root 2, 1 over root 2.  So you can always write rho like this, the product of this column vector times by this row vector.  This always kind of freaks. There's a kind of freak out moment when you see this thing here.  How can you multiply this? Well, you can. According to the rules of multiplying matrices,  the 1, 1 entry is a half, right? And then the rules say, well, then I take this entry and  I multiply it by over there and then I get a half. And then I take this one and I get a half.  And so you build a matrix that way, right? So it's a matrix. It also has the form of psi times  by psi dagger. So it's a one-dimensional projector or otherwise known as a pure state.  And now it's also time for another observation. We're going to need a lot.  What about the, suppose we have a pure state  and pure states feature a lot in quantum computation.  Can any vector give us a pure state? And the answer turns out to be no.  If you take the trace of row, then, well, you're taking the trace  of a column vector times by a row vector, and you can use the cyclic rule of trace,  right? Trace of AB is the same as the trace of BA, even when the matrices aren't square.  So A is psi and B is psi dagger, and you get psi dagger times by psi.  And that's a number. So that number has to equal one. So not any old vector is allowed as a  pure state. The vector further, not any other vector psi from your Hilbert space is allowed  as a pure state. The vector must further have length one. And another way of writing that is  that the inner product between psi and itself is one. That's a quick side remark. So you'll often  see in quantum mechanics textbooks, people will define pure states first. They won't talk about  density matrices at all. They'll say pure states are vectors in Hilbert space with length one.  Now, that's something that many textbooks do. I encourage you not to think this way, because  I encourage you not to think this way, because in reality, in quantum computation,  we will encounter generically and universally density matrices. We will encounter so-called  mixed states, non-pure states. These appear most generally in quantum systems, because  every quantum system is under the influence of noise. And when you have noise acting on a quantum  system, then that takes a system in a pure state to a mixed state. I don't expect you to understand  that statement, but I will have it said that, I'll just say it, quantum systems in the presence of  fluctuations and noise from the environment generically are not in pure states. And so  that's why we should just rip the bandaid off quickly and define states as we do in  simplified quantum mechanics to be matrices. And then pure states are just a special kind.  There's one further example of a state that you should definitely know,  and that is if you have a probability distribution, and this is how you can  take your knowledge about probability theory and upgrade it to a knowledge about quantum mechanics.  If you have a probability distribution  on a sample space of d things,  d items, then what's a probability distribution on a sample space of d items? Well, it's a list of  numbers, right? It's p1, the probability that I get item 1, probability 2, and so on, all the  way up to probability d. And these probabilities, in order to be a probability distribution, you  should be able to sum them up and get 1, otherwise it's not a probability distribution. And furthermore,  the other defining feature of probability distribution is that these numbers are all  greater than or equal to 0. Now, if you have, so given a probability distribution,  then that actually automatically gives you a density matrix or state. We get a valid quantum state  representing this,  and what you do is you take these probabilities and you stick them on the diagonal of a matrix.  So all the other entries are 0, except for the diagonals, which are just these probabilities.  Is this a valid quantum state? Well, let's check, right? According to the definition,  it has to have trace equal to 1, and the eigenvalues have to be greater than or equal  to 0. And so let's check that. Well, the trace equal to 1, that's perfect, right? That's just  the sum of the diagonal entries, which is exactly what you need for these numbers to form a  probability distribution. And the eigenvalues being greater than or equal to 0, well, that's  also straightaway given to us because the matrix is diagonal. So the diagonal entries are the  eigenvalues, and they're all greater than or equal to 0 because this is a probability distribution.  So we automatically can embed probability theory into quantum mechanics, and I find that to be  a really helpful device. If you're struggling to understand quantum mechanics and have a reason  about it, you can gain a lot by just thinking about how probability theory is a sub-theory  of quantum mechanics. You get this sub-theory by just focusing on diagonal density operators.  So I'll write that down.  And that's really handy to know this, that probability theory is a sub-theory of quantum  mechanics. So anything you can do in probability theory, it turns out you can do in quantum  mechanics. It's very useful perhaps when designing algorithms. Okay, I've told you  about preparations that took a while. Now let me tell you about measurements.  I'm going to tell you about the last bit, dynamics last, the middle bit, dynamics last.  So postulate 3 tells us how to model detectors. So I've told you how to model in quantum mechanics  preparations, namely with these density matrices, but in quantum mechanics we can't perceive states.  This is something very important. If you have some quantum system and you've prepared it very  nicely in a given state represented by a density matrix, we can't see this density matrix, right?  You know the system's prepared, but you have no information about the state itself. How do  you get information out of a quantum system? The answer is by detection with a detector.  And that's what I'm going to tell you about now.  So a detector is a measuring apparatus, and it's a very specific kind of measuring apparatus.  It's got only two possible outcomes, this measuring device. It either says yes or no.  So yes, otherwise known as a click. So the detector clicks and says yes, I detected something  or no, which means no click. Detectors are these very special kinds of measuring  apparatuses. They exist everywhere in high-end physics and in optics. You can think of a detector  as a particle detector. It tells if there's a photon there or not. Yes or no. And it turns out  that all measurements in quantum mechanics can be broken down into a sequence of yes-no questions.  It's kind of a binary search thing. If you want to model a much more complex measurement in quantum  mechanics, then ultimately it's like a game of 20 questions. Is the quantity on the left or the  right, yes or no? So that's the first detector. So you can model all detectors in quantum mechanics  really via this postulate. All you have to do is sequentially model the measurement as a sequence  of yes-no questions, which are then separately modeled by these detectors. Now that's what a  detector is. How is it modeled in quantum mechanics? How do we mathematically model  such a thing? It's modeled by an operator. In other words, a matrix.  This matrix has got to be a d by d matrix because we're acting on a d by d dimensional Hilbert space.  And what kind of matrices are allowed? Well, only ones that obey this curious-looking  inequality. I'll explain what that means now. What does this mean? It means that f is bigger  than zero or positive and that f is less than the identity, which I'll explain. So what does this mean?  This means that zero is less than f, i.e. f is positive, and I told you what that meant earlier,  and that f is less than equal to i. i is the identity matrix, 1, 1, 1, 1, all zeros.  And f is less than i is the same as saying that zero is less than the identity,  i is the same as saying that zero is less than i minus f, or i minus f as a matrix is also positive.  That's what it means.  And that's how we model detectors in quantum mechanics. Detectors are modeled by matrices f.  And I better give you an example. So we have the running example of the qubit.  Here's a real-world example detector, one that if you go on a cloud quantum computing service like  the one provided by IBM, you will absolutely be able to measure this detection, or measuring  apparatus. So here's a matrix, f is given by 1, 0, 0, 0. I claim that that's a legal detector.  This is called the sigma z measurement.  In the parlance of quantum computation later, you'll see that this is called the sigma z  measurement. f is this 2 by 2 matrix. So if you do a sigma z measurement, that means you  model it with this matrix here. You'll see many of these as the weeks go by. Here's another one.  I've got to be a touch careful here. No, I think this is correct.  This is called a sigma x measurement. This terminology is largely historical, and we're  kind of stuck with it. So let's take a look. Is this thing here an allowed measurement? Okay,  f has got to obey these inequalities, right? f is going to be positive, and 1 minus f is also  going to be positive, in order for it to model a detection. Now, let's just check. f is indeed  positive, right? Because its eigenvalues are 1 and 0, and they're both greater than or equal to 0.  So that's okay. What about 1 minus f? Well, we can work that out. 1 minus f is the identity matrix  minus f, which is 1, 0, which is the same as 0, 1. Okay, that's also positive, right? Because  the eigenvalues are 0 and 1. What about this next one? Same story, right? We already know that f is  positive because I actually used a matrix up above. Yeah, I've already proved that rho is positive.  It turns out f is the same as rho. That does sometimes happen, but it's not always the case.  It turns out f is the same as rho. That does sometimes happen, but it's not usually the case.  In this case, it does happen. f is positive, but what about 1 minus f, right? Might not be positive.  1, 1, 0, 0, minus a half, a half, a half, a half is equal to a half, a half, minus a half,  minus a half. Now, the question is, does this matrix have positive eigenvalues? And the answer  is yes, right? If you work out the determinant, you can see that you get a positive number,  right? The determinant is a quarter minus a quarter. Sorry, the determinant is 0. It's  even better, right? The determinant is 0 and the trace is 1, so we know it's a positive matrix  by the arguments I've applied above. Just so you can get practice at this style of reasoning,  that's going to happen really a lot in the coming weeks.  While you're taking your sip, just a quick question here.  Please.  When you say positive, this would be what in mathematics we call positive semidefinite.  Oh, thank you. Yeah, I always do this. Thank you for the clarification.  So you do allow a 0 eigenvalue?  We do allow a 0 eigenvalue. I apologize.  I'm sure that's important. Yeah, that's important.  That actually was a mistake. It's not just terminology. I just said the wrong thing for  up to now. Whenever I said positive, I should have been saying positive semidefinite.  I mean, your matrix F there clearly has a 0 eigenvalue.  It clearly has a 0 eigenvalue. So it's actually not positive in the sense,  even mathematically. Yeah. Many thanks for the clarification. That's a shame that I made that  mistake. Okay. That's how we model measurements in quantum mechanics. Measurements are mathematically  modeled by positive operators that also have the property that 1 minus the operator is positive.  That's how it's modeled.  Now we come to the next. And that's great, right? So I've told you about preparations.  I've told you about measurements, but I haven't told you how to get predictions  out of quantum mechanics yet. This is a pretty boring theory.  We can model preparations and measurements, but we can't put them together, right?  What brings these two pieces of information together to give us an actual living breathing  physical theory? The answer is we need another postulate. And this is postulate 4.  Now this is where we've got ourselves a real physical theory. Now we actually don't need  postulates 5 and 6. It turns out postulates 1 to 4 are sufficient to build up quantum  mechanics as a theory, physical theory, and postulate 5 and 6, which I'll talk about later,  are convenience postulates. We just put them in for convenience because we can't be bothered  to rederive everything. But postulates 1 to 4 are actually already enough.  Okay. Now we're going to do physics. This is it.  Enough math. We're going to do some real physics now. The detection rate of a detector  modelled by some matrix F on a system  prepared, right? We've mentioned now detection and preparations.  According to Rho, right? Preparations are these density matrices. Detections are these  matrices F. So detection rate of a detector modelled by F on a system prepared according to Rho  is given by  P. We'll call it click. When does our detector click? Well, with a certain probability.  And that probability is given by the trace of Rho multiplied by F.  That's it. Now we're doing physics now. We've got a way to model preparations. We've got a way to  model measurements. Now we can find out if a given preparation will lead to a given detection  outcome and at what rate. And the rate is determined by this formula here. This is the  most important formula, version of the Born rule, quantum mechanics. You need this formula if you're  ever going to do anything with quantum mechanics. And we'll see that there's so much that's buried  into this formula that's of relevance in quantum computation. Because in quantum computation,  we're always going to be facing the challenge of getting information out of our system.  We can put it in with a preparation. We can set up a detection. And the only way to get  information out is via a measurement and the rate of clicks that we get. So if we do a preparation  and then we do a measurement, then we determine or we get a click outcome with probability  given by trace Rho times F. So let's do an example.  By the way, I will distribute these notes  probably by email. So we're going to go back to our friend the qubit. A qubit, we're going to  describe our preparation and our measurement preparation. So let's imagine we prepare our qubit  in the state, oh, I don't know, a half, a half, a half, a half. This is a pure state. And let's  suppose we want to measure this qubit state and find out with what probability does our  detector click. So the detector, what detector are we going to use? Well, there was a nice one that I  wrote up above, 1, 0, 0, 0. And so we have a preparation. We have a detector. We have the  experiment. Now we can draw the experiment. So in comes the preparation. We need to prepare the  state Rho. So we give a description to our experimental friend and they give us Rho,  they construct an apparatus which can prepare the qubit in the state Rho.  And then nothing happens. And then we measure.  And we measure with our detector F, the so-called Sigma Z measurement. And in fact,  if you go to the IBM quantum experience and you ask to prepare your qubit Rho in the state and  you want to do a Sigma Z measurement, you will get an outcome of click with a probability. Let's  work out what that probability is. So the probability that you get a click  when you prepare your system and then measure it in this way is given by postulate 3 by trace of  Rho. So Rho is a half, a half, a half, a half times by F. F is 1, 0, 0, 0, 0. OK, that's the  probability with which you get a click. And if you multiply these matrices out, we get a half,  0, a half, 0, we get a half. So half the time when you prepared your qubit in this way and you  measure it with this measurement, you will get a click. And the other half is no click. So that's  our first quantum mechanical experiment prepared and modelled and measured. And you can go ahead,  if you're willing to learn the interface for the IBM quantum experience, and actually carry this  out on a real quantum computer, if you wish. And you will get a list of zeros and ones.  And that's the number of times the detector clicked or didn't click. So that's something  that is well worth doing, so much worth doing, that I'm going to give it as a homework.  Now, that's a real challenge homework. I don't expect you to be able to just do this instant,  instantly. But I think with a bit of sort of fiddling around and dragging,  it's got a lovely drag and drop interface, you'll be able to carry out that experiment yourself.  And that's really like a real experiment. It's actually happening on a real quantum computer,  this experiment. And you'll get clicks and no clicks. And you could look at the  empiric rate at which you get the clicks and no clicks, and you should end up with about a half.  So that's, like, already we've done enough now. I've already told you  super simplified quantum mechanics.  That was super simplified quantum mechanics. In this version of quantum mechanics,  we don't have dynamics, we just have measurements and preparations.  And it turns out that's actually enough, right? You can actually,  with a bit of reasoning and argumentation, argue that the next two postulates are actually somehow  by no means independent.  But they're so convenient that I'm going to tell you them as postulates,  so we don't have to prove them. And then you can just, you know, believe me and apply them.  Now, it's worth saying that we have these postulates,  and they tell you the mathematical rules for how to model these things,  but they don't tell you how to model these things, right?  So suppose you have an experimentalist friend, and they said, I can do the widget measurement  and the bleeblap preparation.  What's the right matrix and what's the right F?  What's the right density matrix and the right F to model this experiment  by your experimentalist friend? And the answer is, well, based on experience.  And so what you need to do as a working quantum computer theorist  is build up a dictionary of commonly applied preparations and measurements.  So this is vital.  In fact, I better say that right now.  So  there are a list of really commonly applied preparations and measurements  that people use in practice. Now, I'll write out a couple of them.  Basically, we're going to learn them sort of on the job as we go by in these lectures.  And I won't really take so much time to give you the full comprehensive list,  because once you understand the general shape of one of these  commonly applied preparations and measurements, you'll no longer really...  You won't bother to remember this as a dictionary.  You'll actually learn that postulate five helps you to remember  this list of commonly applied preparations and measurements.  So here's the vital list. I'll give it to you now.  There's the so-called X preparation,  where rho is given by a half, a half, a half, a half.  There's the Y preparation, where I don't even think I can remember it correctly.  I believe it's a half.  Sigma Y would be plus one. So I believe it's minus  a half I, a half I. And then there's the Z preparation,  where rho equals one, zero, zero, zero.  You just have to remember these. As you learn more quantum mechanics  and you get more experience with it, it gets easier and easier somehow  to know which preparation is being talked about at which time.  And then here comes the detections or measurements.  There's a corresponding to each one of these preparations,  there's a measurement operator, just so it turns out they're the same thing.  So that was pretty easy, right?  So F equals rho here. I'll call this rho X to make it clear  that this has got something to do with these letters X, Y, and Z.  The Y measurement F equals rho Y and the Z measurement F equals rho Z.  I want to stress that although F looks like it's also like a density operator,  it doesn't have to have trace one.  So this weird duality between these two things goes away very quickly.  Okay, here's your list of basic preparations and measurements in quantum mechanics.  You can go ahead and sort of do nine experiments this way, right?  You can try all forms of preparing and measuring to see what comes out.  You can prepare your system in the X preparation and measure the Y measurement  and see what comes out.  You can prepare in the Z and measure the X and see what comes out.  So you have nine kind of possible preparations and measurements.  Now, as I said, in practice, we often don't memorize  these preparations and measurements.  Instead, we have two additional postulates which really help us  in minimizing the surface area of stuff that we have to remember  when we're trying to do quantum mechanics.  And so now we come to postulate five.  And this is one where there's going to be a little bit of physics creeping in.  I'll try and keep the physics at bay so we don't get bogged down in  too much physical discussion that isn't relevant to quantum computation.  But this is not unrelevant.  Actually, I don't think I'm going to do it this way.  Mm-hmm, evolution.  Okay, I'm going to describe it slightly differently.  There's going to be a new word here, closed.  All right, now we're doing quantum circuits already.  The evolution of a closed quantum system is described by a unitary matrix U,  and U has to act on L, Hilbert space.  Now, maybe you don't remember what a unitary matrix is.  A unitary matrix is one where if you take the adjoint, multiply it by U,  you get the I, and that is the same as if you do U times U dagger.  Now, any quantum, what does closed mean?  Closed means that the quantum system is effectively  completely shielded from the environment.  What's the environment?  Well, everything that's not the quantum system, right?  So the qubit, perhaps, if we're thinking about a qubit,  has to be sort of hermetically sealed in some kind of chamber,  and nothing from the environment is allowed to interact with the qubit  if we're going to look at the quantum system.  Nothing from the environment is allowed to interact with the qubit  if we're in an example of a closed quantum system.  The minute we do a measurement on a quantum system,  we're actually interacting with it.  That's very crucial.  The only way information can get out of a quantum system is by a measurement,  and the minute you do a measurement, this quantum system is no longer closed.  You open up a little window, and you take a look in,  and by looking in, you're interacting with the system.  This is something you should get used to.  In quantum mechanics, information gain leads to disturbance of the system.  That's a physical truism in quantum mechanics.  Remember it.  I'm not going to write it down here,  but gaining information disturbs the quantum system,  and gaining information, you do so by measurement.  But if you don't measure the system,  if you gain no information about the quantum system,  then the evolution of the system is described always by a unitary matrix U.  This turns out to be really crucial,  this distinction between evolution and information gain and closeness.  All right.  So the evolution of a closed quantum system is described by a unitary matrix,  and we describe evolutions in one of two equivalent ways.  We could do either in the so-called Schrodinger picture,  where your preparation gets updated to a new preparation.  And what's the new preparation after the system has evolved?  Well, the new preparation is U rho U dagger.  So after the evolution takes place,  you can describe the system as being really equivalent to the system  whereby we've just prepared it in a different quantum state,  different density matrix.  What density matrix?  Well, the one where you've taken the old one,  and you've multiplied it by U rho U dagger.  Or, in the Heisenberg picture,  whereby we update our detector operator.  So the detection that we're going to do gets mapped to a new one,  F prime U dagger U F U.  So you either implement your evolution in the Schrodinger picture,  where you model the system as being prepared in the new state rho prime,  or you model it in the Heisenberg picture,  where you say the preparation is the preparation.  That doesn't change.  But the device that we detected the system with  is now effectively replaced with another one.  As we'll see, these two ways of implementing evolution  lead to the same outcome, the same probability.  So we can never tell operationally.  There's no way to set up an experiment that could tell  if it happened in the Schrodinger picture or the Heisenberg picture.  Let me give you this picture here I've shown you at the beginning.  Now we'll do it again.  Remember, preparations are modeled by density matrices.  Detections are modeled by operators F,  and dynamics are modeled by U.  And according, we can now apply the postulates 1 to 4  to work out the probability that we get a click,  either in the Schrodinger picture or in the Heisenberg picture.  Schrodinger.  Let's do the probability of a click now.  Well, that's trace of...  Well, I told you that the preparation in the Schrodinger picture,  the way dynamics works or evolutions or allowed evolutions work in quantum mechanics  is that you have to change your preparation.  So the new preparation is U prime,  and that's given by U rho U dagger times by F.  So the probability that you get a click for this experiment  is given by trace of U rho U dagger F.  That's if you do things in the Heisenberg picture.  And then the picture that you have in mind is that really you're like,  you know, I'm just thinking about the preparation  and the dynamics is just being another preparation.  U prime, rho prime.  So I effectively like incorporate the dynamics of the apparatus into the preparation.  That's one way of thinking in the Schrodinger picture.  But in the Heisenberg picture, you think differently.  You think, oh, no, no, no, no, no.  The right way to think about it is that the preparation is a preparation,  but what really changes is the way I'm measuring the system.  I'm just measuring it with respect to a different angle, so to speak.  So the Heisenberg way of thinking,  way of thinking, which is equivalent,  is that the probability of a click is given by the trace of,  well, the preparation is a preparation,  but it's now a new measurement that we're doing, a new detection.  And that's given by U dagger F U.  But if you look, these two things are absolutely the same number, right?  Because all I have to do is apply the cyclic rule of trace  to bring that U around here.  And that equals the number up above.  So these two ways of thinking,  although they're sort of psychologically extremely different, right?  You know, one way you imagine  that you're slowly changing your preparation bit by bit,  and then you just do a fixed measurement.  Or the other way of thinking where you imagine  that you're just changing preparations,  but you're always, so you're changing your detections,  and the preparation remains the same.  These ways of thinking are psychologically very different for humans.  Physically, they lead to the same results,  according to the postulates of quantum mechanics.  Let me now give you a list of some examples, right?  We need to do examples to get some feeling for these postulates.  And here, I'm going to write down  the commonly used unitary gates in quantum computation.  I'm going to write them all down.  And so these, you just heard me say unitary gates, right?  So now there's a clue there, right?  All quantum circuits are, in quantum mechanics,  what are quantum circuits?  Well, they're just evolutions of closed quantum systems.  That's, when you hear now the words quantum circuit,  you should just think that's an evolution of a closed quantum system.  They're equivalent things.  So let's go through the laundry list of all quantum gates.  I'm going to start drawing pictures without defining this notation,  but you'll get used to the pictures.  So here's evolution according to x.  Pauli x, it's called.  Got to get used to this notation.  Pauli x is the matrix U equals 0011, like that.  Is it unitary?  Well, that's an exercise for you,  but I hope you can do that sort of while I'm writing.  Here's another evolution in quantum circuits.  It's called Pauli y.  Now, I'll give it the notation that you're going to see used.  Sigma x is the name for this unitary matrix.  This is the notation you're going to see.  Sigma y is the notation for this unitary matrix.  Here's a unitary matrix.  Here's another quantum circuit.  It's called Pauli z.  So you're going to start to see these examples get used all,  all the time in quantum computation.  So there's three matrices.  You can check at your leisure that these three matrices are unitary.  They're all allowed, but there's more, right?  To do quantum mechanics, we're going to need a handful more.  We're going to need the so-called Hadamard gate.  Okay, the Hadamard gate is this two-by-two matrix.  Why this one and not another one?  Historical reasons.  Five, we're going to need the so-called T gate or pi on eight gate.  And that one I have to look up.  Because I never remember the phase.  And typically, I haven't written it down.  Ah, damn.  All right, I don't know.  The T gate, I believe, is 1, 0, 0.  Here we go.  e to the pi i on four.  Someone yell out if that was the wrong gate.  Okay, I hope that was the correct gate.  That is correct.  It is correct?  Fantastic, okay.  And the last gate you're going to need to know to do quantum mechanics is, well...  Sorry, I may...  Oh, no, no, it's correct.  I just thought there was a minus.  All right.  Okay, great.  Then one more gate.  And this one, so far, I've just been talking about qubits, right?  You know, H is C2 for this whole discussion.  But in the last gate, I'm going to talk about a new system, C to the four.  Turns out this is the Hilbert space for two qubits,  but I haven't told you how to do that yet.  But we can still talk about a quantum system whose Hilbert space is of type C4.  In this case, we've got another gate,  which has this picture.  But as a matrix, U is a four by four matrix.  It's got to be unitary.  It's got to act on the Hilbert space, C to the four.  And it's this matrix here.  This is called the CNOT or controlled NOT gate.  Okay, there we go.  That's a list of possible evolutions of closed quantum systems.  And now we come to the last postulate of quantum mechanics.  Okay, it's...  I'm sorry, may I ask something?  Please.  Could you say once again, what do you mean by evolution?  What do I mean by evolution?  Yes, that's actually a horribly deep question.  I'll try my best.  Okay, what do I really mean by evolution?  Okay, firstly, we have to have a notion of closeness of the quantum system.  So that's at least critical.  You know, we have to decide, is the system closed or not?  Okay, and then an evolution is anything that that system does once it's closed,  if you wait some time.  Does that help?  Yes, it helps.  Yeah, and so if you're an experimentalist,  and I know some of you have an experimental background,  it turns out you can kind of cheat, right?  You can get...  You can engineer your quantum systems to do pre-specified evolutions  by being quite clever about how you set up your experiment.  So you ensure that the system is closed,  but closed in such a way that it does the unitary matrix that you want it to do.  And that, you know, involves shining lasers at the right angles,  and with the right coherences, and so on.  Lots of hard work.  I don't want to diminish the effort of experimentalists  in making these evolutions will happen.  But you have to...  At this stage, we just say that evolutions are things that happen  when you close a quantum system off from the environment,  and you leave it alone for a time.  So that could be, for example, a change in space-time?  Like if you have, I don't know, an electron in a box or something?  Yes.  So an electron in a box...  As long as the box is hermetically sealed for the environment,  for the environment, then the electron is going to evolve.  Its wave function is going to spread out, right?  That's an evolution.  That's an allowed evolution.  It's described by a unitary operator on an infinite dimensional Hilbert space.  Electrons actually don't fit into simplified quantum mechanics.  We don't allow them.  Unfortunately, they're too complicated.  But that's...  Indeed, that's an example, yeah.  Okay, thank you.  Okay, welcome.  Good, we're almost done.  I see the time is now 4.30, and that's maybe...  We're heading to the right timing,  because I'm going to tell you the last postulate of quantum mechanics, postulate 6.  And this one's...  This is one where we're going to need a little bit of linear algebra  that you may not be familiar with.  So I've told you that to every quantum system of a certain type,  you have to assign a Hilbert space.  But what if you have two quantum systems?  Or, you know, many quantum systems, and you bring them together.  So if you have a qubit, and you have another qubit,  separately, they're qubits.  Separately, they're modeled by this Hilbert space C2.  But if you bring them together,  then the compound system of the two qubits is also a quantum system.  And according to the laws of quantum mechanics,  so there must be a Hilbert space for it.  Which is the right Hilbert space for this composite quantum system?  Well, the answer is the Hilbert space is by a so-called tensor product.  So you've got, you know, a bunch of your favorite quantum systems  that each model by separately by a Hilbert space.  What's the correct Hilbert space to assign to the compound system?  The answer is H is given by H1 tensor, the scary symbol,  H2 tensor, H3 tensor, blah, blah, blah, blah, blah, all the way up to N.  Okay, that's, at this point, if we were doing this mathematically rigorously,  we'd have to take a digression of several weeks to explain this tensor,  the mathematical properties of this tensor product.  I'm not going to do that.  Instead, I'm going to do a couple of sneaky cheats.  One is you might already know about the Kronecker product.  In which case, you can forget the words tensor product and just  use your knowledge about Kronecker products.  And the other is I'm just going to do some examples until you kind of get the rules, right?  So I'm not going to be setting up the full definition of this tensor product,  because we're only interested in quantum computation with one example.  And we're kind of laser-like focused on this example of N qubits.  So we're always going to be focusing on quantum systems that are composed of  one or more qubits.  And I'll be able to explicitly tell you what is the right Hilbert space for N qubits.  It's pretty easy.  And I'll do it right now.  So you don't ever have to worry.  You'll learn the rules quickly anyway.  But at this stage, it's important not to get hung up about this definition.  Just be pragmatic about its application.  So for N qubits, well, h1 equals h2.  You know, they're all qubits, so they're all modeled by c to the 2.  And so then what on earth is this h?  Well, it's c2 tensor c2 tensor blah, blah, blah, blah, blah, n times.  What does this mean?  Well, actually, it turns out this vector space here is exactly given by c to the 2 to the n.  And I'll explain the rules now for how to build vectors in this bigger Hilbert space,  how to reason about them.  And then we've done the postulates of quantum mechanics.  So let's do that.  OK, well, I'll just work.  Basically, I'm just going to work from examples, build up these examples until you have really  enough information to start extrapolating mentally about how you should reason about  these things in this Hilbert space h.  And OK, let's take n is 2.  OK, let's take two vectors.  Phi is a vector, not a state.  Now, phi is a vector, psi.  Phi is a vector like, I don't know, 1, 2, and psi is the vector i, i.  Now, to build up elements of this weird tensor product space, what do you do?  Well, you take that tensor product.  So there's a way to take, given a vector in one Hilbert space, a vector describing another  qubit, sorry, a vector in this other Hilbert space attached to the second qubit, we can  build up a bigger vector.  What's the rule?  Well, I mean, it has to be, we know it has to live in c 2 to the 2, which is c to the 4.  And the rule is, well, you may have seen this.  So what you do is you take the first entry here, phi, and you multiply it by the entire  vector, psi, in the following fashion.  So it's 1 times by psi, which is i, i, and then you take 2, so this is 1, 2, 3, 4, 5,  and then you take the second entry, 2, and you multiply it by psi again.  So this weird-looking operation gives us a 4 by 1 vector, and the vector is i, i, 2i, 2i.  That's how to compute the tensor product of two vectors.  And what happens if you have three vectors?  Well, you just do this again, right?  You first compute the tensor product of two of them, and then you do it again.  So I'll actually do that example.  So what about, what happens if I had phi, tensor, psi, tensor, phi, like that?  How would I reason about that thing that's in a bigger, this is n is 3.  This vector is given by an 8 by 8 vector.  What we do is we work out that vector first.  Oh, we've done that already.  That's great.  And then we apply the rule above again.  So we get, I'll do it this way, I suppose.  We get 1, the first entry of phi, and multiply it by this whole vector, i, i, 2i, 2i, then  2, i, i, 2i, 2i.  So we get an 8 vector, a vector with 8 entries, i, i, 2i, 2i, 2i, 2i, 4i, 4i.  And that's an element of c to the 2 to the 3, which is otherwise c to the 8.  So I've just told you the rudiments of how this symbol tensor works.  If you've got vectors like this, then the rule is you take the whole vector and multiply it  by the first entry and stack it on top of the whole vector multiplied by the second entry.  That's the rule for applying this tensor symbol.  And with that way, you gain access to zillions of vectors in this tensor product Hilbert space.  What about matrices?  So it turns out if you, yep.  Yep.  Okay, yeah, that's a good question.  Let's do it because you asked the question because there must be some ambiguity in what I said.  So let's see.  Like that, yeah?  Okay, can I cheat a bit?  Yeah, I can.  So I'll do this one first.  Ah, yeah.  Okay, now I see where the question's coming from.  Actually, it's a good question.  Um, all right.  So let's write out that vector here that we got it there.  Here, i, i, 2i, 2i, tensor phi, which is 1, 2.  Now we look up above.  How do we do this trick?  So what we do is we take the first entry and multiply it by the second vector and stack it.  So I'll try and I'll do it like this, right?  So what we do is you take the first entry, multiply it by the whole vector,  and then stack it up on top of the second entry,  multiply it by this vector and stack it up and so on.  So I'll just do it and then you might help you.  So i times by the whole vector.  So it's i, 2i.  Then i multiplied by the whole vector.  It's i, 2i.  Then we've got...  Can I just do the same thing actually?  Yep.  All right.  Exactly.  So that's how we would do that tensor product there.  So it's a good question.  Um, yeah.  Basically I'm outsourcing to the questions all the rules of the tensor product symbol.  Already with this recipe, you'll have started to detect some patterns and rules.  For example, if I take a vector and I multiply it by a scalar factor, like...  So if I do phi tensor psi, but I have like some scalar number z.  So z is a complex number.  You know, imagine I work out...  First I multiply the column vector psi by z and then I do the tensor product.  It turns out that's just the same, right?  If you go through the rules above as first doing the tensor product and multiplying it by that  scalar number and so on.  There's a whole bunch of rules that I leave it to you to work out.  And you'll gain experience with these rules.  What about if I have two vectors and I add them first and then take the tensor product?  Well, it turns out that the tensor product is really...  There's a reason why it's going to multiply symbol.  It sort of acts like a multiply symbol.  And so this is really exactly equal to the sum of these two vectors.  So you can work one out, work out the first tensor product, work out the second one, then add them.  That rule is absolutely okay.  And how would you do this in a programming language?  So many of you might be not as old as me, but if you are, you may have experienced MATLAB.  And this tensor notation in MATLAB, you can actually implement with the so-called cron function.  And I would do this in MATLAB like this.  So in MATLAB, MATLAB does this for you.  So you don't have to do the stacking up and multiplying things.  MATLAB will be quite happy to supply you with this tensor product in MATLAB.  I don't know about NumPy, the Python implementation.  Is it called cron there as well? Probably, right?  But any decent programming language with a numerical linear algebra routine  will give you a Kronecker product or tensor product operation.  So, so far I've just...  It's called NumPy, it's also called cron, is that right?  Oh, fantastic.  Okay, then you haven't, I haven't told you any lies.  That's great.  Okay.  And so there's, well, there's lots of programming languages,  whatever ones it takes your fancy, you should use.  But probably most of you will be, as you get into quantum computation,  you'll be exposed to quantum libraries that are based on Python, right?  This is somehow inevitable.  These days, there's Qiskit that's very popular right now  as a way to model quantum systems in quantum computation.  There's also Penny Lane and dot, dot, dot, dot.  There's a growing list of libraries with which you can model quantum circuits,  and they should all, if they're decently written,  give you some version of this tensor product operation.  Now, I've only explained this tensor product operation for vectors.  I haven't, in fact, told you how to take the tensor products of matrices  or of states and so on.  So we're almost done.  How do you take the tensor product of matrices?  Well, it turns out there shouldn't be too many surprises for you  now that you've seen the vectors case.  So suppose we have two Hilbert spaces, that's two vector spaces,  we have two matrices.  Let's be super explicit, like, you know, A is 1, 1, 1, 2,  and B, just to make things spicy, will be a 3 by 3 matrix,  2, 1, 2, 1, 2, 1, 2, 1, 2.  How do I work out?  There is a rule that tells you how to build a matrix  that represents doing, applying A on the first Hilbert space  and B on the second Hilbert space.  And the rule is pretty much a version of what I've just showed you.  So 1, 2, 3, 1, 2, 3, 4, 5, 6.  So what you do is you take the 1, 1 entry, oops,  multiply it by the entire matrix B, oops,  and then stick it in the appropriate place.  So you do, I'll just go ahead and write it down.  You do, I'll just go ahead and write out this.  So we get 1 times by 2, 1, 2, 1, 2, 1, 2, 1, 2.  And then we take the second entry, 1, 1, 2, 1, 2, 1, 2, 1.  And then we get, well, another 1.  And then 2.  That's how you build up this tensor product of A and B.  This is also, by the way, in MATLAB, or I guess Python, written cron A, B.  So now we have a rule that if we have a matrix acting on a smaller vector space  and another one, we can build a matrix that acts on the tensor product of those vector spaces.  And you can quickly reason  by way of examples that this tensor product symbol behaves, well,  pretty much exactly like I've described above for vectors.  Because vectors, by the way, are just examples of matrices, right?  Matrices with many rows and one column.  Okay, so now I've given you a whirlwind tour of the tensor product by way of examples.  And we're finally done because we can now describe  how to model quantum circuits.  And we're going to apply the postulates of quantum mechanics in turn, right?  So every one of my students gets used to going through the list of postulates  every time they consider a new quantum system,  and they're like, well, I'm going to do that.  Every time they consider a new quantum system,  and then after a while, you just get better and better at remembering them,  and you don't ever write them down ever again.  But for the first few times that you model a quantum system,  you should go through the postulates.  So what does postulate one tell us?  Postulate one tells us that a qubit should be attached to a Hilbert space C to the two.  But if you combine that now with postulate six,  then the right Hilbert space for n qubits is actually C2 tensor C2, blah, blah, blah, n times.  Now postulate two talks about preparations.  Well, what's a valid preparation?  A valid preparation is a density matrix.  It's a density matrix.  And this density matrix acts on this very high dimensional vector space.  It's worth saying that the dimension of n qubits,  what's the dimension that is a vector space?  Well, it's two to the n, right?  So if you have every qubit you add, you double the dimension of this vector space,  this underlying vector space.  So preparations are density matrices.  They're two to the n by two to the n matrices.  Oh my gosh, how can we work with these things?  This is in fact part of the power of quantum computers  that a quantum computer can with linear experimental cost add in qubits  and therefore simulate the application and manipulation of very large matrices.  Now, it turns out to be very difficult to reason about these large matrices in general,  but what we do is we have this list of fundamental or basic preparations that we're allowed to do.  And one of them is you separately prepare your quantum system, separately  prepare your qubits.  Prepare your qubits.  And then the correct state describing the joint compound system is then even by the  tensor product.  So you separately prepare the qubits in row one in this list of density matrices here.  These are all acting on C, they're all two by two matrices.  Right?  And then what's the correct preparation?  For the full system, the full preparation is then described by the tensor product.  Row is given by one tensor, row one tensor, row two tensor, row three.  It quickly becomes a nightmare to write this matrix out.  Nobody, when n is four or five, people stop writing out these matrices in matrix form,  because it just becomes so unwieldy to do so.  Okay, I will do it though in the case of n is two.  Let's prepare our state in an x.  So qubit one gets prepared in the x preparation.  And qubit two in z preparation.  What's the correct way to describe the global preparation of the system?  Well, the global preparation, separately preparing them, is the same as taking the tensor  product of their preparations.  That's what the definition above says.  And that means that we've got to take the tensor product of this matrix, a half, a half,  a half, a half, and one, zero, zero, zero, zero.  Okay, that's what the global, the whole system of two qubits,  it's now described by this density matrix here.  What does that matrix look like?  Well, I'm going to work it out explicitly for you.  It's a half, zero, zero, zero.  It's a half, zero, zero, zero, a half, zero, zero, zero, and a half, zero, zero, zero, like so.  So that's the actual matrix that gets prepared if you separately prepare the qubits.  And I leave it to you as a little homework to do qubit one in the z, or let's put it in the x.  So we'll do three qubits, qubit two goes into a y, and a qubit three gets prepared into a z.  Preparation.  That's a, yeah, well, it's not a totally trivial matrix to write out.  It's an eight by eight matrix.  You can check it with MATLAB if you're concerned that you may have made a mistake.  Okay, so that's how to do postulate two when we have more than one qubit.  What we generally do is we, in order to keep the problem easily to describe,  is we separately prepare the subsystems, the qubits.  We form the, describe the full preparation with this tensor product.  And then, and only then, do we start doing operations on the system.  So I won't talk about measurements, postulates  three and four.  We'll just leave them for the moment.  I'd rather focus on postulate five, because that's where the quantum circuits are.  Now, this is sort of winding up for today with the final definition of how a quantum circuit acts.  A quantum circuit is an evolution of a closed quantum system.  So it's a unitary matrix, according to postulate five.  It's a unitary U that acts on a Hilbert space to a Hilbert space.  So what is it?  Well, it's a 2 to the n by 2 to the n unitary matrix.  Now, you've already begun to get a sense of how difficult it is to write down these matrices,  write these 2 to the n by 2 to the n matrices.  So we have a very neat shorthand way to describe quantum circuits,  which doesn't require us to write out the full matrix.  And for that, we use quantum circuit notation  to specify certain unitary procedures that you can do.  And I've already started to introduce this quantum circuit notation.  So I better tell you some of the rules, right?  OK, so if we have the Hilbert space of n qubits,  then I've got to tell you some basic rules.  So how to understand this quantum circuit notation.  Firstly, doing nothing.  What does that mean?  Well, doing nothing is represented by n horizontal lines.  Doing nothing is a very important operation in physics and is represented by  the identity operator tensor, the identity operator,  n times, which is 1 0 0 1 tensor 1 0 0 1 tensor dot dot dot.  But that's actually just a really big identity matrix, right?  The 2 to the n by 2 to the n identity matrix.  So doing nothing is a fundamental primitive in quantum circuits.  You need to be able to represent it as a unitary matrix.  You need to have some pictorial notation to describe it.  And that's it there.  The next notation we have is do a single qubit unitary, it's called.  So a single qubit unitary is a unitary that acts on a single qubit.  But doing a single qubit unitary is the same as doing nothing on the other qubits.  So you choose your favorite qubit, call it qubit j.  And then you do a unitary on that qubit and you do nothing on the rest.  What's the operation represented by this sentence and graphically by the following circuit?  So you do nothing on qubit 1, you do nothing on qubit 2, do nothing on qubit 3.  But on qubit j, you do the unitary.  And on j plus 1, we do nothing.  So the unitary represented by this circuit and therefore an allowed evolution of a closed  quantum system is given by the following unitary.  You do tensor product of the 2 by 2 identity.  I'll just write it out, OK?  1, 0, 0, 1, 1, 0, 0, 1, right?  For every qubit, you do nothing individually until you come to the jth qubit.  And then you do the 2 by 2 unitary and then you do nothing until the end.  OK, that's the unitary matrix that represents doing a single qubit unitary.  Very important unitary matrix.  We're almost done.  In fact, we only have one more unitary matrix to describe.  OK, I'll cheat a bit.  Doing CNOT on two qubits.  OK, what does it mean to do CNOT on neighboring qubits?  Well, it means to do CNOT on neighboring qubits.  So what does it mean to do CNOT on neighboring qubits?  OK, what does it mean to do CNOT on neighboring qubits?  Well, here's the picture.  We do nothing on 1 to 2, but on qubit j, there's a picture for doing CNOT.  It has the following diagram.  You've got a kind of a plus symbol joined with a line to a dot on the jth qubit,  but then you do nothing on the j plus 2 qubit and so on.  What's the unitary matrix that represents doing CNOT on neighboring qubits?  Well, I'm hoping you're starting to spot the pattern by now.  It's 1 0 0 1 tensor 1 0 0 1 tensor dot dot dot dot dot dot all the way up to,  and then you have the CNOT gate, which is a unitary operator, which is a 4 by 4 matrix.  And this is, you know, in factor 1, factor 2.  And then this is on factor j and j plus 1 qubits j and j plus 1.  So the unitary, which represents doing CNOT on neighboring qubits j and j plus 1 is given by  1 0 0 1 tensor 1 0 0 0 0 dot dot dot dot dot dot dot dot dot dot.  one is given by this big, big matrix here. I won't attempt to write it down, I mean you just quickly  learn not to do that because it's too spatially demanding. There's one operation we're going to  need before I can tell you a very important theorem, and then we can sort of draw today's  discussion to a close, and that is a swap. There's a special kind of unitary called swap.  A swap is the following two-by-two matrix 1 0 1 1 0 1, and it does what you think it does,  it swaps qubits j and j plus 1 or two qubits. In circuit notation it looks like this,  and you can imagine what do swap on j and j plus 1  means.  What does this mean? Well in circuit notation we draw this picture  and the corresponding unitary operation is this one, 1 0 1 1 0 1.  So now I've given you a laundry list of basic unitaries that you can define on n qubits,  and I've given you a way, I've given you the recipe for how to build up the two-to-the-n-by-two-to-the-n  unitary matrix, so the doing nothing, doing a single qubit unitary, doing a c0 on neighbouring  pairs, and doing a swap on neighbouring pairs. And now comes an amazing theorem.  So this is a, we can even prove this theorem, not today, but I can describe to you the entire  argument. It's a very beautiful theorem in the coming weeks. Theorem for all unitaries,  I'll write it like this, all unitaries u acting on n qubits.  So this is where quantum computation becomes computation right now. This is the so-called  universality result, may be represented as a product of how many, many  fundamental unitary  quantum circuits, I will not get this bit right, as a product of,  I believe it's two to the two to the n question mark exclamation mark of  of quantum gates. I didn't introduce this terminology yet.  Sorry, just put that in here. So unitaries one through four that I've just described above  are called primitive, that's my notation, so I'll delete that, they're called quantum gates.  All of these things here are examples of quantum gates. Examples one and two are examples of  single qubit gates, like doing nothing is like just doing nothing on qubit j. So these are called  single qubit gates. They're allowed evolutions of closed quantum systems. Doing c not on neighbouring  qubits is a two qubit gate, right? We've got qubit j and j plus one, something happens to them. Swap  is a two qubit gate. Unitaries one to four, they're all examples of quantum gates. So this is  terminology, right? It's, nothing's changed, they're just unitaries, but we,  they're special kinds of unitaries, ones that we think we can apply in experiments with less cost.  And now comes this amazing theorem. It says that no matter what unitary you want to do,  so if you have some unitary, your favourite unitary on n qubits, big 2 to the n by 2 matrix,  and you wonder, how could I do this unitary in an experiment? Well, the answer is you can  by multiplying a certain sequence of single and two qubit gates.  There's a product of on single and two, there's a product of single and two qubit gates.  So, you know, you have your favourite unitary u that you want to implement for whatever reason,  it's a 2 to the n by 2 to the n matrix.  And it turns out, turns out that no matter what u you choose, I mean, this, you know,  potentially 2 to the 2 n complex numbers there, you can always represent that as a product of  gates, of single and two qubit gates.  And which gates do you need to bring under consideration? You know,  which gates will appear in the sequence? Turns out only a finite set, even with a finite set  of single and two qubit gates, you have enough gates to express any unitary as a product.  And the gates you need in order to express any unitary, so this is universality,  the Hadamard gate, the T gate, the CNOT gate, and the swap gate.  With just these four gates, you can represent any unitary on n qubits.  This is called universality of this gate set.  Now, I want to contrast this observation with one that you possibly know from classical computer  science.  You may know that the NAND gate is universal for classical computation,  meaning that any Boolean operation can be expressed as a composition of NAND gates.  This is the, this result I've just described here is the analog of this  resulting classical computer science. So the NAND gate, right, you know, is this gate here  with this following tree, right? And this is the gate that I've just described here.  The NAND gate, right, you know, is this gate here with this following truth table, x, y, z,  oops, x, y, z, 0, 0, 0, 1, 1, 0, 1, 1. So it's the NOT of the AND, so it's that, right?  So you can express any Boolean function in classical computer science as a composition  of multiple NAND gates, right? That's the NAND gate by itself is sufficient to carry  out any computation classically. And here we have just seen the quantum analog of this.  Any unitary you want to do, that's any allowed operation for a closed,  any allowed evolution for a closed quantum system is a unitary.  Any unitary you care to do can be implemented as a product of single and two qubit gates,  and the gates you need, really, you can boil them down to this one of these four.  So although the NAND gate doesn't appear in that list, we have these other gates,  but these are by themselves sufficient to express any operation in quantum mechanics on n qubits.  So this is a high point in the theory of quantum computation, that these gates are  computationally universal, and it's the one that we can, that allows us to build,  to use the quantum circuit abstraction as a useful abstraction. So, you know,  these quantum circuits that are drawn here with lines and dots and boxes and so on,  this is a useful diagrammatic abstraction because of this universality result, right?  We're guaranteed that any unitary we want to apply will be written as a product of these gates.  Can I ask a question?  Please.  So how do you do nothing?  Uh, you just, that's really a good question. So experimentally doing nothing is super hard.  Like you have to-  But I mean, with these four matrices, like if you just have a two by two, then you don't need it.  Yeah, right. So a two by two matrix that does nothing is this matrix. Here's the identity  matrix.  But it's not one of the four.  Oh, oh yeah, okay. Okay, I'm gonna get out of this. Yeah, no, it's a good question, actually.  It's not one of the four.  Well, it turns out that if you take T to the power four, that's the identity matrix, right?  So T is this matrix, one, zero, zero, E to the pi, I on four, sorry, eight, right?  So if you take that matrix to the power eight, so you do it eight times in composition,  you'll get the number one.  And so the matrix you get out at the end is one, zero, zero, E to the eight pi on four,  but that's one, zero, zero, E to the two pi I, which is just one.  So indeed, that's a good question. Like how do I do nothing,  the identity without that being in our list of allowed gates?  The answer is you do T eight times, which is a super stupid way to do nothing.  Like a much more efficient way to do nothing, of course, is just to do nothing.  But no, that was an excellent question.  All right, I've come to the end of what I wanted to tell you about quantum computation.  So I'll just scroll, zoom out.  Can I have a follow up question?  Please.  And so can that be interpreted in something like rotating eight times,  and then you're at the beginning again?  Yes. Yeah, if you're familiar with the Bloch sphere,  we're doing like a rotation of two pi over eight on the Bloch sphere.  So you do it eight times and you come around again.  Perfect. Thanks.  So I want to take us to zoom us out and take us  through a sort of highly zoomed out summary of today's material.  So I started by telling you who this course was for,  and then I introduced you to simplified quantum mechanics,  which is a list of postulates that you apply  to model mathematically any quantum system allowed in simplified quantum mechanics.  And there are six postulates in all.  The first postulate concerns the playground for the quantum systems, the Hilbert space.  The second postulate concerns preparation.  How do we describe preparations?  The third postulate and the fourth postulate apply to measurements.  How do we detect the system and get information out of it?  How do we model that mathematically?  Postulate five is concerned with what happens  if we leave the system closed and leave it alone for a while.  And postulate six tells us how to model  many quantum systems composed of fundamental atomic quantum systems.  And then I went through a list of accepted dictionary of accepted evolutions,  that are attached to certain names.  These names are quantum gates,  so quantum gates are just evolutions of closed systems.  And then I introduced you to this amazing result that says  that with a finite list of quantum gates,  we can express any unitary as a product of these finite gates.  So that's where we come from today.  And where we're going to go in the future  is I'm going to show you how with a combination,  a clever combination of preparations, evolutions and measurements,  we can extract the answers to computational problems  using fewer quantum gates than the best known classical algorithms  to solve the same problems.  That's called quantum computation.  It's really the topic of the next talk coming in a couple of weeks.  But for now, I think I'm done.  Thank you very much. 