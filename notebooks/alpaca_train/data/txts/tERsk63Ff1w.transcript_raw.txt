 Hi guys, in this video we're going to deploy a web app to Azure and we're going to configure  an Azure Pipeline DevOps process so that we have a continuous integration and continuous  deployment which essentially means that on every GitHub commit and every push we trigger  on GitHub or every repository, it doesn't matter, our web app will going to be built  automatically, its tests will going to be automatically run and validated and if that  passes we're going to have an automatic deployment to an Azure App Service.  Just to let you know, the process of building and deploying is a little bit slow so at times  during the video I'm going to hit the pause because I don't want to have some empty minutes  on my video and when everything is done I'm going to continue the video so if you see  some sort of flickering or if the video is cut it's because there is actually no need  to sit and wait and not talking about anything.  Also I would like to mention that I have a lot of experience with other DevOps websites  and portals like Appware, like Travis CI, like Octopus Deploy so if you want to see  how to deploy an app using a different service than Azure Pipelines let me know and I'm going  to create a video about it.  But the thing is that all of these systems are quite the same, it doesn't matter whether  you're going to use Travis CI or Azure Pipelines, it's the same.  The only difference is a little bit of configuration here and there but that's usually copied from  some sort of documentation or you just need to turn on some options for example to make  the thing work.  So essentially the principles we are going to see here in this video apply to every other  platform which provides DevOps operations.  So first things first, what is continuous integration?  Continuous integration means that your code is validated on a standalone server, it's  built and its tests are run.  These are two common tasks that you can see in almost every project.  So essentially what I can do is I can instead of running all my tests locally I can trigger  a build.  If I have too many tests and I don't want to wait for 15 minutes for example I can just  push my code and wait for the continuous integration service to report results.  That's one thing.  Also another positive side of using continuous integration is that usually when you develop  alone you won't have that much problems, you won't have that much changes to your system,  you won't have that much issues or bugs or whatever.  But when you work in a team, when you work with more than five people for example and  everybody is merging code in the same repository, in the same place, bad things happen because  you may change a module which is required by someone else's work but he didn't reflect  the change in his part of the system and everything will work correctly on your machine but when  you merge the code and upload it, it will show that you have some bugs, you have some  problems and so on.  So the main idea is to make sure that the team and the whole source code that the team  is building is working correctly every time on a separated, isolated environment.  Because you know that it works on my machine but it doesn't work on the production, that's  a common problem and part of the problem is that you are working in a team environment.  So continuous integration will help you with that.  If you have automatic builds of your source code or automatic tests, you will be sure  that your code is completely fine or is having some problems.  But nevertheless, that's the main part of continuous integration.  Of course, you can do other tasks, for example, minify CSS, minify JavaScript, combine all  the JavaScript files and so on and so on.  You can do a lot of different tasks on a continuous integration server but usually the most important  ones are restore the dependencies, build the project, run the tests.  If everything passes, you're good to go.  About continuous delivery or continuous deployment, because usually it's CI and CD, CI is continuous  integration but CD is, people normally refer to CD with the term continuous delivery but  you may also see it as continuous deployment, it's the same thing.  What is important about continuous delivery is that you have your code deployed every  time a change is pushed to the repository, which is a very nice thing because your customers  will have the latest version of your app directly deployed every day.  So you make your clients happier this way.  Additionally, you no longer will need to have development cycles.  We are going to release this day and so on.  Of course, that process with automatic delivery is not applicable to every single project.  First, you need to have tests.  If you don't have tests, it's a little bit risky to deploy every push, that's understandable.  But if you have a lot of tests and if your code coverage is good enough, you may trigger  a deploy on every push.  Stack Overflow is using this strategy.  They have everything automated from the coding to the deployment.  So when the developer codes something and decides to push it, everything is automatic  from here on.  So every push triggers a deployment to the Stack Overflow system.  The only thing they do manually is database migration.  I know that because I haven't worked at Stack Overflow, obviously, but I've read a lot of  blogs where they share what are their processes, what are their infrastructures.  If you haven't read these articles, I suggest you take a look at them because they have  a lot of valuable information.  But if Stack Overflow, which is a huge system with a huge number of users, can afford to  risk to have a continuous delivery process, then it's applicable to everyone.  As long as you have some integration tests going on, as long as you have some unit tests  written, you should be fine.  Okay, so this application here is a simple block system.  It has tests.  You may find it in my GitHub profile, Vyval Kenov, and in my test.asp.net core.mvc tools,  which essentially, you know, you may know that these tools are for fluent testing and  easier assertion of web applications written with asp.net core.  If you go to samples, if you go to block, this is essentially the project we are going  to use.  We have 73 tests.  These are written with my tool, but never mind that.  Actually, if they pass or if they fail, everything is correct in terms of the process.  So we're going to fail some tests.  We are going to make some tests run smoothly and so on.  Okay, first things first, we need to deploy the application.  So I'm going to deploy to Azure.  So let's go to azure.microsoft.com.  Let's sign in.  I'm already signed in, so I'm going to hit portal.  So in the portal, what I need to do is I need to create a new app service.  Essentially an app service is a web application you can deploy.  For example, asp.net core app, Node.js app or whatever, actually.  So the easiest way to deploy a web app to Azure is by using app services.  So I'm going to create a new app service.  So first things first, because you may not have an Azure account, it's easy to create  one.  They require you to put a credit card, but they have three tiers.  So if you decide to follow this tutorial or if you decide to deploy an app there, you  have three options, so it's completely fine.  Also, if you just do the tutorial for educational purposes, you can delete the app afterwards.  It won't cost you a thing.  So if you register on Azure and enter your credentials, there's a lot of free goodies  you can use.  I suggest if you're an active.net core developer and haven't used Azure yet, just go and try  it.  It's very simple.  It's very easy to create new apps.  I really like it, actually.  So I need to specify a resource group.  Resources in Azure are essentially different kinds of services you are using for your app.  For example, a database, for example, a web app, for example, some sort of message broker,  whatever.  These are resources, and in order to be easier for you to navigate in your resources, you  may provide a resource group, which is a group of resources, like a namespace in the C-sharp  code.  So I'm going to create a new one, and I'm going to specify Azure pipelines blog.  Good.  So I'm creating a new one.  I'm going to create Azure pipelines blog to be the app name.  It's available, so I'm going to continue with that.  I'm going to publish codes.  I'm not going to use Docker images for now, but if you want me to create a video with  publishing Docker images, I can create that too.  Good.  So I'm going to choose .NET Core 3.1 because my project is .NET Core 3.1.  I'm going to, it doesn't matter whether I'm going to use a Windows or a Linux.  Let's stick with Windows.  Good.  Let's choose Europe because I'm located in Europe, but you can choose your location,  and I want to have app service plan, which is the most important part here if you don't  want to have any costs on your credit card.  So the S1 tier is paid, so I need to create a new one.  Azure pipelines blog plan, something like that.  Okay.  Let's create a new one, and I'm going to change the size of this thing because I want to be  completely free.  They changed the UI here, so I need a little bit of, I need to recognize what is what,  but we're going to do it nevertheless.  Also what's important is I haven't prepared this lecture in terms of, I haven't tested  the Azure pipelines with this project.  So that's at the same time a good and a bad thing.  A good thing is because for you, you will see any problems I encounter, which is kind  of nice because you're going to see how I'm going to solve them, but essentially it's  bad because it will take us a little bit more time.  But I believe that live debugging and live issues are fine when teaching because it's  really frustrating to see your teacher doing everything, working correctly.  It's fine.  Everything is fine.  It's perfect.  Then you try it yourself and you run and you see all kinds of problems.  So that's essentially not a good thing.  Okay.  So on DevTest, there's a free app service tier, which allows you 16 minutes per day  computing time.  This is more than enough, more than enough.  If you want to test apps to just educate yourself, so choose it.  If you want to have a website, which is used by not many people, you may choose the shared  infrastructure, which is something like eight years a month.  There are cheaper ASP.NET core hostings, but essentially if you decide to, if your  website becomes more popular, you may choose very easily a more expensive pricing tier.  So I can suggest to you that you may use Azure for simple sites.  For example, this MyTestedASP.NET website is hosted on Azure.  The whole thing is hosted on Azure.  It has a database.  It has a lot of things here, like an email service and something like that.  And because Microsoft is giving away a lot of free goodies, this site costs me something  like two to three euros a month, and it has more than 5,000 views every month.  So it's okay for simple apps too.  So I'm going to choose the free tier.  I'm going to hit apply, and I'm going to hit review and create.  I don't want to have any monitoring or all that advanced stuff.  Good.  So .NET Core 3.1, Windows Westero 3 should be fine.  Let's create that.  The Azure will start to deploy this service.  So when it's ready, I'm going to use it in my Visual Studio Publishing.  Then I'm going to use it in the Azure pipelines.  What we'll need also is, yep, that's good.  Go to resource.  Nice.  Okay.  So I created the app service from here.  I will need the database because this system has a SQL Server database, but I will try  to create it through Visual Studio so that you can see the other process because the  same thing we did here, the same thing, creating an app service can be done by Visual Studio  directly.  So how to do that, how to publish the app, you need to hit the right mouse button on  your web app and hit publish.  It's here.  So when we hit publish, first things first, we need to choose Azure because yeah, we don't  want to publish the app anywhere else.  Then we need to choose the app service.  I already created the Windows one, so let's use that one.  And here you can log in in your account and Visual Studio will automatically show all  the resources you have, all the app services.  You can see the Catstagram if you are familiar with that from my YouTube account.  You can see the mytestedsp.net website I showed you earlier, this one.  So Visual Studio will show you everything here.  So I can choose Azure pipeline block, but I can also create a new app service from here.  I'm not sure whether you can choose the free tier from here, whether you can create a free  tier.  Yeah, you can create it.  OK, it's fine, but nevertheless, essentially, it's the same.  So I'm going to choose the Azure pipeline and I'm going to hit finish.  Good, so it's cool that Microsoft or Visual Studio for that matter, so that I have a database  here, I have some default connection.  I have, let's change that, the database can be azure.pipelines.block or something like  that.  Let's remove the dots.  It's strange for a SQL server database to have dots.  So essentially, Visual Studio saw that I have a database and my app needs a SQL server database.  So let's hit configure and let's choose a database.  If I choose, I can choose a SQL server database, which I already have.  For example, if I purchased somewhere or I have a server with a SQL server installed  on it or whatever, but I can choose Azure SQL database if I want to use the Azure database.  So here are all my databases for the catstagram, for the mytest.asp.net website, and for some  random game that I don't even remember, but nevertheless, OK, I need to create a database.  So I'm going to specify the name.  The database will be called azure.pipelines.block database or something like that.  What's the problem here?  Yeah, the database server is required.  It's a little bit strange because you first choose the database name and then you choose  the database server.  OK, I'm going to create a new server.  I'm going to choose West Europe.  I need to specify some administrator username.  So let's administrator.  OK, so azure.pipelines.block seems fine.  I'm going to choose a password.  OK, let's.  It should be hard to remember password.  I'm trying because it's an educational content.  I try to have something more easy to follow.  I won't need that password, but nevertheless.  OK.  This is fine and database server, resource group, pricing, create.  So I created the database, make sure that after you create the database from here, because  I didn't choose a pricing plan, make sure that you go to the Azure portal and see whether  the pricing plan of the SQL server is a little bit too much for you, because usually the  app services are cheaper and the database, the databases are that are more expensive.  So let's wait a bit.  It should be ready soon.  If I hit resource group, I can see all the different resource group which I used, and  if I go to azure.pipelines.block, I would, I guess I would see the SQL server too here  besides my plan and my app service.  Azure automatically creates an application insights, which is a reporting service for  your app, whether it's healthy, whether it's working correctly, how many requests it received  and so on.  So that's automatic and it's free.  Okay, I'm going to pause the video now because it usually takes a few minutes and I'm going  to continue afterwards.  So the database was created, we can see it here.  Let's go through the Azure portal and check whether it's an expensive database.  So this SQL server, let's see whether it has some sort of a plan, SQL databases, pricing  tier.  Good, so every time I use the Azure portal, something has changed, but nevertheless, I'm  going to find it.  Pricing tier standard, 10 DTUs, this should be, this should be fairly free.  So currently I cannot choose, I cannot choose a free database.  I will have some costs here.  Let me see whether I can choose something more.  Okay, let's, let's create this database.  It's not that much.  This is essentially not high performance database.  You can choose how many DTUs your database will have.  A DTU essentially means how, how your database computement is calculated.  So, and of course, it means that you have a lot more.  Let's put it this way.  If you have more DTUs, you have more performance and more costs.  So let's choose the, the most simple one.  Keep in mind that even though I've chosen a database, which is paid, by default, Azure  gives you some free dollars, free credits you can use if you didn't.  So here, here they are.  I have a subscription, which has free credits, something like 50 euros a month.  They give that to everybody.  And for the first 12 months or something like that.  So if you decide to test the database, it won't be a problem because you have a lot  of, a lot of credits you can use to test your app, but make sure that you delete  the app afterwards, because if you, if you forget it, you may hit the problem that in  one or two years, it may start charging you.  Check it, check it for yourself, but nevertheless, it doesn't matter.  This database here, I'm going to leave on one gigabyte.  This database here will not exceed my credit.  So it doesn't matter.  Okay.  So I have the database.  I checked it.  If you, if you want to delete the database and the app service afterwards, you can do  it from the delete button here.  I'm not going to do that.  Good.  So I'm going to choose Azure Pipeline database.  Let's hit refresh.  Azure Pipeline, next.  Next.  Database connection.  Azure.  Problem is, is I don't remember.  Yeah, this is the ID, Azure Pipelines block.  Luckily, I remember the password.  So the password, I don't care about the password, but somebody may decide to hack  into this database and it may overcharge me.  I guess you won't do that, but nevertheless.  Okay.  So project changes for dependency.  Okay.  NuGet packages, good secret stuff.  Okay.  I don't care about that.  I don't have NuGet packages.  So this will take a while, I guess.  Oh no, it's ready.  Okay.  Done.  So I have a database.  I have a web app.  So what I need to do now is hit publish.  I will hit publish.  You need to wait for the build to complete.  I believe it will be a matter of seconds.  So let's wait it.  Then if everything is published correctly, if I go to the website, which is this one  here, azurepipelinesblog.azurewebsites.net, my blog should be working.  So let's wait a little bit.  The app is now deployed.  Database is migrating.  The app service is a free one, so we can't expect it to be fast enough.  And here it is.  The blog is live.  We have the seeded data.  Nice.  Okay.  So you saw how easy it is to use Azure.  I created and deployed an app, which is available to the whole world in, what, 20  minutes.  So it's very easy to use Azure.  It has free plans.  It has free credits.  So make sure you check it out as well.  And guys, Azure is not a sponsor or Microsoft is not a sponsor.  I just like the cloud.  It's every time I used it, it was a piece of cake.  This is why I'm recommending it that much.  Okay.  So we deployed the app, but you know, that's not very, that's not very convenient to  deploy it manually.  Yeah.  After the first configuration, every time I need to deploy the app again, I need just  to hit publish and everything is configured here.  I just need to hit the button and it's done.  But still, if I want to have continuous deployment, I need to set up the Azure  pipelines.  So let's go to, I'm going to leave that for now.  Let's go to Azure.  Actually, it's dev.azure.com.  This is the one.  And we are going to now create our first project.  First, you need to log in and all that stuff, but that doesn't matter.  So I'm going to create the project Azure Pipelines blog.  I want to have a description.  I want it to be public.  Wait a minute.  Before doing that, we need to create a GitHub repository for this project.  So I'm going to create a GitHub repository.  Wait a minute.  Before doing that, we need to create a GitHub repository for it.  You may use a repository on Azure directly.  It doesn't matter.  You can choose a GitHub repository.  Also, you can choose an Azure repository.  It doesn't matter.  But I'm going to create a new repository on GitHub.  I'm going to use GitHub.  So let's hit Azure Pipelines blog.  Good.  If you want to have a public repository, your project here should be public too.  If you want to have a private repository, your repository should be private too.  So let's have a readme.  Let's have Gitignore for Visual Studio and some GPL license or creative commons, whatever.  So let's clone the repo somewhere.  I'm going to create a new folder just to clone the repo there.  Good.  Then I'm going to move everything inside it.  Yeah, but I need to close that.  Yeah, but I need to close the solution first.  I'm done.  Good.  Then I'm going to move that outside of that.  Oh, I didn't move the blog solution or Visual Studio just created a new one for me.  Let's move that.  Just to make sure that everything is fine and I'm going to move the repo into the here.  I'm going to remove that folder, which I create temporary for Git.  Good.  So Git commit.  The whole problem and why I did that temporary folder is because Git is not happy when the  folder is not empty.  That's the reason.  That's the reason.  Okay.  So I added the initial blog.  So let's commit, push.  And now our code should be available here.  Great.  Good.  So let's choose public on advanced.  I will choose Git and I'll choose Agile.  Agile is a little bit better.  It has more options.  So choose it.  I'm going to create a project.  The most difficult part of Azure pipelines is the YAML or WML.  I'm not sure how to read that.  The YAML configuration, but this is why I prepared a lot of documentation links, which  I'm going to copy later just to, because you will find a lot of useful examples here, which  you can use.  Okay.  So the Azure DevOps essentially gives you a lot of things.  For example, Kanban board, GitHub repository.  You can use this instead of GitHub pipelines, which is the continuous integration, continuous  delivery, test plans, and so on and so on.  So I'm going to hit pipelines because we are going to use that.  We don't care about Kanban boards and I'm going to create a pipeline.  So it will ask me what I'm going to use.  I'm going to use GitHub.  If you decide to commit to Azure, you need to choose the Azure.  So I'm going to choose GitHub.  You need to authorize GitHub to have access to your repositories because you want to have  a trigger when you push the code.  So you need, we need to authorize Azure pipelines.  I'm going to put my password here and now I should be able to choose all my repositories,  but this is Azure pipelines blog.  Yeah, I would like to give access to this blog, these permissions.  Cool.  This was strange, but okay.  I was already logged in.  I was already logged in.  Good.  So it will ask me what kind of project I have here.  So essentially I have an ASP.NET Core project.  You may choose the old ASP.NET ones, but I have ASP.NET Core.  So this is the tricky part.  Once you configure this YAML file, everything will be fine.  Initially we have some configuration.  For example, we need to, our project will be built in release mode and it will be run  on Ubuntu, which is kind of, it's okay.  Then what are going to be the steps for our continuous integration process?  It will just run .NET build.  That will be our initial process.  I'm going to save that.  Commit message, set up CI with Azure pipelines.  Okay.  Commit directly to the master branch.  Sure.  So I'm creating the pipeline now with the initial configurations.  I'm going to add more.  So what we have now, we have a job, which is Qt to run.  This job means that every time you push a new code to your repository,  a new job is triggered.  Then some agent will get the code and will restore the packages and it will build your  solution.  So essentially currently this is still running.  So it takes one to two minutes to, because the job needs to clone.  It needs to clone the repository.  Then it needs to restore packages.  Then it needs to build the project.  So as a matter of fact, it was run successfully.  Good.  That's good enough.  Let's try something.  Let's break our app and commit a broken app.  Let's go to the block solution.  Let's make it unbuildable.  I'm going to choose startup.cs and I'm going to remove this semicolon.  This should make the solution not buildable.  Yep, there is an error.  So let's commit it and let's see whether Azure pipelines will trigger a new job.  And let's see whether it will fail.  Intentional.  Intentional fail.  Let's commit that.  Push.  Yeah, I needed to pull the Azure pipelines YAML because Azure created that for me.  It's essentially the same YAML file we had earlier.  So let's push our failing build.  Good.  So let's hit pipelines.  Let's see what's going on.  And we will see that there's a second push going on, which is queued for now.  Then it will start running.  And finally, after some seconds, it should fail.  So let's wait a bit to see.  And after we see how it fails, we are going to fix our code, of course, and then we are  going to configure our pipelines.  How to configure the pipelines?  We need to just edit the Azure pipelines configuration and we need to specify different tasks here.  So what we want to build also, we are going to want to, for example,  run .NET test to see whether it's working correctly.  So it's failing.  We can see that it's failing.  .NET build.  You can see the different parts of the job here.  Initialize job.  Check out the repository.  Build, which is the task I tried to run, which is actually a task defined here.  Display name .NET build release configuration, which means exactly that.  So .NET build is not working correctly and we can see here that something is not quite  right.  We can see that the startup file, there's an error in it and a missing symbol here.  So Azure pipelines helped us identify a very difficult error.  Good.  I'm going to recommit again.  And the next thing we need to do is we need to configure the testing.  So how to do that?  We need to go and edit the Azure pipelines YAML file.  I'm just going to, because it will be a waste of time for you to watch me how I type  some comments.  So I'm going to pause the video.  I'm going to set up the comments and then I'm going to explain what we did.  Okay.  So essentially you can copy that these comments from the build, test and deploy .NET Core  apps on Azure DevOps.  But nevertheless, I'm going to leave links in the video description.  So you're going to, you can see these code snippets because it's very troublesome to  write them by hand.  Okay.  So what this means here, first we have this script says run the following, which essentially  builds the app .NET build.  Then we add the task, another task.  What is a task?  A task is a predefined process on Azure pipelines.  So if you go to .NET Core CLI documentation, this is the .NET Core CLI task, you will see  that this task allow you to do different things with .NET projects, run tests, publish them,  whatever, a lot of stuff.  You may pack, you get packages and so on.  So essentially we say we want to use the built-in task.  We can use the script too.  You can use a script and specify something like .NET test, but it's more appropriate to  use tasks.  We can also use a task for building our app.  So let's use that too.  So if I want to build an app, I can copy this task like here, like that.  The order of the tasks matter because these tasks will be run one after another.  So if I say build, then I'm going to say here display name test like this, and I'm  going to remove that.  So my initial steps and tasks will be build the project, but I'm going to specify a solution  file here.  I don't want to build the csproj files individually.  I want to build the whole solution.  So the whole solution should be, if I go to GitHub, not this one apparently, should be  Azure pipelines block, block.sln.  So I'm going to just write block.sln.  I'm going to see whether I need to provide a full path.  I'm not sure about that.  Okay, so my first task will be build.  My second task will be test, and I say that I want to run tests in every project which  has a test suffix.  In every directory, every project which has a test suffix, again with the release configuration.  Let's see, but there's a bit of a difference here because my projects are called in a single  form, so it's test only.  So these tasks are the building steps of your pipelines, what you need to do step after  step to validate your project.  First, I need to build my project.  It will run .NET restore for me, so this is why I don't restore packages initially.  Then I want to have a test here, which I just say run the test command on the .NET Core  CLI task.  You can see the different commands written here, build, test, and so on, push, whatever.  Build it, build it, and use this configuration.  So let's save that, and let's commit it.  Let's commit the master branch.  Of course, you can also specify the trigger here.  We only trigger when there is a change in the master branch, but you can configure it  to use all kinds of branches, even with regular expressions.  It doesn't matter.  It doesn't matter.  Okay, so Azure Pipelines added tests to the Azure Pipelines.  Good.  Let's commit that.  Let's push, and let's see whether the app is going to be built and whether the tests  are going to be run, of course.  So hitting Pipelines, a new job is started.  Here it is.  It's still queued, so I'm going to hit pause because tests made a little bit of time, and  we're going to continue after it's done.  So all the tests, I guess, are working fine.  The duration was quite small.  I'm impressed, usually, on other services.  I'm waiting a lot more, of course, for more tests, but still, it's fast enough.  Okay, so let's check the job.  These are all the tasks we defined.  You can see that built-in tests are the same as the display name we showed here.  So the build was successful.  So the build was successful.  The tests, we can see the log that the test run was successful.  It runs 73 tests, so everything should be fine, but let's just check whether the pipeline  is working correctly.  I'm just going to change that the privacy action should return, for example, bad requests  like this.  If I run the tests, they should fail now, and the job should fail too.  Yep, this test is not working, so let's commit it and see how the Azure pipelines  Intentional  No, test fail.  Good, let's see that there's a new job queued.  Here it is.  It's queued.  It should start running any second now, and then it should start failing hard.  Yeah, it's now running.  Good.  So basically, all the continuous integration and continuous delivery services give you  a some sort of configuration like this one, where you want to  on what kind of operational system you want to run your project, what kind of release,  what tasks you want to define.  I'm going to show you a sample YAML file I'm using for one of my projects in Appvr and  Travis CI so that you can see that they're similar.  The process is similar to configure a pipeline on another service, not Azure DevOps.  It's pretty much the same.  So intentional test fail.  You can see that something is not right.  If we hit the test here, you can see that there's a failed test.  And here is the test.  When calling privacy action in home controller, expected result to be bad request, but instead  received view result, which is exactly what we changed.  So let's return it and make sure that it's running correctly.  I'm going to commit.  Fixed the failing test.  I'm going to push that button again.  Good.  Next thing we need to do is we need to deploy our app.  To publish our app, we need to configure the publishing, which is described again here  in this article.  We just need to specify these commands.  I already copied them here and let's now see them and decide whether we want to change  something.  So first we need a build.  Then we need a test.  I'm going to add display name to the other tasks and this one is a publishing task.  It says publish the web project, publish all the projects with the build configuration,  which is again release.  If you're not familiar with all that dash dash configuration arguments and so on, that's  essentially the .NET Core CLI and you will see all the commands here.  So essentially it's the same command.  When you decide to use, for example, .NET build, you can see that there's a configuration  argument you can pass.  So if you're not familiar with it, essentially we're doing just that.  We're specifying that we want to run the publish command from the .NET CLI and want  to specify the configuration.  We also specify that the output here is in some directory, which Azure provides.  Artifact staging directory.  What's an artifact?  Artifact is essentially a component which is ready for release.  So an artifact in this context will be the web application built and ready for release.  That's the artifact.  And we also specify zip after publish because that's easier to deploy afterwards.  Keep in mind that publishing does not mean deployment.  Publishing means that you prepare your app for deployment.  So you publish the app as a zip file and the files in that zip file are completely OK and  completely ready, optimized and whatever for deployment.  So publishing will not deploy our code to Azure.  As you can see, we don't specify where we want to deploy the app.  We just say publish it to an output directory.  So this command should publish our web project to a final and we'll get it ready to be released.  Then I have another task here, which says I want to save the artifact in Azure pipelines.  And you can go to the artifacts page and download the ready to be used app.  Ready to be used app.  This is useful when you want to check what kind of files are going to be uploaded to  the production server, for example.  So it's a good idea to have that configured too.  I'm just going to say Azure pipe just block is OK.  I'm just going to say block.  OK, so let's commit that and see whether the configuration is OK.  Let's push it and we're going to wait a bit.  While we wait, I'm going to again show you the different tasks we have built.  All of these tasks essentially have the release configuration because we want to deploy to  the production server.  So we want the release configuration.  So we have a built a test then publish, which prepares our app in a folder for deployment.  Publishing does not mean deployment here because publishing in Visual Studio is similar to  deployment.  But here we just specify deploy my app in an output directory.  And then we say, please save this artifact so that I can analyze it later.  Let's return to the pipelines.  Let's see what's going on.  It should be still building, running.  Let's see the tests are here.  OK, it's run OK.  So.  One artifact produced, 100% tests passed, looks kind of OK.  Good.  What we need to do now is we need to release our app.  Releasing means deployed to the production app service we had earlier.  Let me just check where I can see my artifact.  Here it is.  Azure pipelines block artifacts like this.  Great.  OK, if we won't be able to see the artifacts here, this is useful for NuGet packages.  Or something like that.  Universal packages, pip, yeah.  These artifacts here are more useful for NuGet packages and packages in general,  where you can go and download your NuGet package, for example, just to see it.  OK, one more thing.  Let's see the artifact.  Here it is in the pipelines.  If you go to your pipelines job.  And you can click.  Tests to see the test summary, which is kind of a nice dashboard.  You can put that dashboard on some TV in your team's room.  And you can always see whether a test is failing with the latest build.  Good, so that dashboard is quite nice, actually.  I really like it.  And yeah, I know teams that have a lot of TVs constantly showing  the state of the app currently with a lot of health checks and so on.  It's a nice addition, so to speak, to a team so that you will always know whether there's a problem.  If you hit artifacts, you will be able to download the app ready for development.  If I hit the zip file and decide to download it somewhere.  Then, for example, and if I open that.  It should contain all the DOLs from my source code.  All the CSS and JavaScript files, essentially everything needed for this app to be published.  This is if we didn't specify the last step, publish build artifact, this artifact.  Wouldn't be fine here.  So you can always see what went wrong because you can download your artifacts locally,  run them and see why the app is not working, for example.  Good, so finally we need to release.  I'm going to say I want a new release pipeline.  It's a bit tricky.  Oh, I have an Azure app service, so I want to deploy here.  Then I need to specify the name of this.  Keep in mind that a stage essentially means an environment where you deploy.  So if I have a QA environment, staging environment, production environment,  I'm going to create multiple stages here.  But since this is my production, I'm going to name it production.  And here it's a bit UX unfriendly here because you need to hit the X here.  That won't cancel our changes.  As you can see, everything is fine.  So then I need to configure that.  I need to say where I want to be.  I can say here if I want the release to be triggered on every commit  or if I want to manually deploy by hitting a button.  But I want to deploy continuously, so I'm going to say after release.  Still, I don't have any artifacts.  Scheduling pull request deployment, prior deployment approvals.  You can set different settings here.  For example, you can schedule to deploy every week.  You can set that pull request will be deployed, for example, to a QA environment.  Pre-deployment approvals if you want somebody to approve that the deployment is happening.  A lot of cool stuff actually.  Okay, so what I need to do finally is I need to go to releases.  Really, it didn't save.  Okay, let's do that again quickly this time.  Production.  I'm going to specify after release.  I don't have any other conditions.  I need to hit the tasks here so that I can specify which is my Azure subscription.  I need to hit authorize because apparently the two systems are different.  You need to authorize the one system, the Azure portal to the Azure DevOps.  But that doesn't matter.  So I authorized my account.  I'm going to wait a bit.  Good.  Web app on Windows.  Let me see whether there's something else here.  No.  No.  App service is Azure pipelines blog.  So I specified that I want to deploy the artifacts from the DevOps process to this app service.  So let's hit save.  And it should be ready.  Finally, I need to add an artifact which will be deployed.  So I'm going to say that I want to use the Azure pipelines blog project.  And the source is the Azure pipelines blog.  The same.  I'm going to use latest.  I can specify here which versions to be deployed of my app.  So I can say that I want to deploy something at a specific time.  I want to deploy only specific versions.  For example, versions which are less than 5.0 and so on.  If I am building a NuGet package, this is useful.  For a web app, I can use latest.  Okay, latest version, which means every single trigger after a push to the GitHub should be  released if everything is running fine.  So let's hit add.  Let's hit save.  And I guess that should be it.  So, if I trigger a new commit, it should be released.  Let's first try to change the web app.  I'm going to go to use home index.  And I'm going to say welcome to our Azure blog.  Azure blog.  This will be the indication that the app was deployed.  Then I'm going to break a test so that we can see that failing builds are not deployed.  And I'm going to.  Failing builds should not be deployed.  And let's push that.  And let's wait a bit to see what will happen.  I'm going to pipelines.  A new pipeline is queued.  The job will start running any second.  I'm going to pause the video.  We don't need to wait it.  So we see that the build failed.  If I go to the job, I will see that publish and artifact did not occur.  They didn't happen because the testing failed.  So this is very super useful.  Because it automatically validates that nothing works.  If nothing works, it won't be deployed.  If my project is not building or the tests are failing, it won't be deployed.  Okay, so now let's go and fix our problem.  And then I'm going to fix failing tests for deployment.  Let's commit that, push it.  And if we go to the pipelines, a new job should start soon.  And I'm going to wait this one on the video because it's the final one.  What I wanted also to specify is that we are deploying on a Windows environment.  And our Azure pipelines configuration is using Ubuntu, which of course can be changed.  What we need to do is just search for all the Azure DevOps.  So we can see all the different environments on which we can deploy.  Also, you can test and assert that your program is working correctly on multiple environments.  This is how it's done.  You specify strategy, matrix, Linux, Mac, Windows.  Specify the different environments, which are essentially what is written here.  Windows latest, Ubuntu latest, and so on.  And you specify that the virtual machine image should be extracted from here.  This will run your pipeline on all different scenarios.  This is useful if you deploy, for example, a NuGet package,  and you need to make sure that all tests are passing on every environment.  For web apps, I guess it's not that mandatory because if my production environment is on Linux,  I'm going to run my DevOps pipeline again on Linux.  If it's Windows, like it's here, we should run it on Windows.  So we're going to change that in a minute.  So I guess everything is fine now.  Artifact, everything should be okay.  Let's go to releases.  Let's create a release.  The artifacts version.  So one release was cute.  We can also...  It was not cute automatically because I need to specify when the release should be done.  But let's see whether the release was good enough.  Manually triggered, not deployed.  I'm going to hit deploy.  It's cute.  It's in progress right now.  So in a matter of seconds, the app should be deployed to Azure.  Guys, if you have any questions, leave them down below in the comments.  I'll be more than happy to answer them.  And I hope this video is useful for you.  Deploying to the app service.  Succeeded.  Let's refresh our website and see what's happening.  It will take a while to restart the whole app.  After all, it's a free tier.  But we saw that everything was deployed by my pipelines, which is very nice.  Again, so what I'm going to do is I'm going to use Windows latest for my final tests  before we finish the video.  Also, I'm going to show you other configuration files for other systems.  So I'm going to use Windows latest and then I'm going to set up the release to be automatic.  Let's go to releases, edit my release and schedule how to release.  So, but I want to be automatic.  Yeah, here, not the schedule not set, but here.  You can schedule that you want to release every week.  But you can also say I want to have a continuous deployment trigger.  Let's enable that.  And yeah, creates a release every time a new build is available.  This is more than enough.  I can, of course, specify different branches.  For example, the build pipelines default branch, but it doesn't matter.  So if there is a new build, the app should be deployed.  I'm not sure whether I should.  Yeah, OK, let's leave it like that.  Let's hit save.  Let's hit save.  When you hit save, you may also add comments to know what kind of  changes you did to the release configuration.  OK, Windows latest.  Let's change the view to have welcome to our cool Azure block.  And let's commit it and wait for it to be deployed.  So final deployment or automatic deployment.  So I configured Azure pipelines to deploy automatically.  So that should happen in less than a minute.  A new job was started here in the releases.  It should trigger a new release.  And of course, if you want, you can always schedule releases, not make them automatic.  So let's wait for that.  And while we're waiting, I'm going to show you how an up there configuration works.  It's essentially the same thing.  Look.  I have some version, but I'm specifying branches only master development and version.  I want to use Visual Studio 2019.  It's pretty much similar.  Trigger only the master branch.  Then I'm saying I want configuration release and I want to run dotnet restore.  Before build.  Then I want to build this project and then I'm specifying which tests I want to run.  There was a reason to run the tests one by one.  There was some problem, I believe, with my solution, the asynchronous nature of the solution.  So I needed to specify them one by one, but it doesn't matter.  It was just an exception for my solution.  So this is an up there YAML file.  It's pretty much similar with different keywords, but it does the same.  Let's see whether it's still running.  Okay.  And let's see the Travis CI.  The Travis CI is similar.  I said I have a C sharp language.  I want to do required because this is for Linux and Mac OS.  I want to have dotnet 3.1.  This is the solution I want to run on Linux and Mac OS on these distributions.  I want these branches and run again only these tests.  So these different configuration files do the same thing with different keywords.  That's the whole difference.  And when you create your first pipeline, okay, that was good.  The second release is currently queued, so it should be the point.  I'm not doing anything.  I'm not doing anything.  When you create your pipelines on whatever system, you can put these badges.  For example, an app there and on Travis CI, I have these two badges.  Here it is that the final, the last built was successful for Windows.  And here it is that the last built was successful for Mac OS and Linux.  So very, it's very useful.  Uh, I had numerous problems, which I catched in my solutions because of the continuous  integration.  It's so helpful and super easy to set up.  I'm wondering why, uh, lots of teams are not doing it.  It's super helpful.  I really catched more than 100 problems in this solution alone, which is quite a lot  just because I had a continuous integration.  Everything was working fine locally on my Windows machine, then on Linux, it was failing.  So it's very, very helpful.  And these packages are, uh, cross platform.  So I needed them to run successfully on Windows, Linux, and Mac OS.  Okay.  So here it is.  The release was successful.  So if I refresh the app, I will see.  Welcome to our cool Azure blog.  Nice.  Everything was done automatically and it was super easy.  It was super easy to set up the Azure environment.  Initially, the app service, it was like 20 minutes or something like that.  And my app is now available worldwide.  And it was super easy to set up these pipelines so that I have.  Very, very, uh, nice pipeline and process to deploy my app automatically.  These things, these comments are just pretty much copy paste from documentation, but it's  important to understand what every task does.  This is why I spent some time explaining it.  But for a normal web app, you need to build, test, publish, and artifact tasks.  From there on, you need to configure your release and it's done.  I'm going to leave a link to.  All these, uh, all these articles I use throughout this tutorial.  And I hope you guys like this video.  If you have any suggestions for me, for my content, for my future topics, leave them  down below.  If you have questions again, you can, um, add a comment below the video.  And finally, make sure you try yourself a continuous integration and continuous deployment  process.  A lot of options available up there.  Octopus deploy, uh, JetBrains had a two team CD.  Azure pipelines is very nice and it's free for public repos and open source repos.  So you can start adding it.  Uh, one last thing.  I'm not sure how to do that.  Azure pipelines.  Badge.  So apparently if I, um, if I copied this one.  And fill in my data here, organization, which I'm not sure.  This is the project, I believe.  Yeah, the project organization.  What's my organization.  I guess if I will kind of lead is my organization.  And API built repos, repo type.  What's the repo type?  That's interesting.  Let me try to find out.  Azure DevOps repo type.  Maybe it's Git.  Let's try with Git.  It's a bit.  Yes.  Value cannot be no branch name.  Okay.  Git branch name.  Equal master.  There's a badge, but it does not indicate my build.  It says set up now for some reason.  One moment.  Let me pause the video.  Okay, I found it.  It's very easy, actually.  So we need to go to the pipelines.  Then choose our pipeline.  And then here it is a status badge.  There is a sample markdown, which we can use.  So I'm going to copy that.  I'm going to go to my GitHub repository, and I'm just going to update the readme.  And done.  Now we have a build badge, whether it succeeded or not.  Cool, guys.  Thank you very much for watching.  And I hope you like this video.  Again, if you have any suggestions down below in the comments.  Bye. 