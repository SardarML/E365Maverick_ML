 Okay, so to be honest, I kind of didn't have a plan for this video, but I was thinking  what topics could we address?  And I mean, one of my favorite topics and one topic that a lot of people have questions  about is the topic of backtracking and utilizing recursion to express a certain decision space  or express possibilities.  So what I really want to do with this is give you the toolkits, give you the blueprint that  I, somehow, I don't know how this came to me, but it just came to me from doing a bunch  of these problems, the toolkit and the patterns you can apply to these problems.  And I mean, it's recursion in general, but specifically for backtracking problems, the  blueprint you need to apply.  So what I thought up was something I always call the three keys of backtracking.  I've done many, many backtracking videos right there, there, there, there, there, and also  here and here and here.  So I've done a good amount of backtracking videos, I mean, but they're a while back and  I mean, my video quality was pretty bad, I didn't have a mic and I kind of want to re-dive  into this and actually explain it again.  So why not?  So what are the three keys to backtracking?  I actually addressed this in my, I think my favorite video, my end Queens video, which  is a while back.  I also did not have a mic, the quality wasn't the best, but that was one of those original  videos that goes a while back.  What I talked about is the fundamental keys to backtracking problems.  It goes like this.  You make choices, you have constraints on those choices, and at the end, you're going  and you're going to converge towards a goal.  You have a decision space you can choose from.  Your decisions are restricted somehow, and your goal is somewhere.  Your goal is to do something.  Maybe it's to fill a string.  Maybe it's to fill N slots.  Maybe it's to solve a Sudoku board.  Our goal would be to solve this.  And what we need to do is see how each of these influence how we shape our code, how  we shape our approach and the way we think about these problems and see how we can decompose  something that's intimidating, like solving a Sudoku board, which is the example we'll  do.  I already did a video on solving Sudoku, but we'll, we'll run through this as an example  to demonstrate these concepts that I'm trying to get across.  So why don't we get into it?  We have our choice.  We have our constraints and we have our goal.  So what we need to do is we need to see what each means.  And also, as always, there's a code sample in the description.  You can see that, but I'll go through a little code snippets here.  I'll put them right there so you can see them.  Um, but yeah, so let's look at our first concept, the choice.  So what I see here is I see a Sudoku board and my interviewer says, okay, uh, write me  an algorithm that solves this.  I have no idea how to do this.  Do I use two for loops or something?  Do I just go through this?  So what we need to fundamentally think about is the core choice, the core choice that we  are making at each step.  This is how we can craft, we can craft a recursive function to solve a problem like this.  So we have a Sudoku board and yes, that's a Sudoku board.  It's a lot of stuff.  We, we, we don't know how to start with this, but I would say that we do know how to start  with it because we know the choices we're making.  What we need to do is we need to fill these cells.  We need to fill those cells, right?  And we need to fill those cells by making choices.  So I said a key word there, I said a cell.  So our key choice will be made on a cell.  So okay, where does a cell sit?  Well a cell sits in a row and it sits in a column.  So okay, I have a lead.  I have a lead on how I can draw a function.  So I'll call my function solve and I'll pass in a row and a column and the job of the function  will be to solve that specific row and column.  Well my next question is how do I solve a, how do I solve a cell?  How do I actually do the process?  So let's reduce our decision space.  We have a big Sudoku board.  Why don't we get rid of every row except the first row?  So the way we need to think about this is we need to think about this compartmentalizing  into subproblems.  So we want to solve cells and when we solve all the cells in a row, then we focus on the  next row and the next row.  And by the time we finish every row, we will have finished, but we'll get to the goal part later.  So our choice at every single cell is going to be to place a number.  What are the numbers we're able to choose?  We can choose these guys.  We can choose numbers from one through nine.  So our decision space that we can choose from is going to be from one to nine.  So let's bring back that code snippet.  We're working on that code snippet right there.  We're trying to solve for the row and column, but what do we do inside?  Well, I know I have a decision space.  I can place numbers one through nine in the cell if it's empty.  If it already has a number, then I don't want to place a number there, but if it's an empty  cell, why don't we run a for loop?  So let's put a for loop right there and there's our for loop.  It runs from one to nine.  I express my decision space.  We're making progress.  We're not lost anymore.  We know what we're doing so far.  So we saw a large Sudoku board.  We broke the problem down into solving a cell.  We're slowly crafting our recursive function and we're slowly getting there.  So what we now need to think about is when I solve a cell, I can place an item.  So once I place an item, it would kind of look like that.  So if I place an item, it's going to look like that and we're going to put an item in  the cell.  And so now I've made a choice and now I need to express my constraints.  What are my constraints?  So the thing is when we place an item, I could validate the whole Sudoku board, but that's  a waste of time.  That would be to the order of N squared and we don't want to do that.  All we need to do is we need to validate the row.  We need to validate the column.  We need to validate the subgrid that the number we just placed sits in.  So if I place a two here, if I, if in my for loop, my for loop says, okay, put a two there.  All I need to know is does the two break the row?  Does it break the column and does it break the subgrid?  So again, I already have a video on the Sudoku solver stuff, so I don't really want to go  into those logistics.  I really want to talk only about backtracking here.  So, okay.  So the key here is what we need to do is if that was a valid placement, I recurse on it.  So why don't we put our recursion right now?  Do you see that?  We recurse on our decision.  So we recurse on our decision.  We'll do some exploration, but do you see what I called it with?  Why did I say a column plus one?  Well, I mean, think about it.  If we solve this column, what's the next logical step?  We solve the next column and then the next.  So my function is a policy.  My function is a policy that is going to know what to do based on the state that it gets  input.  So imagine this.  If I am at the end of this row right over here, if you pass me a column that is out  of bounds and I am not at the final row, what is the natural decision of the recursion?  Well, the recursion is going to say, well, just solve this cell over here, go to the  next row, start in the first column.  So that crafts a base case.  So this gets me to our goal.  So our goal here is to reach our base cases.  So one base case is where we finished a row and we overbound, we out of index on the row  and we need to go to the next row.  That's one base case.  And the final base case is when we're down here.  The final base case is when I out of bounds on the final row.  When I go out of bounds on the final row, that means every row is finished.  If I go out of bounds here, then that means there's more rows to finish.  It's not our final row.  But if it's our final row and we just finished it, that means we finished and that crafts  our base case.  So let's move all our decision space stuff down a little and let's put our base cases  right there.  So what we need to see here is we're slowly understanding sub-problem down, craft my decision  space, adhere to my constraints, converge to a base case, and now what we need to do  is we need to keep in mind, what if a decision doesn't work out?  So if a decision does not work out, once we come back from our exploration, we need  to eject our decision and we can put that right there and it's right there.  That's how we remove our decision.  We just remove it from the cell we placed on.  So this is how it works.  We craft our function based on our choice.  We have base cases we converge to.  We have a decision space and we undo our decisions after we explore on them.  And what we do is at each of these calls, each of these calls has a goal and it tells  us was the Sudoku solvable given the placements that we just did.  So these are the keys to backtracking.  The choice you make.  What is the fundamental sub-problem?  What is the core, core, core decision space?  This is our decision space for a cell.  Our fundamental choice is choosing from this decision space what we want to express in  the cell.  Once we express that, we recurse on that decision.  If the decision doesn't work, we come back and we undo it and we make another choice.  We explore, we undo, we make another choice.  So bring the code back right there.  That's what our for loop is for.  Our for loop is for exploration within the stack frame.  This cell needs to explore one through nine.  This cell explores one through nine.  This cell explores nothing.  It already has a number.  This cell explores one through nine.  So this is one approach to solving the Sudoku problem.  I don't know if there's a way faster than this because this is pretty exponential in  time.  But anyway, this is how backtracking works.  This is how it pans out in my mind.  We make a choice.  We adhere to constraints and we have a goal.  So again, I've done many, many videos on this channel.  Super cool effects going on right there.  I've done many videos on this, but they were a while back and I wanted to kind of retouch  on this topic and give a kind of brief overlook into how backtracking works.  And a lot of times I get questions like, how do you know when you have a backtracking problem?  So you'll know you have a backtracking problem when it's easy to express the answer recursively.  And that's kind of hard to notice unless you have experience using backtracking often,  but you'll just know.  Like if it's, if it says generate all, if it says compute all, if it says, if it says  generate or compute, or I can't really think of other words, but if it says words that  are exhaustive, they're words implying exhaustion of a decision space, then you have a really  good chance that backtracking is going to be one of your solutions.  The only problem with backtracking for exhausting decision spaces is often they are exponential  in time and there may be a more, there may be a smarter way to go about things, but this  is what backtracking is about.  We reduced to our fundamental sub problem here and yeah, that's how the Sudoku solver  works.  And again, I already have a video on that.  I don't think the video is that good, like a lot of my old videos, but yeah, this is,  this is how backtracking works.  This is the fundamental gist behind it.  And I, I didn't have a script for this.  I kind of just went with it and just talked a lot.  So that is all for this video.  This was a kind of briefer one and less in depth into an actual question because I didn't  really have notes for today, but yeah, this is backtracking.  And if you ever get a question like this, I mean, practice helps, but really knowing  what's going on and being comfortable with recursion really helps make these decisions  and making crafting these recursive functions easier.  It's very difficult.  And I honestly, I'm not the best at it either.  I still get stumped on very simple problems, but the more you do it, it becomes more straightforward  and comfortable.  So that's all for this video.  If you like this video, hit the like button, subscribe to this channel.  My goal is to make this one of the world's largest resources for software engineering  interviews.  And until that happens, I don't think I'm going to stop because I think it's a necessity.  I think there just needs to be people aggressively tackling these, these, just this space of  issues.  And I mean, this, this interviewing system is kind of weird, especially in software engineering  because a lot of people have complaints about it.  But I mean, if we don't tackle it head on, I mean, nothing's going to get better if we  just complain about it.  But yeah.  Yeah.  Yeah.  Yeah.  Yeah. 