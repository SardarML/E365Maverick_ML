 Hallo und herzlich willkommen zu einer neuen Folge von David's Deep Dive.  Wir werden uns heute in diesem Video mal dem Thema agile Softwareentwicklung widmen,  denn das ist eines der Themen, das ihr euch in der Kanalumfrage gewünscht habt.  Wenn ihr versucht, euch mit dem Thema zu beschäftigen, wenn ihr euch da einarbeiten möchtet,  dann werdet ihr im Internet zahlreiche Definitionen von agiler Softwareentwicklung finden,  die mal mehr und mal weniger hilfreich sind.  Ich gebe euch mal ein Beispiel.  Die Agile Alliance schreibt Agile Softwareentwicklung ist ein Sammelbegriff  für eine Reihe von Methoden und Praktiken, die auf Werten und Prinzipien  des Manifests agiler Softwareentwicklung basieren.  Wenn ihr noch ein bisschen weiter lest, dann werdet ihr feststellen,  dass diese ganze agile Softwareentwicklung aus agilen Leitsätzen, agilen Prinzipien,  agilen Methoden und agilen Prozessen besteht.  Alles richtig.  Aber für die Erarbeitung des Verständnisses oder für einen Überblick,  was agile Softwareentwicklung ist, hilft einem das meistens nicht wirklich weiter.  Genau darum soll es heute in diesem Video gehen.  Ich möchte euch mal zeigen, warum agile Softwareentwicklung supergut ist  und warum das für jeden von euch, für alle Unternehmen da draußen,  die Software entwickeln, fast immer der richtige Ansatz ist.  Mein Name ist David Thielke.  Auf diesem YouTube-Kanal geht es um die Themen Softwarequalität, Softwarearchitekturen  und alles, was Spaß macht im Bereich der Softwareentwicklung.  Mein Credo auf diesem Kanal ist, dass ich jeden von euch  jeden Tag ein Stückchen besser machen möchte im Bereich der Softwareentwicklung.  Wenn ihr dem Video einen Daumen hoch gebt, dann helft ihr mir dabei,  noch mehr Entwickler zu erreichen und damit noch mehr Entwickler  jeden Tag ein kleines Stückchen besser zu machen.  Wenn ihr das Video gut findet, wenn ihr das Thema gut findet  und mehr zu dem Thema sehen wollt, dann empfehle ich euch, abonniert den Kanal.  Und wenn ihr das macht, dann bekommt ihr jede Woche eine Benachrichtigung,  wenn ein oder mehrere Videos pro Woche fertiggestellt werden.  Und dann seid ihr quasi von vornherein beim Video mit dabei.  Was werden wir heute machen?  Wir werden uns mal das Thema agile Softwareentwicklung anschauen.  Das sagte ich bereits.  Aber wir fangen erst mal da an, was agile Softwareentwicklung nicht ist,  also die klassische Art, wie man Software entwickelt hat  oder heute teilweise Unternehmen auch noch macht.  Wenn wir uns mal anschauen, was daran so besonders gefährlich ist  und werden dann mal die Brücke rüberschlagen, was denn genau Agilität ist.  Und dann werden wir uns mal anschauen,  warum ist die Agilität genau das Richtige für die Softwareentwicklung?  Warum können wir damit wesentlich besser Software entwickeln  und welche Vorteile ergeben sich daraus überhaupt?  Da möchte ich noch auf einen Punkt eingehen, nämlich Agilität ist nicht gleich Chaos.  Das erlebe ich in ganz, ganz vielen Projektsituationen, in vielen Beratungen.  Und wir werden uns nochmal ein bisschen mehr mit dem Thema beschäftigen.  Und ich denke, da spreche ich einigen von euch aus der Seele  und wahrscheinlich jeder von euch wird die Situation schon erlebt haben.  Die ist aber ganz, ganz gefährlich.  Deswegen sollten wir da mal drauf eingehen.  Wenn ihr bis zum Ende dranbleibt,  dann werde ich euch mal meine Top drei Gründe sagen,  warum jeder von euch Software agil entwickeln sollte,  warum jedes Team agil arbeiten sollte  und jedes Softwareprojekt agil durchgeführt werden sollte.  Da gibt es eine ganze Menge Gründe.  Aber ich zeige euch mal aus meiner Erfahrung raus die Top drei Gründe,  die ich in jedem Projekt sehe, dass die dort einfach einen entscheidenden Mehrwert  für das ganze Unternehmen, für das Projekt und für das Team bieten.  Ich würde sagen, wir verlieren jetzt nicht viel Zeit.  Nach dem Intro geht's los. Viel Spaß.  Um zu erklären, warum Agilität für uns genau das Richtige ist,  müssen wir erst mal erklären, was Agilität nicht ist,  wie also so eine klassische Softwareentwicklung aussieht.  In der klassischen Softwareentwicklung ist es so,  dass wir erst mal am Anfang Stakeholder haben.  Das ist natürlich in der modernen auch so.  Wir haben also irgendeinen Fachbereich oder irgendeinen Kunden  und dieser Kunde, dieser Fachbereich möchte gerne,  dass wir ein Softwareprodukt für ihn entwickeln.  Der hat also die fachliche Idee.  Der weiß, wie er seinem Geschäft einen Mehrwert hinzufügen kann.  Und die Softwareentwicklung ist jetzt quasi mit der Aufgabe traut,  dazu ein Stück Software zu entwickeln.  Damit ich so ein Stück Software entwickeln kann,  muss ich allerdings erst mal zusehen,  dass ich natürlich die Anforderungen dazu ermittle.  Und in solchen klassischen Vorgehensmodellen ist es so,  dass man normalerweise hingeht und eine Liste,  eine vollständige Liste, einen Anforderungskatalog zusammenstellt.  Pflichten, Lastenheft kennen bestimmt einige von euch.  Und dann von diesem Pflichten, Lastenheft geht man dann hin  und entwickelt die Software.  Das heißt, wir nehmen erst alle Anforderungen auf für dieses Projekt,  was vielleicht fünf oder sechs Jahre lang dauern wird.  Wir haben also mehrere Leitsordner voll.  Das Szenario habe ich noch oftmals miterleben müssen leider.  Und dann nehmen wir diese Leitsordner,  übergeben die in die Softwareentwicklung  und die Softwareentwicklung baut dann dazu entsprechend ein Stück Software.  So, diese Softwareentwicklung,  da reden wir gleich noch ein bisschen genauer darüber,  wie das Ganze intern aussieht.  Aber am Ende der Entwicklung kommt dann hinten ein fertiges Softwareprodukt raus  und dieses Softwareprodukt können wir dann entsprechend  unserem Kunden zur Verfügung stellen,  sodass er damit arbeiten kann.  Was ist jetzt das Problem von dieser klassischen Entwicklung?  Nun, das Problem ist erst mal die Vorgehensweise,  wie das Ganze entwickelt wird.  Es gibt in der Softwareentwicklung verschiedene Vorgehensmodelle.  Diese Vorgehensmodelle beschreiben einen Prozess, eine Arbeitsweise,  wie wir von der Anforderung hin zum fertigen Softwareprodukt kommen.  Hier in diesem Fall arbeiten wir mit dem sogenannten Wasserfallmodell.  Das heißt, am Anfang geht man hin, sammelt alle Anforderungen,  dann nimmt man alle Anforderungen, gibt die in den nächsten Schritt in die Architektur.  Dann macht ein Architekt quasi ein Architekturgerüst außenrum,  zeichnet verschiedene UML-Diagramme  und dann wird dann diese Buß von UML-Diagrammen  und diese Riesenmenge an Anforderungen an die Entwicklung übergeben.  Die Entwicklung entwickelt das Ganze dann mehrere Jahre  und irgendwann werden diese Artefakte alle zusammen an die Qualitätssicherung übergeben.  Die führen dann die Tests durch und irgendwann nach ganz, ganz langer Zeit,  meistens mehrere Jahre nachdem der Kunde der Stakeholder die Software bestellt hat,  stellen wir diese Software irgendwann mal bereit.  Dadurch ergeben sich jetzt natürlich zahlreiche Nachteile.  Und der erste Nachteil natürlich ist es,  dass wir lange brauchen, bis wir ein Ergebnis bekommen.  Wenn also ein Kunde ein Stück Software bestellt,  dann muss er warten, bis diese Software vollständig entwickelt wurde.  Wenn ich jetzt größere Softwareprojekte habe,  heißt das, dass ich meistens erst nach vielen, vielen Jahren  und nach längerer Zeit eben dieses Softwareprodukt als Kunde bekomme  und dann das erste Mal ein visuelles Feedback zu meinen gestellten Anforderungen bekomme  und dann sagen kann, ob das Ganze richtig war oder nicht.  In dem Zusammenhang ist es natürlich oft vorgekommen,  dass der Kunde Anforderungen vielleicht ungenau definiert hat,  Anforderungen vergessen hat oder sonst irgendwelche Fehler  bei der Anforderungsanalyse gemacht wurden.  Und dieser Fehler, dieser Faux pas, ist dann erst aufgefallen,  als die Software nach langer, langer Zeit an den Kunden ausgeliefert wurde,  was natürlich den Kunden nicht zufriedenstellt  und zum Beispiel in meinen Projekten vor langer Zeit zum Glück auch dafür gesorgt hat,  dass zum Beispiel ein großes Softwareprodukt entwickelt wurde,  was dann zum Zapfen des Releases gar nicht mehr verwendet werden durfte.  Entweder weil etwas falsch entwickelt wurde  oder weil es mittlerweile Gesetzesänderungen gegeben hatte oder sonstige Dinge.  Das Zweite ist natürlich, dass dieser Prozess extrem fehleranfällig ist.  Ich habe es gerade schon mal bei den Anforderungen beschrieben,  aber je später ein Fehler in diesem Wasserfallprozess entdeckt wird,  umso teurer wird es natürlich, diesen Fehler zu beheben.  Das heißt, wenn ich schon bei den Anforderungen erkenne,  okay, da habe ich irgendwas falsch aufgenommen oder die Anforderung ist inkonsistent,  dann kann ich das noch recht einfach beheben.  Aber wenn ich zum Beispiel erst in der Entwicklung feststelle,  dass dort irgendetwas nicht passt oder irgendwelche Anforderungen nicht konsistent sind,  dann muss ich diesen Schritt davor, die Architektur und die Anforderung,  muss ich nochmal erneut durchführen.  Und das Testen ist ja quasi nochmal der Entwicklung nachgelagert.  Das heißt, wenn ich dort Fehler erkenne,  dann kann es sein, dass ich in der Entwicklung etwas neu machen muss  oder vielleicht die Architektur abändern muss  oder ich dann dort feststelle, hey, das hat ja der Kunde gar nicht bestellt.  Da muss ich diese ganze Kette also nochmal durchlaufen.  Das heißt, für all diese Aspekte, die wir bis jetzt angesprochen haben,  ist eigentlich die klassische Softwareentwicklung nicht besonders gut geeignet.  Das Nächste, was wir haben, ist natürlich verbunden mit dem,  was wir gerade gesehen haben, dass diese Fehler extrem teuer werden.  Die meisten Fehler, erfahrungsgemäß in solchen Prozessen,  passieren in der Anforderungsanalyse,  dass der Kunde also Anforderungen nicht genannt hat,  sie nicht richtig aufgenommen wurden oder sonst irgendwelche Dinge.  So, und wenn ich jetzt irgendwann das Ganze ausliefere nach vier, fünf Jahren  und der Kunde hat bei einem Modul zum Beispiel  irgendwas nicht richtig benannt oder die Anforderung nicht richtig formuliert,  dann muss dieses Modul unter Umständen neu entwickelt werden.  Dann muss dieser ganze Prozess nochmal durchlaufen werden.  Und das sorgt natürlich für extreme Verzögerungen  und nicht wirklich für eine Akzeptanz im Bereich der Software beim Kunden.  Und der letzte problematische Punkt, zumindest nachdem wir uns hier anschauen,  ist es, dass wir Änderungen in diesem Prozess nicht machen können.  Ich hatte eben schon mal in meinem Beispiel beschrieben,  mein Kunde hat eine Software entwickelt im Versicherungsbereich  und während der Entwicklung, das war eine Entwicklungszeit von zweieinhalb Jahren,  ist eine Gesetzesänderung gekommen.  Und diese Gesetzesänderung hat dafür gesorgt,  dass wir beim Release der Software diese Software gar nicht mehr benutzen konnten,  weil wir diese Gesetzesänderung währenddessen nicht erfasst haben in den Anforderungen  und die dementsprechend auch gar nicht implementiert wurde innerhalb der Software.  Das waren jetzt mal nur vier Probleme, die wir, nochmal,  Das waren jetzt nur mal vier Probleme, die wir mit so einem Wasserfallprozess  und so einem klassischen Entwicklungsmodell in der Praxis haben.  Da gibt es noch eine ganze Menge mehr.  Ich denke, wir können allein ein ganzes Video  über die Probleme der Wasserfallentwicklung machen.  Aber es soll euch nur mal einen groben Überblick darüber geben.  Ich denke mal, ihr habt da wahrscheinlich auch ein paar Dinge, die euch im Kopf rumschwirren.  Vielleicht habt ihr auch schon mal mit dem Wasserfallmodell gearbeitet.  Könnt ihr mal runterschreiben in die Kommentare, was ihr so für Erfahrungen gemacht habt,  was ihr so für Probleme damit gehabt habt.  Da können wir, glaube ich, einen ganzen Katalog zusammenstellen.  Aber wenn jetzt das Wasserfallmodell so unglaublich schlecht ist für die Softwareentwicklung,  warum hat man das überhaupt genommen?  Dazu müssen wir in der Historie ein bisschen zurückgehen.  In den 80er, 90er Jahren gab es nur wenige Unternehmen, die Software entwickelt haben.  Es wurden aber immer mehr.  Es kamen immer mehr Anwendungsfelder dazu.  Die Geräte wurden immer günstiger.  Und so fing die Software an, in alle Bereiche reinzugehen,  in alle Industriebereiche, in alle Branchen reinzugehen.  Und es fingen auch Branchen an, Software zu entwickeln,  die das eben nicht von der PIKA aufgelernt haben  oder die nicht spezialisiert auf die Softwareentwicklung waren.  Ich habe ein Beispiel einen Kunden und dieser Kunde fertigt Schaltschränke.  Und die haben schon Schaltschränke gebaut, seit, glaube ich, 100 Jahren mittlerweile.  Also früher waren das Elektroschränke, heute sind das IT-Schaltschränke.  Und die haben immer schon nach dem Wasserfallmodell gefertigt.  Das heißt, wenn so ein Schaltschrank entwickelt wurde,  dann haben die am Anfang erstmal eine Studie durchgeführt,  wurde geschaut, was braucht der Markt überhaupt.  Dann gab es eine Phase, in der alle Anforderungen gesammelt wurden  und ein Dokument angefertigt wurde über diesen Schaltschrank, der gebaut werden sollte.  Dann wurde der konstruiert und dann wurde irgendwann eine Produktionslinie aufgebaut.  Und in dieser Produktionslinie wurde dann dieser Schaltschrank gefertigt,  hinten dann vom Band runtergenommen, in der Qualitätssicherung einmal durchgeprüft  und dann entsprechend an den Kunden ausgeliefert.  Das ist so oder so ähnlich der klassische Prozess,  den man bei industrieller Fertigung verwendet.  Und da funktioniert das Ganze auch ziemlich gut.  So, und diese Unternehmen haben seit Jahren mit genau diesen Prozessen gefertigt.  Und da ist es ja naheliegend, wenn man jetzt mit einer neuen Ingenieursdisziplin  in die Softwareentwicklung anfängt, dass man die Prozesse nimmt, die man kennt  und die seit Jahren schon erfolgreich im Unternehmen laufen.  Deswegen haben viele Unternehmen angefangen, mit dem Wasserfallmodell zu entwickeln.  Und literaturmäßig, mal ein bisschen zurückgeblickt,  war das damals auch der empfohlene Prozess genau für die Softwareentwicklung,  weil Ingenieursdisziplin mäßig sind wir in der Softwareentwicklung relativ jung,  im Vergleich zum Beispiel zur Mathematik.  Und deswegen gibt es in unserer Branche einfach noch nicht so viele Erfahrungen.  Damals dachte man, das wäre gut und hat dann eben festgestellt, dass es nicht so gut ist,  weil viele Projekte schief gelaufen sind.  Viele Softwareprodukte waren irgendwann fertig und konnten dann gar nicht mehr eingesetzt werden.  Und das hat sich immer so weitergezogen.  Wenn wir verstehen wollen, warum das Wasserfallmodell so unglaublich schlecht ist,  dann muss man verstehen, was das für unterschiedliche Prozessarten sind,  die dort abgebildet werden sollen.  Wenn wir uns jetzt diese Schaltschrankfertigung anschauen,  da wird quasi die Studie gemacht, dann die Konstruktion,  dann wird die Produktionsstraße aufgebaut.  Und wenn wir uns an das Ende von diesem Produktionsband stellen,  dann nehmen wir mehr oder weniger immer denselben Schaltschrank von diesem Band runter.  Diese Art von Prozessen nennt man Pull-Prozesse,  weil ich jedes Mal dasselbe Element rausziehe, also pulle.  So, wenn ich jetzt Pull-Prozesse habe,  dann kann ich das Wasserfallmodell oder wasserfallartige Prozesse verwenden,  ohne irgendwelche Bedenken, da ist das sogar ziemlich gut.  Aber wir in der Softwareentwicklung haben keinen Pull-Prozess,  weil in der Softwareentwicklung werden quasi hinten aus diesem Prozess  niemals dieselben Arten von Software herausgenommen.  Das heißt, jedes Mal, wenn wir eine neue Iteration haben oder sonstiges,  dann kommt ein neuartiges Produkt aus unserem Softwareentwicklungsprozess raus.  Warum? Na ja, weil es nicht wie bei dem Schaltschrank ist,  dass vorne einmal Anforderungen reingedrückt werden und dann kommt immer dasselbe Produkt raus,  sondern wir pushen kontinuierlich neue Anforderungen vorne in diesem Prozess rein  und hinten nehmen wir dann immer ein andersartiges Produkt runter.  Das eine waren Pull-Prozesse, weil immer dasselbe rausgepullt wurde.  Und bei diesen softwareentwicklungsartigen Prozessen reden wir von Push-Prozessen,  weil vorne immer wieder neue Anforderungen in die Softwareentwicklung reingedrückt werden,  rein gepusht werden und dabei ist das Wasserfallmodell eben extrem schlecht.  Wenn wir das Ganze noch mal grafisch visualisieren,  wir nehmen jetzt hier mal quasi einmal die klassische Variante  und wir stellen uns mal so ein Projekt einfach zweidimensional vor.  Dann könnten wir sagen, okay, irgendwann haben wir hier mal einen Start.  Das heißt, wir starten mit unserem Projekt, mit unserem Softwareprojekt  und wenn wir jetzt ein klassisches Softwareentwicklungsmodell nehmen,  dann gehen wir hin und sagen, okay, wir wollen am Anfang schon alle Anforderungen  aufnehmen, eine Studie durchführen und wollen damit dann genau prognostizieren,  wo wir nachher am Ende irgendwann landen wollen.  Das heißt, wenn wir jetzt davon ausgehen, dass das Ganze über mehrere Jahre entwickelt wird,  dann ist das hier quasi das Ziel, was wir erreichen sollen, also unser Sollziel.  Und unsere Aufgabe in der Softwareentwicklung ist es jetzt quasi  von dem Start hin zu diesem Ziel, zu diesem Sollziel zu entwickeln.  Es ist aber das Problem, dass wir manchmal Anforderungen nicht richtig aufnehmen,  gerade wenn es solche großen Mengen sind.  Der Kunde manchmal nicht weiß, was er genau haben möchte,  in der Entwicklung Fehler gemacht werden und so weiter und so fort,  sodass es meistens so ist, dass wir dieses Ziel hinten gar nicht genau erreichen.  Das heißt, wir haben kein Ziel, wo wir hinwollen,  sondern wir haben ein Ziel, was wir tatsächlich erreichen.  Das ist Ziel.  Das heißt, wir haben hier oben das hier gar nicht so entwickelt,  sondern wir gehen in eine ganz andere Richtung und  sondern entwickeln hier hin zu unserem Istziel.  Das heißt, das, was wir erreichen wollen, haben wir nicht erreicht.  Wenn es unterwegs Änderungswünsche beim Kunden gegeben hat,  haben wir die nicht erfasst.  Ihr könnt euch, denke ich, bei dieser Visualisierung ziemlich gut vorstellen,  was das Problem genau von Wasserfallprozessen werden kann  und was man dort für Probleme bekommen kann.  Und dann bekommt man auch so ein Gefühl dafür, warum damals,  wenn ihr schon ein bisschen älter seid, genauso viele Projekte in der IT schief gelaufen sind.  So, wenn wir jetzt hingehen und sagen, wir wollen nicht klassisch sein,  sondern wir sind agil, haben wir ein ähnliches Ausgangsszenario.  Das heißt, wir sind hier, haben wir einen Startpunkt.  Und bei diesem Startpunkt ist es jetzt so, dass wir nicht sagen,  wir wollen jetzt alle Anforderungen aufnehmen für die nächsten drei, vier, fünf, sechs Jahre.  Wir wollen nicht hingehen und wollen  keine Ahnung, das gesamte Produkt schon im Kopf haben oder den Kunden das ganze Produkt ausfragen,  sondern wir gehen zum Kunden und sagen dem Kunden OK, lieber Kunde,  du willst ein Produkt bauen, aber sag uns jetzt nicht, was du alles haben willst,  sondern sag uns erst mal, was für dich das Wichtigste ist und sag uns die Funktionalität,  die du gern nächsten Monat schon in der ersten kleinen Version deiner Software haben willst.  So, dann kann der Kunde sagen OK, wir definieren uns hier so ein kleines winziges Zwischenziel  und wenn wir dann dieses Zwischenziel haben in der Entwicklung,  dann gehen wir hin und entwickeln quasi dieses Stück Software.  Wenn wir das Stück Software entwickelt haben,  dann können wir zum Kunden gehen und können beim Kunden sagen hier,  schau mal bitte, ist das für dich in Ordnung oder ist es nicht in Ordnung?  Hast du dir so vorgestellt?  Und was ist jetzt genau das nächste Wichtige für dich?  Dann kann der Kunde sagen OK, für mich ist als nächstes jetzt das und das Wichtige.  Das heißt, er kann den Kurs noch mal korrigieren.  Und so entwickeln wir quasi von Iteration zu Iteration, entwickeln wie immer weiter  und der Kunde kann quasi die ganze Zeit auf diesem Weg immer wieder Änderungswünsche einbringen  und kann sagen OK, hier hinten, da will ich dann irgendwann mal sein.  Das sagt er natürlich erst ganz am Ende mit seinem letzten Änderungswunsch.  Das heißt, wie so eine kleine Schlange hier nähern wir uns immer diesem Ziel an.  Wir verfolgen also die Wünsche unseres Kunden und durch diesen continuous support,  continuous Feedback, was wir bekommen von unserem Kunden.  Das ist so eine agile Methode, von der ich anfangs mal gesprochen habe.  Durch dieses continuous Feedback gehen wir quasi nach jeder Iteration hin  und versuchen es wieder alles so zu machen, dass es genauso ist, wie der Kunde das haben will.  Das hier ist nur eine Visualisierung.  Das soll ich mal ungefähr ein Gefühl dazu geben.  Was ist klassisch und was genau ist daran anders an der Agilität?  Hier müsst ihr jetzt aufpassen.  Verwechselt das nicht mit iterativer Softwareentwicklung.  Nur iterativ ist nicht agil, weil die Agilität sagt,  wir entwickeln in Iterationen und nach jeder Iteration sprechen wir mit unserem Kunden,  holen unserem Kunden Feedback und lassen den Kunden die nächste Iteration planen.  Nachdem wir jetzt gerade einmal schon kurz auf die agile Entwicklung draufgeschaut haben,  wollen wir das Ganze jetzt mal ein bisschen konkreter machen.  Wir haben ja eben auf den Slides schon mal das Beispiel gesehen,  wie die klassische Entwicklung high level view mäßig aussieht.  Jetzt gehen wir mal hin, schauen uns das mal an für die agile Entwicklung  oder für die moderne Entwicklung, wie es hier genannt.  Wir haben natürlich genauso wie auf der linken Seite, auf der rechten Seite auch Stakeholder.  Wir haben also Stakeholder, die Anforderungen gegenüber der Softwareentwicklung haben.  So weit, so normal.  Der erste Unterschied ist jetzt aber, dass die Anforderungen,  die Artenweise, wie Anforderungen aufgenommen werden.  Wir gehen nicht mehr hin und nehmen ein oder erstellen ein riesengroßes Dokument,  wo alle Anforderungen drin sind, so die klassischen Projektdokumente,  sondern wir sagen dem Kunden einfach nur,  okay, wir planen jetzt so eine Iteration von 30 Tagen beispielsweise.  Was möchtest du nach diesen 30 Tagen fertig haben?  Das heißt, dieser Scope, den wir betrachten,  der ist wesentlich kleiner als in der klassischen Entwicklung.  Wir fokussieren uns einfach nur auf das nächste Ergebnis,  das nächste Stück Software, was wir diesem Kunden präsentieren wollen.  Das heißt, wir haben viel kleinere Menge an Anforderungen,  die wir viel präziser formulieren können,  weil wir uns nur auf diesen einen Bereich fokussieren müssen  und nicht schon darüber nachdenken müssen,  was brauchen wir in drei, vier, fünf Monaten oder sonst irgendetwas.  Diese Anforderung, die ihr dort seht,  die wird auf sogenannten Storycards formuliert.  Das heißt, wir haben nicht mehr ein großes Dokument,  sondern ihr könnt euch das vorstellen einfach nur wie ein normaler DNA4-Zettel,  auf dem diese Anforderung draufsteht.  Das heißt, wir haben eine Nummer, wir haben einen Titel,  wir haben eine Beschreibung, vielleicht Oberflächenprototypen,  wir haben Akzeptanzkriterien und so weiter und so fort.  Denn diese Anforderung auf diesem Zettel, die dort definiert wird,  diese User Story oder später auch bei Scrum Product Backlog Item genannt,  die wird später an den Entwickler übergeben,  dass er das Feature entwickelt.  Das heißt, der Entwickler muss seinerseits nicht hingehen  und dieses riesengroße Dokument herunterbrechen,  auseinanderpflücken, in einzelne Aufgaben herunterbrechen,  sondern diese Tätigkeit wird schon bei der Anforderungsanalyse durchgeführt  und diese User Stories, die wir dann dort schreiben auf diesen Storycards,  die werden dann an die Entwicklung weitergegeben.  So, die Entwicklung weiß jetzt,  wir machen jetzt eine Iteration über 30 Tage meinetwegen  und die können sich jetzt von diesem Stapel von Anforderungen  so viele Anforderungen herunternehmen, wie sie in den nächsten 30 Tagen  oder je nachdem, wie lange die Iteration ist,  wie dort entwickelt werden kann.  So, das heißt, wir nehmen jetzt diese Anforderungen  und in der Entwicklung entwickeln wir das Ganze.  Wir schreiben also Quellcode dazu,  setzen diese Anforderungen mit programmiertechnischen Mitteln um,  sodass wir nachher ein Stück Software haben.  So, am Ende der Entwicklung müssen wir dem Kunden natürlich ein Stück Software zeigen.  Wir wollen ja dem Kunden zeigen, was er jetzt bestellt hat vor einem Monat,  um an dieses Customer Feedback zu kommen.  Das Ganze machen wir mit so einer sogenannten Pipeline.  Das heißt, wir haben hier eine,  ja, gehen wir später noch ein bisschen genauer darauf ein,  das ist ein Build Server oder eine Kette von verschiedenen Dingen,  die dort automatisiert durchgeführt wird  und am Ende des Tages hier so ein Produkt bereitzustellen  und dieses Produkt können wir dann wieder dem Kunden zuführen  und der Kunde kann dann von sich aus sagen,  okay, bin ich total zufrieden mit,  oder da haben wir uns vielleicht ein bisschen missverstanden  oder jetzt, wo ich das gerade sehe, habe ich noch eine coole Idee.  Das heißt, wir entwickeln von Iteration zu Iteration,  entwickeln wir so, dass unser Kunde immer sagen kann,  direkt Einfluss auf die nächste Iteration geben kann  und uns neuen Input und neues wertvolles Feedback darüber geben kann,  wie diese Software weiterentwickelt werden soll.  Und das ist genau das, was ihr in der vorigen Grafik gesehen habt,  wie wir iterativ versuchen, agil quasi den Kundenwünschen zu folgen,  um nachher genau bei dem Ziel rauszukommen,  was der Kunde auch tatsächlich am Ende des Tages haben wollte.  Jetzt haben wir mal geklärt, was ist Agilität?  Agilität ist es also, wenn wir nicht nur in Iterationen entwickeln,  sondern immer nur portionsweise die Anforderungen von unserem Kunden holen  und nach jeder Iteration dem Kunden das funktionsfähige Zwischenprodukt  zur Verfügung stellen, uns Feedback darüber einholen  und dann gemeinsam mit dem Kunden die nächste Iteration planen,  so dass wir quasi immer die Kundenwünsche folgen,  wie wir das in der einen Grafik eindrucksvoll gesehen haben.  Jetzt habe ich ja mal eingangs erwähnt, nach dieser Definition,  dass es noch sowas wie agile Methoden gibt, agile Techniken gibt und so weiter  und unter anderem auch agile Prozesse.  Wir gucken uns jetzt mal diese agile Prozesse an.  Als die Agilität damals aufgekommen ist, so am Anfang der 2000er Jahre,  war der erste agile Prozess, also die Vorschrift,  wie man jetzt agil in so einem Prozesssoftware entwickelt,  das sogenannte Extreme Programming.  Das ist damals von Kent Beck, glaube ich, erfunden worden.  Ich weiß es gar nicht mehr genau.  Und auf jeden Fall Extreme Programming war so die erste Sammlung an Methoden,  die wir an die Hand bekommen haben, um agile Software zu entwickeln.  Diese Story Cards zum Beispiel waren in Extreme Programming drin.  Unit Tests war auch ein Bestandteil von Extreme Programming  und Test Driven Development ebenfalls, glaube ich, bin mir gar nicht genau sicher.  Aber es war damals so der erste Ansatz,  ein Prozessmusell zusammenzubauen, wo wir agile Software bereitstellen können.  Das Problem dabei war immer, dass die Anforderungsanalyse  so ein bisschen stiefmüterlich behandelt wurde.  Das heißt, für die Entwicklung gab es viele Vorschriften,  wie man Agilität umsetzen kann im Bereich der Anforderungen.  Meiner Meinung nach war das Ganze immer ein bisschen schwach.  Und dann ist irgendwann der Primus, auch das meistverwendete Prozess,  agile Prozessmodell von heute herausgekommen, nämlich Scrum.  Bei Scrum gibt es zwei sehr, sehr starke Prozessschritte.  Einmal die Anforderungsanalyse und dann eben die tatsächliche Produktentwicklung.  Und Scrum setzt diese ganzen agilen Werte,  dieses agile Manifest, diese agilen Mythologien und Dinge extrem gut um.  Wir haben am Anfang eine Anforderungsanalyse,  bei der eine separate Person, ein sogenannter Product Owner,  mit diesen Stakeholdern zusammen diese Anforderungen erarbeitet.  Die werden bei Scrum dann Product Backlog Item genannt.  Und danach gibt es dann einen 30-tägigen Sprint,  so nennt man die Iteration bei Scrum, bei dem das Ganze entwickelt wird.  Das ist jetzt nur eine Möglichkeit, ein agiler Prozess,  mit dem ich agile Software entwickeln kann.  Ein anderer zum Beispiel ist Kanban.  Kanban funktioniert ähnlich, auch da wird die Anforderungsermittlung  so ähnlich durchgeführt, wie wir es gerade bei Scrum gesehen haben.  Und danach entwickeln wir nicht in Iterationen,  sondern wir entwickeln in einem Flow.  Das heißt, wir haben einen Prozess und in diesem Prozess  darf immer nur eine gewisse Menge an Elementen bearbeitet werden,  bevor das nächste angefangen wird.  Und damit bekommen wir quasi so einen kontinuierlichen Feature Stream  durch unsere Entwicklung hindurch.  Wir wollen jetzt auch gar nicht so sehr in diese Bereiche reingehen,  aber erstmal agiles Softwareentwicklung beschreibt die Art und Weise,  wie wir das Ganze umsetzen.  Und dann gibt es dazu agile Prozesse wie Extreme Programming, Scrum, Kanban,  mit denen wir das Ganze dann konkreter machen können.  Wenn ihr das Ganze einführen wollt,  dann solltet ihr euch diese agilen Prozessmodelle mal anschauen,  weil es ist eigentlich immer in der Softwareentwicklung so,  entweder passt bei euch Scrum sehr gut und ihr könnt Scrum umsetzen  oder ihr könnt das Ganze mit Kanban machen.  Wenn ihr dazu mal noch ein paar Videos haben wollt,  schreibt es runter in die Kommentare, dann machen wir mal eins dazu.  Nachdem wir uns die Agilität jetzt allgemein angeschaut haben,  uns die agilen Prozesse angeschaut haben,  will ich noch auf einen Punkt ganz explizit hinweisen.  Ich habe schon gesagt, ich bin Berater  und ich bin öfters in Kundenprojekten unterwegs  und am Anfang analysiere ich Prozesse,  Entwicklung, Technologie-Stacks, Architektur und so weiter.  Und wenn es zu Prozesse geht, kommt immer ganz schnell die Aussage,  wir, der DIGE, entwickeln agil.  Und wenn man dann mal ein bisschen nachbaut,  dann findet man einfach heraus,  okay, die entwickeln zwar immer wieder ein bisschen agilere Prozesse,  okay, die entwickeln zwar immer wieder in so einer Art Iteration,  aber total planlos.  Mal dauert die eine Woche, mal zwei, mal drei, mal nur ein paar Tage.  Anwendungen werden nur hier und da mal bereitgestellt.  Anforderungsanalyse gibt es gar nicht.  So ein Erkunde ruft direkt beim Entwickler an.  Der Entwickler muss immer wieder direkt beim Kunden nachfragen.  Es ist also kein wirklicher Prozess  und es ist einfach nur eine rein chaotische Entwicklung.  Ganz, ganz wichtig ist es, dass ihr das nicht verwechselt.  Wenn wir so chaotisch wie gerade entwickeln,  oder wahrscheinlich werdet ihr auch da draußen genügend Beispiele haben,  wie gesagt, da freue ich mich nachher mal auf eure Kommentare,  hat das überhaupt nichts mit Agilität zu tun.  Agilität heißt einfach nur,  dass wir nicht in großen Blöcken entwickeln,  sondern dass wir in kurzen Iterationen entwickeln  und den Kunden mit einbeziehen.  Das heißt nicht, dass wir keine Anforderungsanalyse machen.  Das heißt auch nicht, dass wir in irgendeiner Art und Weise  keinen expliziten Prozess haben,  sondern quasi einfach nur frei Schnauze entwickeln,  sondern wir haben feste Prozesse,  wir haben eine feste Anforderungsanalyse,  aber wir machen das Ganze in kurzen Iterationen,  binden dabei den Kunden mit ein.  Ganz, ganz wichtig, dass ihr das nicht mit der chaotischen Softwareentwicklung  vermixt oder sonst irgendetwas,  sondern in der agilen Softwareentwicklung gibt es ganz, ganz, ganz klare Regeln.  Wie gesagt, dieses agile Manifest solltet ihr euch mal durchlesen,  wenn ihr in dem Bereich was machen wollt,  weil da werden diese Regeln relativ klar beschrieben.  Wenn ihr dann hingeht und nutzt eins dieser agilen Prozessmodelle,  die wir eben besprochen haben, heute ist es meistens Kanban oder Scrum,  dann solltet ihr peinlichst genau darauf achten,  dass ihr es auch genau so umsetzt, wie es gefordert ist.  Man kann da hier und da Anpassungen machen,  aber ihr müsst euch das so vorstellen, es gibt agile Methoden,  da gibt es ganz, ganz viele von.  Und diesen agilen Prozessmodellen Kanban und Scrum  sind gezielt bestimmte Methoden aus diesem Werkzeugkasten herausgenommen  und sind in so ein Prozessframework gegossen worden.  Und diese Methoden miteinander funktionieren extrem gut.  Wenn man aber einzelne Anpassungen macht aus eigener Motivation heraus,  dann kann es sein, dass man mit dieser Anpassung  das gesamte Prozessmodell komplett kaputt macht.  Bestes Beispiel, wenn ich in Scrum zum Beispiel keinen Scrum Master habe,  keinen dedizierten, dann ist der ganze Prozess für die Tonne.  Wenn ich in Scrum keine Richtungsperspektive mache,  habe ich keinen KVP, keinen kontinuierlichen Verbesserungsprozess,  ist das Ganze ebenfalls für die Tonne.  Deswegen geht mit euch selber hart ins Gericht  und versucht selber mal genau zu definieren,  seid ihr agil, ja oder nein?  Macht ihr Scrum, ja oder nein?  Und am Ende des Tages ist immer noch besser,  wenn ihr zu der ehrlichen Einsicht kommt, wir sind nicht agil,  wir haben einfach keinen Prozess entwickelt, chaotisch,  weil dann habt ihr ein gutes Resultat, auf dem ihr aufbauen könnt  und dann Richtung Agilität starten könnt,  Richtung einem konkreten agilen Prozessmodell,  wie Scrum oder Kanban gehen können.  Aber seid an der Stelle ehrlich, weil ich sehe das wirklich ganz,  ganz oft, sich selber in die Tasche zu krücken,  bringt an der Stelle überhaupt nichts.  Wir haben jetzt über eine ganze Menge Nachteile des Wasserfallmodells gesprochen,  auf der anderen Seite von den ganzen Vorteilen der agilen Softwareentwicklung.  Ich hatte schon versprochen, am Ende gebe ich euch mal meine Top 3 Vorteile  oder Geschenke, die ihr mit der Agilität bekommt.  Das sind nur drei von ganz, ganz, ganz vielen.  Also die agile Softwareentwicklung ist wirklich eine großartige Sache  und jeder von euch sollte sich genau mit diesem Thema beschäftigen.  Aber ich habe im Laufe der Zeit herausgefunden,  dass eine Reihe von Vorteilen da ist,  die die Kunden am Anfang gar nicht so wertschätzen  und nach vielen Jahren dann lieben.  Der erste Punkt ist zum Beispiel das direkte Kundenfeedback.  Wenn man in Unternehmen agile Softwareentwicklung einführt,  dann sehe ich das ganz oft, dass dort bereits eine gewisse Spannung ist  zwischen der Fachabteilung und den Softwareentwicklern  oder zwischen der Softwareentwicklungsabteilung und den zahlreichen Kunden.  In dem Moment, wo man switcht auf ein agiles Softwareentwicklungsmodell  und dieses Rapid Feedback von seinem Kunden bekommt,  der Kunde also in hoher Frequenz neue Softwareversionen bekommt  und immer wieder quasi direkt Einfluss auf die nächste Iteration nehmen kann,  sorgt das einfach für ein unglaubliches Zusammenhörigkeitsgefühl,  für eine unglaublich enge Kundenbindung  und für unglaublich gute Ergebnisse, die wir mit diesen Sprints erzielen.  Deswegen ist für mich der erste unglaublich positive Punkt  dieses direkte Kundenfeedback und diese nahe Zusammenarbeit,  die man dadurch mit dem Kunden bekommt.  Dieses Horrorszenario, was ich beschrieben habe,  dass irgendwann ein Stück Software rauskommt und der Kunde sagt,  wow, das habe ich überhaupt nicht bestellt, da kann ich nichts mit anfangen,  habe ich in der agilen Softwareentwicklung einfach noch nie erlebt.  So, der zweite große Vorteil sind natürlich die schnellen Time-to-Markets.  Ich kenne viele Kunden, die in ihrem Bereich Marktführer sind,  die Softwaresysteme entwickelt haben für gewisse Nischen  und unglaublich viele Kunden haben und unglaublich arrogant sind  und denken, dass sie an diesem Bereich überhaupt nicht angegriffen werden können.  Und dann kommt ein kleines Startup und dieses kleine Startup entwickelt agil  und ist unglaublich schnell in der Lage, neue Softwareversionen rauszubringen  und neue Features rauszubringen, die der Markt gerade braucht,  während die mit klassischer Anwendungsentwicklung,  meistens auch mit großen Monolithen, eben nicht mehr so flexibel sind,  nicht mehr so agil sein können.  Und dann habe ich schon oft jetzt erlebt,  dass eben solche kleinen Unternehmen die großen ruckzuck eingeholt haben  und ruckzuck quasi große Kundenmengen abgeworben haben  und mein Kunde dann in große Probleme gekommen ist.  Deswegen, da müsst ihr halt auch immer ein bisschen drüber nachdenken,  wir reden hier oft natürlich nur über die Entwicklungsvorteile, klar,  aber aus geschäftsstrategischer Sicht sind diese Time-to-Markets heute,  wo immer mehr Software da ist, wo immer mehr Systeme da sind,  die IT eine immer größere Rolle spielt, einfach unfassbar wichtig.  Und wenn ihr Time-to-Markets aus agiler Softwareentwicklung  mit der traditionellen vergleicht, sind da einfach Welten zwischen.  Heute mit klassischer Softwareentwicklung zu arbeiten, ist ein unglaublich großes Risiko.  Der dritte und letzte Punkt, mein persönlicher Liebling,  doch das ist mein Platz eins, ich mache jetzt doch ein Ranking,  das ist KVP, kontinuierliche Verbesserungsprozesse,  vollständig ausgeschrieben, das ist in Scrum zum Beispiel die Retrospektive.  Wenn ich etwas wiederholend mache,  wenn ich immer wieder in Iterationen irgendetwas mache,  habe ich am Anfang der Iteration immer die Möglichkeit,  alles besser zu machen als beim letzten Mal.  Deswegen gibt es Supervisionen, deswegen gibt es in Scrum die Retrospektive  und in diesem Meeting setze ich mich hin und überlege,  was habe ich im letzten Sprint schlecht gemacht  und in der letzten Iteration, was ist schief gelaufen,  was haben wir nicht gut gemacht  und wie können wir das im nächsten Sprint besser machen.  Und was haben wir gut gemacht  und wie kann ich das Ganze für den nächsten Sprint konservieren.  Wenn man das wirklich ernst nimmt  und wenn man das kontinuierlich mit einer gewissen Hingabe macht,  dann kann man unglaublich gute Dinge erreichen.  Wenn ich mir Scrum anschaue, Scrum richtig mache  und nochmal immer einen Scrum Master habe,  immer eine Retrospektive mache,  die wichtigsten Dinge bei Scrum, meiner Meinung nach,  dann können wir nach sechs, sieben Sprints  eine dermaßen hohe Performance erreicht haben,  wo alle Entwickler sich wohlfühlen,  wo die Kunden super mit eingebunden sind,  wo alle Prozesse automatisiert sind,  wo die Systeme weitestgehend automatisiert sind und so weiter und so fort.  Es ist einfach ein unglaublich tolles und schönes Arbeiten,  wenn man quasi nach jeder Iteration  die nächste Iteration noch besser machen kann.  Und ganz ehrlich, das ist definitiv mein Lieblingspunkt.  Deswegen nochmal zusammengefasst.  Einmal das direkte Kundenfeedback,  dann zwei, die schnelleren Time-to-Markets  und drei, und da profitieren wir Entwickler ganz besonders von,  kontinuierliche Verbesserung ist einfach einer der wichtigsten Dinge  in so einem Push-Prozess wie der Softwareentwicklung.  Und allein deswegen solltet ihr alle euch  mit agiler Softwareentwicklung beschäftigen.  Am Ende interessiert mich natürlich auch, was denkst du?  Was sind deine Top drei Gründe, die drei Top Benefits,  die du hattest, als euer Unternehmen  die agile Softwareentwicklung angeführt hat?  Schreibt es mal wieder runter in die Kommentare.  Lasst uns mal wieder über das Thema diskutieren.  Das hat schon in den letzten Videos echt großartig funktioniert.  Wir haben jetzt in diesem Video mal einen Überblick gegeben  über die agile Softwareentwicklung.  Und nachdem wir jetzt agil Anforderungen ermitteln können,  agil das Ganze entwickeln, ist nur noch ein großes Fragezeichen über dem,  wie liefere ich jetzt diese Software agil schnell zu meinem Kunden?  Und damit kommen wir dann zum Thema DevOps.  Aber dazu mehr im nächsten Video.  Ich hoffe, dir hat dieses Video gefallen.  Ich hoffe, das Video hat dich wieder ein kleines Stückchen  weiter nach vorne gebracht.  Und wie immer am Ende, wenn es dir gefallen hat  und du dem Kanal helfen willst, die Reichweite erhöhen willst,  gib dem Video einen Daumen hoch.  Wenn du noch nicht abonniert hast, dann mach das.  Und ich würde jetzt sagen, ich wünsche dir einen schönen Tag.  Viel Spaß bei der Arbeit.  Bis zum nächsten Mal. Ciao. Mach's gut. 