 Jeder gute Programmierer sollte was von funktionaler Programmierung verstehen.  In diesem Video erkläre ich dir von 0 auf 100 alles, was du darüber wissen musst.  Hallo Leute, in meinem Video zu den 5 wichtigsten Vorlesungen im Informatikstudium  war eines davon die funktionale Programmierung.  Und da hat ein gewisser Seabird kommentiert, gutes Video,  mich würden noch mehr Details zur funktionalen Programmierung interessieren.  Gerne lieber Seabird, gebe ich dir heute eine Einführung in die funktionale Programmierung.  Funktionale Programmierung ist ein sogenanntes Programmierparadigma,  das heißt ein Programmierstil oder eine Programmierdenkweise.  Es ist per se an keine besondere Programmiersprache gebunden.  In fast allen gängigen Programmiersprachen kann man sowohl funktional als auch imperativ programmieren.  Ein anderes Beispiel für ein Programmierparadigma ist zum Beispiel die objektorientierte Programmierung.  Davon hast du vielleicht schon gehört, das wird eigentlich in jedem Informatikstudium  gleich vom ersten Semester an intensiv unterrichtet.  Und das ist heutzutage eigentlich das Standardparadigma, in dem überall programmiert wird.  Ganz früher war ein Computerprogramm so eine Datei, die einfach einmal von oben nach unten durchläuft.  Einfach so eine Folge von Anweisungen für den Computer.  Danach hat man festgestellt, dass es nützlich sein kann,  bestimmte Codeblöcke, die man immer wieder ausführen möchte, als Prozedur zu definieren.  Und diese Prozedur kann man dann von anderen Stellen des Programms aufrufen.  Das wird manchmal auch prozedurale Programmierung genannt.  Und die Erweiterung dessen ist die objektorientierte Programmierung,  die einem noch viel mehr Möglichkeiten bietet, sein Programm logisch einzuteilen.  In Klassen, die Instanzen haben und die Methoden anbieten.  Methode, Prozedur, Funktion sind Begriffe,  die oft durcheinander und meistens gleichbedeutend benutzt werden.  Jetzt sei gesagt, dass es hier überhaupt nicht darum geht,  objektorientierte versus funktionale Programmierung.  Im Gegenteil.  Man kann objektorientiert und funktional programmieren  oder nur funktional oder nur objektorientiert.  Das geht alles.  In der Praxis spielen sowohl funktionale als auch objektorientierte Programmierung  eine sehr große Rolle.  In den heutigen Beispielen gucken wir uns einzelne Methoden,  Schrägstrich Prozeduren, Schrägstrich Funktionen an.  Und es spielt keine Rolle, ob das jetzt eine Methode ist, die alleinstehend ist  oder ob es eine Methode ist, die von irgendeiner Klasse angeboten wird.  Wenn wir die funktionale Programmierung einmal verstanden haben,  dann können wir später noch die objektorientierte Programmierung dazunehmen  und dann schreiben wir funktionale Methoden für unsere Klassen und Objekte.  Gucken wir uns mal ein Beispiel für eine nicht funktionale, eine imperative Methode an.  Hier haben wir so eine dubiose Methode.  Es ist nicht genau wichtig, was die jetzt soll.  Das ist auch nur ein plumpes Beispiel.  Die bekommt einen Pointer zu einer Liste, einige Zahlen,  einen Pointer zu einer Liste Summen und einen Pointer zu einer Datenbank.  Und diese Methode hat etwas, das nicht funktionale Methoden oft haben,  nämlich Seiteneffekte, quasi Nebenwirkungen.  Ein Seiteneffekt ist irgendein Zustand, der sich ändert, wenn man die Methode ausführt.  In diesem Fall wird etwas in einer Datenbank gespeichert.  Der Zustand meines Programms oder in dem Fall sogar einer externen Datenbank ändert sich,  je nachdem, ob und vielleicht wie oft ich die Methode schon ausgeführt habe.  Ein anderer Seiteneffekt, den wir hier sehen, ist,  dass ich diese Liste, die von außen reinkommt, nehme und da etwas ranhänge.  Wenn jetzt diese Liste von einem anderen Programm auch noch benutzt wird  oder irgendwo in meinem Programm, dann macht es einen Unterschied,  ob ich diese Beispielmethode schon ausgeführt habe und wie oft ich sie ausgeführt habe.  Wenn ich die Methode mehrmals ausführe, tritt dieser Seiteneffekt potenziell mehrmals auf  und die Liste verändert sich mehrmals.  Bei der funktionalen Programmierung gibt es solche Seiteneffekte, wie wir sehen werden, nicht.  Eine weitere Charakteristik nicht funktionaler Methoden ist auch,  dass ich hier überhaupt meine Datenbank abfrage.  Das heißt, ich greife auf einen Zustand zu und entscheide anhand dessen,  wie mein Programm ausgeführt wird.  Bei einer Funktion ist sowas nicht erlaubt.  Und wenn ich jetzt Funktionen sage, meine ich Funktion im Sinne der Mathematik oder funktionale Methode.  Eine Funktion also ist nie von einem Zustand abhängig.  f von x gleich x².  Wenn ich das gleiche x reingebe, 5, kommt immer das gleiche x² raus, 25.  Ein Mathematiker würde niemals etwas als Funktion akzeptieren,  das nicht für jede Eingabe genau eine Ausgabe hat.  Wenn also ein Programm irgendeinen Zustand überprüft, ist das immer ein ganz gutes Zeichen,  dass es keine Funktion ist.  Hier sieht man zum Beispiel, dass der Rückgabetyp NULL ist.  In anderen Sprachen würde das vielleicht VOID heißen.  Das ist also eine Methode, die nicht zurückgibt und deswegen sowieso keine Funktion sein kann.  Das legt es ohnehin schon ein, dass die Methode eigentlich Seiteneffekte haben muss.  Denn wenn eine Methode keine Seiteneffekte hat und VOID ist,  dann heißt es, dass sie eigentlich gar nichts tut.  Und selbst diese harmlose Variablenzuweisung in Zeile 5 ist nicht funktional.  Denn wenn man nur diese eine Zeile als eigenes Miniprogramm betrachtet,  dann ist sie ganz klassisch imperativ.  Da wird dem Computer gesagt, nimm diese Zahl und füge sie der Variable zu.  Es gibt keinen Rückgabewert, aber es gibt einen Seiteneffekt,  nämlich diese Variablesumme hat danach den Wert NULL.  Das kann man sich sehr gut an den eingebauten Sortiermethoden von Python veranschaulichen.  Gehen wir so dazu einmal in die Prompt mit etwas Glück,  indem wir Python 3 oder so in unsere Kommandozeile eingeben.  Und wenn wir jetzt hier einen Python-Ausdruck eingeben, sehen wir sofort den Rückgabewert.  Zum Beispiel, wenn ich eingebe 4 plus 3, kommt sofort der Rückgabewert 7.  Wenn ich eingebe x ist gleich 4, kommt welcher Rückgabewert?  Void. None.  Denn dieser Ausdruck ist imperativ und hat keinen Rückgabewert.  Aber er hat den Seiteneffekt, dass jetzt eben x, wenn ich das abrufe, plötzlich 4 ist,  was es vorher nicht war.  Machen wir jetzt mal folgendes.  Definieren wir mal eine Liste oder ein Array.  Und sagen wir mal, das ist irgendwie so eine Liste von so ein paar gemischten Zahlen.  Python hat zwei eingebaute Wege, eine Liste zu sortieren.  Einen funktionalen und einen imperativen Weg.  Der funktionale Weg ist, indem wir schreiben sorted xs.  Und da kommt sofort zurück die sortierte Version der Liste.  Das ist eine Funktion, ganz klassisch.  Wenn ich die gleiche Liste bei sorted reingebe, kommt immer das gleiche Ergebnis.  Und es hat keinerlei Seiteneffekte, wenn ich mir die originale Liste xs angucke,  ist die immer noch unsortiert.  Im Gegenzug dazu gibt es die Methode sort.  Wenn ich die aufrufe, gibt es gar keinen Rückgabewert.  Das ist eine Void-Methode, die den Seiteneffekt hat, dass die Liste sortiert wird.  Wenn ich jetzt die Liste wieder aufrufe, ist die Liste sortiert.  Welchen Vorteil hat jetzt eine funktionale gegenüber einer imperativen Methode?  Es ist nicht immer besser, als es funktional zu schreiben.  Aber anerkannterweise sind funktionale Programme oft einfacher zu verstehen.  Das sehen wir dann auch gleich noch in den Beispielen.  Es ist außerdem viel einfacher zu testen.  Denn ich kann jede Funktion, jede funktionale Methode isoliert testen.  Denn bei der gleichen Eingabe kommt ja immer die gleiche Ausgabe raus.  Und das hängt überhaupt nicht davon ab, in welcher Reihenfolge ich verschiedene Methoden aufrufe,  welchen Zustand mein Programm hat, was in meiner Datenbank steht.  Ich kann einfach sagen, diese Methode soll xy berechnen.  Und dann kann ich genau einen automatischen Test schreiben, der das überprüft.  Es ist deswegen insgesamt auch oft weniger fehleranfällig und es kann leichter zu parallelisieren sein.  In der Praxis, wenn man mit großen Software-Systemen arbeitet, ist das oft ein Vorteil,  wenn Sachen parallel laufen können.  Und bei parallelen Prozessen ist der Zustand, der Speicher, auf den alle zugreifen, immer so ein Problem.  Wenn da ein Prozess auf den Speicher schreibt und ein anderer Prozess und dann wieder ein anderer das gleichzeitig lesen will,  dann ist das relativ kompliziert, das sauber hinzukriegen.  Funktionale Programmierung hat solche Probleme nicht, weil sie zugegeben ja auch nichts speichert.  Und da kommen wir auch zu der Begrenzung funktionaler Programmierung.  Man kann natürlich nicht das ganze Software-System funktional schreiben.  Denn an irgendeinem Punkt ist I.O. natürlich unabdingbar.  Mein Programm muss ja vielleicht alle möglichen Dateien schreiben und lesen,  Datenbanken schreiben und lesen, das ist normal.  Aber das hält uns ja nicht davon ab, ganz viele Methoden trotzdem funktional zu schreiben.  Denn es ist ja nicht so, dass jede Methode und jeder Teil meines Programms  wirklich auf Zustand zugreifen und Zustand schreiben muss.  Das ist in der modernen Softwareentwicklung auf jeden Fall sehr beliebt,  große Teile des Programms einigermaßen funktional zu gestalten.  Da wird oft von so Begriffen wie Stateless Design gesprochen.  Und Stateless, das ist mein positives Merkmal, dass es keinen Zustand gibt.  Denn das hat sich einfach bewährt und es hat sich immer wieder gezeigt,  dass es das Leben leichter macht.  Also hoffentlich bist du damit überzeugt und möchtest jetzt lernen,  wie man ein Programm funktional schreibt.  Da gibt es im Wesentlichen zwei Methoden.  Eine Methode, mit der an der Uni oft viel Zeit verbracht wird, ist Rekursion.  Das ist auch nützlich, Rekursion zu lernen.  Das ist gut, rekursiv denken zu können.  Aber in der Praxis ist es schon sehr selten,  dass ein Softwareentwickler eine Rekursion schreibt.  Über Rekursion mache ich vielleicht mal ein eigenes Video.  Wir konzentrieren uns heute auf die andere Methode,  die in der praktischen Softwareentwicklung viel wichtiger ist.  Und das sind die Funktionen höherer Ordnung.  Eine Funktion höherer Ordnung ist grob gesagt eine Funktion,  die eine andere Funktion als Argument bekommt  und oder eine andere Funktion als Rückgabe liefert.  Wir gucken uns gleich die vier wichtigsten Funktionen höherer Ordnung an.  Das sind Map, Filter, Reduce und Curry.  Gucken wir uns das mal in der Praxis an.  Als Beispielproblem habe ich mir folgendes ausgedacht.  Wir wollen eine Funktion schreiben, die eine Liste mit einer Zahl multipliziert.  def.multipliziereListe bekommt eine Liste, nennen wir mal xs,  und k, ein Integer, und gibt uns eine Liste zurück.  Das soll dann so gehen, dass jede Zahl in der Liste mit dieser neuen Zahl multipliziert wird.  Wenn wir das imperativ lösen wollen, würde das ungefähr so gehen.  Wir definieren eine neue Liste, die ist am Anfang leer.  Dann gehen wir einmal in einer Vorschleife durch die Liste durch  und in diese Ausgabeliste hängen wir an das Element, das es schon gab,  multipliziert mit dem k, das reinkommt und am Ende geben wir die Ausgabe zurück.  Fertig.  An der Methode ist nichts auszusetzen, aber wir wollen ja heute funktionale Programmierungen lernen  und dafür müssen wir vor allem erstmal ein Konzept verstehen und das sind Closures.  Pass auf.  Sagen wir, wir wollen eine Methode schreiben, mal, und diese Methode bekommt ein Integer  und sie gibt mir zurück eine Methode.  Und zwar, in Python schreibt man das als callable und diese neue Methode,  Funktion, sollte ich sagen, bekommt ein Integer als Argument und gibt ein Integer zurück.  Aus technischen Gründen müssen wir das hier oben noch importieren.  Das ist jetzt Python-spezifisch und nicht weiter spannend.  Und dann habe ich mir überlegt, dass ich dieser mal-Funktion eine Zahl übergebe  und dann bekomme ich eine neue Funktion zurück und diese neue Funktion macht folgendes,  die kriegt eine Zahl und multipliziert diese Zahl mit der vordefinierten Zahl.  Das heißt, was ich später machen will, ich möchte sowas schreiben können wie mal 2 ist mal 2  und dann möchte ich schreiben, sagen wir, x ist gleich mal 2 5 und dann soll x den Wert 10 haben.  Und das machen wir, indem wir hier eine Sub-Methode definieren, mal x.  Ihr seht schon, ich sage Methode und Funktion auch immer völlig gleich bedeutend.  Und diese mal-x-Funktion bekommt ein y, das ist auch wieder ein Integer und die gibt ein Integer.  Das ist also genau die Signatur, die wir hier als Rückgabe haben wollen.  Und dann gibt sie x mal y zurück.  Und diese mal-x-Funktion ist die Ausgabe unserer mal-Funktion.  Und das wichtige Konzept, das in ganz vielen Programmiersprachen wichtige Konzept, ist hier das Closure.  Wenn wir mal gucken, diese Methode mal x, wenn ich diese Definition mal rauskopiere und hier unten hin,  dann ergibt das ja gar keinen Sinn, denn hier wird auch sofort gemeckert, das x ist ja gar nicht definiert.  Ich benutze eine Variable, die es eigentlich gar nicht geben kann.  Und warum geht das eben doch?  Weil in dem Kontext hier, in diesen Zeilen, in diesem Skopus- oder Gatingsbereich, wie man sagt,  das x definiert ist, über die äußere Funktion.  Und ein Closure heißt jetzt folgendes, indem wir dieses mal-x zurückgeben,  da geben wir nicht einfach nur eine Funktion zurück, da geben wir ein Closure zurück.  Und zwar ist das die Funktion, die wir aufgeschrieben haben,  und ein Snapshot des Gatingsbereichs, in dem sich diese Funktion befunden hat.  Das heißt, wenn wir uns hier in dieser Zeile befinden, hat x ja einen besonderen Wert.  Wenn das Programm durchläuft, hat x einen zugewiesenen Wert.  Und diese Information, dieses Subuniversum, in dem wir uns befinden, dem x sagen wir den Wert 2 hat,  das wird zusammengepackt, eingeschlossen mit dieser Funktion.  Und das ist ein Closure.  Das können wir mal kurz hier unten ausprobieren.  Dann importieren wir die Funktion, die wir gerade definiert haben.  Und dann, wie gesagt, zum Beispiel sagen wir mal 3 ist mal 3.  Und wenn wir jetzt eingeben mal 3 von 5, kommt 15 raus.  Wunderbar. Und jetzt wollen wir diese Funktion höherer Ordnung hier,  denn das ist ja so eine halbe Funktion höherer Ordnung,  die kriegt zwar keine Funktion ins Argument,  aber sie gibt eine Funktion als Zurückgabe wieder.  Die wollen wir benutzen, um dieses Multipliziere-Liste-Funktional neu zu schreiben.  Und das geht so.  Multipliziere-Liste-Funktional kriegt eine Liste,  immer ein Integer k, und gibt eine Liste zurück.  Und jetzt definieren wir unsere mal k-Funktion anhand des gerade implementierten mals.  Und die ganz wichtige Funktion höherer Ordnung, die wir jetzt hier benutzen,  die es in ganz vielen Programmiersprachen gibt, voreingebaut, ist map.  Map ist gewissermaßen das funktionale Äquivalent der Vorschleife, die wir oben gesehen haben.  Map bekommt zwei Argumente, eine Funktion und eine Liste.  Und es gibt zurück eine neue Liste, die entsteht,  indem auf jedes Element in der Liste die Funktion angewendet wird.  Also, was wir hier zurückgeben wollen, ist map, dann unsere mal k-Funktion und die Liste.  Und das war's.  Aus technischen Gründen müssen wir noch einmal Liste rumschreiben.  Das liegt einfach daran, dass map in Python speziell einen Iterator zurückgibt und noch keine Liste.  Das ist aber ein unwichtiges Randdetail.  Jetzt gucken wir mal hier unten, was passiert, wenn wir diese neue Funktion importieren.  Dann können wir also eine Liste eingeben, sagen wir irgendwelche Zahlen und eine Zahl  und erhalten zurück die Liste, die sich ergibt, indem jedes Element mit dieser 3 multipliziert wird.  Ein weiteres Konzept, das in der funktionalen Programmierung ganz wichtig ist,  sind anonyme Funktionen, die oft Lambda-Funktionen genannt werden.  Wenn wir in Python eine Funktion definieren, dann geht das ja normalerweise mit def.  Zum Beispiel def foo, xInteger, dependInteger zurück und sagen wir, das wird jetzt einfach plus 1 addiert.  Ein anderer Weg, so eine Funktion zu definieren, ginge so.  Sagen wir, bar ist Lambda x, x plus 1.  Und wenn wir das hier ausprobieren, dann sehen wir, dass die Funktionen sich völlig gleich verhalten.  Was hier passiert ist, dass mir dieses Schlüsselwort Lambda erlaubt, eine anonyme Funktion, eine unbenannte Funktion zu definieren.  Ich könnte das hier unten einmal so hin kopieren und dann kommt zurück, das ist eine Funktion.  Dieser Ausdruck hat den Wert dieser Funktion, ohne dass ich in diesem Fall jetzt der Funktion irgendeinen Namen gegeben habe.  Und da hat man sich überlegt, dass so eine Variablenzuweisung syntaktisch nicht so schön ist.  Deswegen gibt es eben dieses äquivalente Format, in dem man das auch schreiben kann, eine benannte Funktion.  Anstatt jetzt eine anonyme Funktion zu definieren und die einer Variable zuzuweisen, kann ich das gleich mit def hinschreiben.  Das ist aber letztlich nur syntaktischer Zucker, sagt man.  Das ist eigentlich gleich bedeutend, was da passiert.  Gut, und in der funktionalen Programmierung, dadurch, dass man so Funktionenhörer und irgendwie Map hat,  möchte man das ganz oft, dass man eine Funktion mal eben kurz benutzt, die eigentlich aber nicht in irgendeinem Interface anbieten will.  Zum Beispiel, wenn wir das hier einmal entfernen, diese ganze Geschichte mit dem Mal da oben, ist gut, um das mit der Closure zu verstehen.  Aber eigentlich können wir das hier direkt mit einer Lambda-Funktion schreiben.  Und da sagen wir einfach Lambda x x mal k.  Ich führe das jetzt nicht vor, es funktioniert, glaub's mir.  Aber das ist jetzt schon ein relativ kurzer Ausdruck.  Da würde ich schon fast sagen, dass ich die Version in Zeile 18 besser finde, als die imperative Version, die wir oben hingeschrieben haben.  In diesem Fall ist das eh alles noch relativ einfach.  Aber bei so komplizierten Programmen, wo man dann mehrere Schleifen ineinander vernesten muss,  kann es oft sein, dass man die funktionale Programmierung schöner aufschreiben kann.  Und dass der Leser es vor allem besser versteht, dass er nicht im Kopf durch die ganzen verschachtelten Schleifen gehen muss und überlegt,  was hat jetzt welchen Wert und in welcher Reihenfolge wird was ausgeführt,  sondern man sieht sofort diesen funktionalen Ausdruck und kann ihn hoffentlich gut verstehen.  Übrigens möchte ich noch sagen, dass bei der Version, die wir hier vorher hatten,  da noch ein anderes relativ einfaches Konzept eine Rolle spielt.  Wir haben hier nämlich eine zweistellige Funktion.  Dieser Stern ist ja auch eine Funktion, die zwei Argumente nimmt und miteinander multipliziert.  Und wir geben zurück eine Funktion, die nur ein Argument kriegt  und das andere Argument quasi schon festgelegt ist und das dann aufmultipliziert.  Und dieser Vorgang, dass man eine Funktion mit einer bestimmten Stelligkeit, einer bestimmten Anzahl Argumente nimmt,  dann ein Argument fixiert und eine neue Funktion zurückgibt,  die eine Stelligkeit weniger hat und nur noch ein Argument in dem Fall braucht,  das heißt Currying.  Dieses Prinzip des Curryings ist benannt nach einem amerikanischen Mathematiker,  der mit Nachnamen so hieß, Curry.  Nach dem ist übrigens sogar eine funktionale Programmiersprache benannt.  Und damit meine ich nicht die Sprache Curry, die es gibt, aber relativ exotisch ist,  sondern die Sprache Haskell.  Denn man hieß einfach so, Haskell Curry.  Und die nach ihm benannte Programmiersprache Haskell ist gar nicht unbekannt,  ist wahrscheinlich die bekannteste der funktionalen Programmiersprachen.  Es gibt zum Beispiel sogar bei Facebook ein relativ großes Team,  das ausschließlich in Haskell arbeitet.  Also wir haben Map gesehen, wir haben impliziterweise hier Curry gesehen.  Was wir uns noch angucken müssen, ist zum Beispiel Filter.  Filter, naja, filtert.  Sagen wir, wir wollen eine Funktion schreiben, größer als,  die bekommt eine Liste und ein Integer  und liefert mir eine Liste, und zwar gefiltert,  mit nur denjenigen Elementen der Liste, die größer sind als k.  Das funktioniert so, Filter, sieht man hier schon, bekommt eine Funktion und eine Liste.  Und diese Funktion muss ein Prädikat sein, also eine Funktion, die wahr oder falsch zurückgibt.  Schreiben wir zum Beispiel, Lambda bekommt ein x und gibt mir zurück,  ob x größer ist als k, wahr oder falsch.  Und dann kommt noch die Liste dazu.  Und wie vorher müssen wir aus technischen Gründen noch einmal diesen Listwrapper aufrufen.  Und das war's. Einmal hier zur Vorführung importieren wir das  und probieren aus, größer als eine Liste zufälliger Zahlen.  Und sagen wir alle, die größer sind als 3 und bekommen 5 und 7.  Relativ unkompliziert.  Und das letzte wichtige Beispiel für die Funktion höherer Ordnung ist Reduce.  Reduce nimmt eine Liste und reduziert sie auf einen Rückgabewert.  Und das funktioniert so, indem man eine zweistellige Funktion übergibt,  also eine Funktion, die zwei Eingaben kriegt, und einen Startwert.  Und was Reduce macht, ist, es nimmt den Startwert und das erste Element der Liste  und kombiniert sie zu einem neuen Wert, den wir uns merken.  Dann nimmt es diesen neuen Wert und das zweite Element der Liste  und kombiniert sie wieder zu einem neuen Wert.  Dann nimmt es wieder den Wert und das dritte Element und so weiter.  Reduce wird in manchen Poemiersprachen auch Fold Left genannt,  weil man von links nach rechts durch die Liste durchgeht und immer so zusammenfaltet  und bei jedem Schritt wird die Liste ein Element kleiner.  Gucken wir uns das in der Praxis an.  Sagen wir, wir wollen eine Liste Summe schreiben.  Die gibt es natürlich schon eingebaut, aber sagen wir, wir wollen sie schreiben.  Kriegt eine Liste und gibt zurück ein Integer.  Das war die Summe aller Zahlen in dieser Liste.  Das können wir ganz einfach mit Reduce machen.  Reduce bekommt eine zweistellige Funktion,  die in diesem Fall die beiden Argumente einfach aufradiert.  Dann eine Liste und einen Startwert, sagen wir 0.  Reduce war ein wichtiges Konzept,  aber wenn der modernen Python-Welt nicht allzu beliebt ist,  ist das nicht mehr eingebaut und wir müssen das hier einmal importieren.  Wenn wir das wieder ausprobieren,  dass wir hier einmal den Import machen,  dann können wir sagen, wir übergeben eine beliebige Liste  und bekommen die Summe der Elemente der Liste zurück.  Es sei der Vollständigkeit halber gesagt,  dass das hier nicht der beste Weg ist,  diese Funktion in Python zu implementieren.  Es ist jetzt nämlich so, dass Python für alles,  was mit Map und Filter zu tun hat, eine sehr schöne Syntax anbietet.  Das sind die sogenannten List Comprehensions.  Wenn wir also diese Funktion hier einmal nehmen  und dann nochmal die schöne Python-Version davon anlegen,  das geht jetzt nicht in anderen Programmiersprachen,  dann können wir anstatt dieses ganzen Gebildes mit List und Map und Lambda sagen,  gut, was wollen wir?  Wir wollen jedes Element der Liste multipliziert mit K  und das schreiben wir einfach hin.  Wir sagen x mal K für x in XS und das war's.  Und ähnlich schön geht das hier bei dem Filter,  auch da zur Vollständigkeit halber nochmal die bessere Python-Version.  Wir wollen jedes x, das größer ist als K.  Dann sagen wir einfach, okay, gib uns jedes x vor x in XS,  aber nur wenn x größer als K.  Und da kann es ehrlich gesagt auch gar keinen Zweifel mehr geben,  ob jetzt diese Version hier oder diese letzte Version hier schöner ist.  Es ist viel kürzer, viel schöner und es ist funktionaler Code  und hat damit all die Vorteile funktionaler Programmierung.  Python ist eben eine besonders ausgefeilte Programmiersprache,  in der man sowohl imperative als auch funktional ausgezeichnet programmieren kann  und das ist auch der Grund, warum es in der Praxis eine der beliebtesten Programmiersprachen ist.  Es wäre sehr falsch zu denken, dass Python nur so eine Skriptsprache für Data Scientists ist.  Das gesamte Instagram-Backend ist zum Beispiel in Python geschrieben.  Der Grund, warum ich das trotzdem erstmal mit Map und Filter erklärt habe,  ist, dass das eben die übertragbaren Konzepte sind.  Das gibt es in ganz vielen verschiedenen Programmiersprachen  und von einem guten Programmierer erwarte ich,  dass er sowas wie Map und Filter einfach kennt.  Für die Java-Fans unter euch, denn ich weiß auch,  dass an vielen Unis Java die Einstiegssprache ist,  sind hier nochmal alle unsere Beispiele in Java aufgeschrieben.  Halt das Video einfach an, wenn du dir das in Ruhe durchlesen willst.  Du kennst jetzt also die wichtigsten Konzepte funktionaler Programmierung.  Closures, Lambda-Ausdrücke und Funktionen höherer Ordnung,  zum Beispiel so wie Map, Filter, Reduce und Carry.  Damit sich dir das besonders gut einprägt, habe ich noch drei Übungsaufgaben für dich.  Und zwar habe ich drei Funktionen, von denen ich möchte,  dass du sie mit einem Einzeiler implementierst.  Da kommt in der Implementierung also sofort Return und dann ein funktionaler Ausdruck.  Und diese Funktionen heißen AnzahlGerade, Carry und MeinFilter.  Ich führe kurz vor, wie die funktionieren sollen.  AnzahlGerade bekommt eine Liste und gibt die Anzahl der geraden Elemente zurück.  Carry ist Carry.  Sagen wir zum Beispiel, ich definiere mir eine Funktion foo,  die bekommt drei verschiedene Integers.  Es muss nicht drei sein, aber sagen wir drei.  Es soll mit jeder Zahl funktionieren.  Und was macht die Funktion zum Beispiel?  Addiert sie die einfach auf.  So, und jetzt soll ich sagen, sagen wir mal Bar ist gleich Carry.  Und zwar übergebe ich einmal die Funktion und eine Zahl, ein Argument.  Sagen wir 5.  Und jetzt soll diese 5 als erstes Argument festgelegt werden.  Bar kriegt jetzt also nur noch zwei Argumente, zum Beispiel 3 und 2.  Und heraus kommt 5 plus 3 plus 2 ist 10.  Und die letzte Funktion MeinFilter, kannst du dir schon denken,  soll sich einfach genau wie die echte Filterfunktion verhalten.  Also zum Beispiel MeinFilter, Lambda, x, x größer 3.  Und dann eine Liste.  Kommen dann genau die Elemente zurück, die größer sind als 3.  Jetzt soll also jede dieser Funktionen mit einem Einzeller programmiert werden.  Da gibt es ganz verschiedene Wege, wie man das machen kann.  Als zusätzliche Einschränkung deshalb folgendes.  Die erste Funktion, Anzeigerade, sollst du mit einem Reduce und Filter programmieren.  Also beides muss irgendwie sinnvoll benutzt werden.  Reduce und Filter.  Bei der Carry-Funktion mache ich keine Einschränkung.  Aber bei MeinFilter musst du ausschließlich Reduce benutzen.  Keine anderen Funktionen höherer Ordnung.  Und natürlich kannst du in allen drei Fällen Lambda-Ausdrücke benutzen.  Wenn du die Lösung weißt, egal ob in Java oder in Python, ich habe es selbst nur in Python gemacht,  schreib unten einen Kommentar mit der Lösung.  Am liebsten schreibst du davor einen Spoiler-Alert mit ein paar Leerzeilen oder Punkten oder so,  damit das nicht sofort angezeigt wird.  Also ich bin gespannt, wer es erst herauskriegt und was da für Lösungen kommen.  Und ich appelliere vor allem an dich, wenn du neu bist in funktionaler Programmierung,  das wirklich mal zu machen und die Lösung hier hin zu schreiben.  Wenn du irgendwelche Fragen oder Anmerkungen hast, freue ich mich wie immer über deinen Kommentar.  Wenn dir das Video gefallen hat, gib einen Daumen hoch, es hilft.  Abonnier den Kanal, wenn du es noch nicht gemacht hast.  Bis bald im nächsten Video.  Untertitel von Stephanie Geiges 