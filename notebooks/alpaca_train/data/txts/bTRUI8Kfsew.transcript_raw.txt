 Hello world, Noah here.  Welcome to part two of my retrospective  on my 10-year programming journey.  If you haven't already seen part one,  you should watch it first.  Otherwise, let's pick up where we left off  right after my high school graduation.  ♪♪  Before I talk about my college experience,  I want to talk briefly about the difference  between computer science and programming  because the distinction is important.  Programming is the act of writing code,  but computer science deals with the ideas,  theories, and proofs that underpin the field.  It's one thing to be able to write a program,  but it's another thing entirely to prove  that a computer can run that program  or to discuss in mathematical terms  how long the program takes to run  as a function of the size of its input.  Some of my classes, like operating systems,  did involve programming,  but the focus was still on understanding  the underlying concepts,  and oftentimes this was harder  than actually writing the code.  Some classes, like theory of computation,  didn't involve any code at all,  and instead focused entirely on proofs, theory, and logic.  In my day-to-day work as a software engineer,  very little of what I learned in college  is directly applicable,  and I could probably still do my job just fine  if I hadn't gone to college.  However, college did teach me how to think,  how to approach a problem,  understand it, and begin to solve it.  It gave me a look at many different areas of computing  so that I could see what I did and didn't like,  and every so often, something I learned in a class  is directly applicable to a problem or discussion.  So overall, I'd say that college  was absolutely worth it for me,  but if you're looking to study computer science,  it may not be what you expect,  but I'm getting a bit ahead of myself here.  I did a lot during my three-and-a-half-year undergrad  at Penn State.  In my freshman year, I worked as a freelancer  and built an app for a company.  I also continued to compete in programming competitions,  and I even went to the International Collegiate  Programming Contest, ICPC.  I did not do very well.  In addition to programming competitions,  I also competed in hackathons.  If you don't know, a hackathon is an event  where teams work under a tight deadline  to build a project from scratch.  It's a great opportunity to work with friends  and a great excuse to start a new project.  Hackathons typically take place on weekends  so that competitors can go all out  and pour hours into their projects.  My favorite project was a code translator.  You could input code in one language,  and it would be translated first  into an intermediate representation,  and then into code in the target language.  We pulled an all-nighter to get a working demo  with a couple of languages and basic translation,  and although we didn't place,  it was a lot of fun and I learned a lot.  In general, I've found that when I have an idea  for a new project, I'm very excited at first  and often can't stop thinking about it.  However, once enough time passes,  whether I've actually worked on the project or not,  I'll often start to lose motivation.  I've adopted the general strategy  that if a good idea comes to me  and I know I want to work on it,  I should try and get as much work done  as quickly as possible,  so that by the time I lose my initial motivation,  I've either put in enough effort to be willing to give up  or I've gotten enough additional motivation  to be excited to continue to work on the project.  So here's another piece of advice.  Find something that will give you  frequent incremental motivation.  Once I get that initial burst of work done  and I have a prototype,  I'm usually motivated to continue working,  and as I refine the prototype and add new features,  I get further motivation from seeing the project develop.  I also worked for a few semesters as a teaching assistant  in the computer science department.  I held recitations where I reinforced concepts  that were taught in class  and helped students understand  and complete their assignments.  I even sometimes did one-on-one sessions  with students upon request.  In these sessions,  I was able to provide personalized lessons,  answer any and all questions that the student had,  and ensure that they truly understood  what they were learning.  Much like when I worked as a teaching assistant  in my senior year of high school,  this was a great opportunity to continue teaching.  It even inspired a short-lived series  on my YouTube channel called CS University,  which I made partially as a resource  for students taking the programming fundamentals class  for which I was a TA.  Since I'm talking about my college years,  I should talk about some of the classes I took.  My favorite class was probably Comp Sci 311,  Introduction to Systems Programming.  In this class, we learned low-level C programming  and even touched on some assembly.  I really enjoyed this class  because I hadn't had much experience  with these areas of programming beforehand,  so I learned a lot.  The low-level programming I did in this class  was actually quite different  from the high-level programming I was used to.  There was a whole different set of considerations  that I had to worry about.  I was no longer dealing with object-oriented programming,  async await, and multithreading,  but I did have to worry about managing my own memory,  making sure that my strings were null-terminated,  and avoiding segfaults.  My favorite project in that course was Bomb Lab.  You were given an executable, the bomb,  and you had to figure out the passwords  that would disarm each stage.  The bomb executable had to be run  on the school's lab machines,  and every time you entered a wrong password,  the bomb would notify a server  and you would lose half a point from your final grade.  The only way to disarm the bomb  was to step through the instructions with the debugger,  understand what the assembly code was doing,  and reverse-engineer the passwords  that the code was looking for.  The first thing I did was get the bomb executable  to run inside of a virtual machine  that was disconnected from the internet,  so I wouldn't have to worry about losing points.  This ended up taking a significant amount of time,  and it probably wasn't worth it in the end,  but I was proud of myself for figuring it out.  I confirmed with the professor,  who said that I was allowed to run the bomb in my VM,  since I had figured out how to make it work  This process took so long  that I didn't have much time  to actually do the project before the deadline,  so I worked hard for a few days  figuring out how to solve the bomb  and writing up my process to submit along with my answers.  Overall, I learned a lot about assembly code  from this project,  and I felt like I had truly solved a mystery.  I also did research during my undergrad.  I was in the Schreyer Honors College,  and one of the requirements was to write an honors thesis.  I did research with a professor  in the field of natural language processing,  which is concerned with how computers  can understand and interact with human language.  I did experiments on an algorithm  that was developed in our lab  that attempted to automatically grade summaries  written by students for school assignments.  The algorithm basically worked like this.  First, a few experts would write summaries  that we know are good, which we call golden summaries.  Then, using software built in our lab,  someone would break down each golden summary into fragments  called summary content units,  where each SCU expressed a single idea.  Then, they would link SCUs from different golden summaries  that express the same idea.  The theory is that the more summaries  a particular idea appears in,  the more important that idea is.  Then, to grade student-written summaries,  our algorithm would break the summaries down into SCUs,  compare the student SCUs to the golden SCUs,  and score the summary.  I experimented with changing parameters  and using different models to encode words,  among other things.  Overall, I personally found research  to not be as enjoyable as programming,  but I learned a lot about NLP  and further developed my interest in the field.  This led me to take a class  that was run by the lab's professor, which I enjoyed a lot.  And I also got to write a thesis, which is pretty cool.  I also did a few internships.  In the summer between high school and college,  I worked at Lockheed Martin for about a month.  I worked on some internal websites  that are probably long since gone,  and the internship wasn't particularly exciting,  but it was a good first experience.  In the summer after freshman year,  I worked at a small fintech company in Delaware.  This was my first real experience of working on a team  and delivering a product.  I mostly worked on a new version of their customer portal,  and I also worked on some internal tools.  I even got to give a presentation on Kotlin  to a local bootcamp that sends some graduates  to the company.  But the big one happened in the summer of 2019,  after my sophomore year.  Google reached out in 2018,  and I went through the intern interview process.  I found out in March of 2019  that I had cleared the hiring committee.  Now I just had to wait for a team match.  Google's hiring process is a bit weird,  and it's the same for interns and full-time.  In most cases, including mine,  you're interviewed as a generalist software engineer.  If you pass the hiring committee,  it means that Google deems you good enough  to work on most teams,  but then you enter the team matching stage.  Hiring managers are able to see your information,  and if they think that you might be a good fit for the team,  they'll schedule a call.  If the call goes well and both sides are interested,  the match is made.  But some people never get that call.  That means that Google deemed them good enough,  but there just wasn't a spot open for them.  It's pretty heartbreaking to make it that far,  to pass the interview, but not get the job.  And that's where I was in April of 2019.  I had been in team matching for a few months  and hadn't heard anything back.  School was going to be ending in a couple of weeks.  I had another internship lined up  at a small company in Ohio.  It was cool, but it was no Google.  And then in late April, I got an email.  There was a team that wanted to talk to me.  The call was scheduled for the next day, and it went well.  A day or two later, the match was made, and it was official.  I was going to Google in just a couple of weeks.  My 2019 internship was an incredible experience.  I worked on an internal analytics tool  for Google's first-party mobile apps.  My office was in Sunnyvale,  and I lived in San Jose and biked to work every day.  I learned a lot about being a software engineer,  more on that later, and made some friends,  two of whom are my current roommates.  I interned again in the summer of 2020.  Of course, due to that thing that happened in 2020,  the internship was remote.  I was bummed to not be in person in California,  especially since my new team was in Mountain View,  but the remote internship was still a good experience.  I worked on the AdWords conversion tracking team.  The team uses the Dart language,  which was created at Google for its front-end web code,  so I learned it.  It's my most used language of the past couple years,  so it was definitely a worthy investment.  In order to help myself learn Dart,  I decided to take my own advice  about finding different ways to apply the skills I have.  Shortly before my internship began,  I started working on an app in Flutter,  a mobile app framework built by Google  that uses Dart as its language of choice.  For the past five years,  I've used a service called Last.fm  to track my music listening habits.  You can track every time you listen to a song  and then see detailed statistics  about your top artists, albums, and tracks.  Last.fm does have a mobile app, but it's quite limited.  Most importantly, it doesn't allow you  to manually scrabble or track your music.  I also wanted a Shazam-like feature  that would recognize the song that was playing around me  and then scrabble it,  so I set about building my own Last.fm client,  which I called Finale.  I built a basic version that could fetch some stats,  and then I integrated a third-party framework  called ACR Cloud to do the music recognition.  At this point, I had a custom app  that was genuinely useful to me  and that, as far as I knew, didn't exist anywhere else.  I continued to add features and refine the app  for the next six months  until it was a proper Last.fm client  with a decent amount of polish.  At that point, I figured  that others might find the app useful,  so I decided to publish it on the App Store and Play Store.  To date, the app has received  more than 40,000 downloads across both stores,  and I've added a bunch of new features  that were requested by users  who reached out via email or the subreddit I set up.  Here's a piece of advice.  If you're launching an app or service or video series  or anything that exists within a niche,  find out where those people congregate online  and market to them there.  Chances are that you already know where these places may be.  When I published Finale on the App Store and Play Store,  I made a post on the Last.fm subreddit  and got a lot of users from there.  Some of them even suggested features  that they wanted to see implemented,  and when I implemented those features,  I made update posts on the Last.fm subreddit  to keep the app on people's minds  and bring in a steady stream of new users.  I also used this tactic back in the days  when I was making Minecraft tutorials.  I posted frequently on the bucket forums  and even took plugin requests there.  Even when I wasn't directly promoting my videos,  I was making a name for myself in the community  so that maybe someone would check out my profile  and see my videos,  or maybe they'd ask me how to make plugins themselves,  and boy, do I have a great resource for them.  So now it's December of 2020,  and I graduate from college at home a semester early.  I've already accepted a job at Google  that will start in February,  so I have some time off.  I've been at home for almost a year,  so I need a change,  but the Google offices aren't open yet,  so there's no point in moving out to California.  My good friend and fellow YouTuber, Luke Miani,  lives in Washington, D.C.,  so why not move there?  We plan to rent a shared studio space  where Luke could make YouTube videos  and I could do my remote job.  So in mid-January of 2021,  I packed up my car and drove down to D.C.  before I even had a place to live.  I was able to find one pretty quickly and got set up.  My job at Google started in mid-February.  I was working on an internal mobile app  that the Google Ads salespeople use to manage their data.  The app was written in Flutter,  so my experience building Finale came in handy.  The team was pretty small,  which meant that I got to have ownership  over large pieces of the app.  I can't talk too much about exactly what I did,  but I definitely learned a lot.  In late 2020, Luke had purchased a lot of 50 iPhone 4s  and 4Ss from eBay.  His original idea was just to clean them up,  see how many of them worked, and play around with them.  But I had another idea.  Maybe I could build an app  that would connect all of the iPhones together  to do cool things.  When I moved to D.C., the project started in earnest,  and once I had a working prototype,  Luke ordered 50 more iPhones so that we could have 100.  The resulting project is an app and server called MultiPhone  that links all 100 iPhones together  and turns them into a giant video screen,  a chess board, a deck of cards, and more.  You can check out my video  explaining exactly how the app works.  I'm really proud of it.  This project is another example of starting small  and working my way up.  When I first had the idea,  I didn't even know if it was going to be possible.  These phones are pretty old,  so I'd have to figure out what version of Xcode  I needed to use and see if I could even build  and run apps on these old phones.  Once I got that figured out,  I had to make sure that the phones  could communicate with the server  in reasonably close to real time.  Once all of the experimentation was done  and I felt confident that I could build the app,  I worked on one feature at a time  until I had enough features to call the project finished  and make a video on it.  I lived in D.C. for about eight months  and had an incredible time there.  I think about it often,  and I honestly wouldn't be surprised  if I end up back there in the future.  But in August of 2021, Luke was moving apartments  and the Google offices had opened back up,  so my time in D.C. was over  and it was time to move to Mountain View.  Since my team was pretty small  and Google still wasn't requiring people  to show up in person,  I typically went to a different office each day  to try different cafes and work in different environments.  I continued to build features  and fix bugs for the mobile app,  but in early January of 2022, I got really lucky.  I can't talk too much about the specifics,  but there was an emergency project  that some people in my organization  were tasked with delivering.  My manager and I worked on it  along with some other engineers.  The plan was for it to be a one-off deliverable  that we would hand off to another team  and then go back to our normal jobs.  But the project was a success  and I guess Google decided  that it would be in their interest  to invest in a permanent team to build it out.  While most of the contributors  went back to their normal jobs,  my manager stayed on the project  to be the engineering lead and I joined him.  For a few months,  it was just me and my manager on the project,  but since then, we filled out our engineering team  and hired product managers and UX folks  to round out the team.  Since I was the second most senior member of the team  and because I had been at Google  for over a year at this point,  I became the tech lead  of a significant portion of our product.  These days, I manage the work of three other engineers  and the four of us are responsible  for the front-end client and server code for our product.  I want to take a second to talk about the difference  between programming and software engineering.  Programming is, in fact,  just one piece of software engineering  and it's not even the most complicated piece.  When you're working on a school or personal project,  you generally have a good idea of what you want to build  and you hack away at it until it works.  This is programming writing code,  but software engineering is so much more than that.  In my daily job, I work on large, complex systems  that are going to be maintained by many engineers,  will be around for a long time, and that have to work well.  When I start working on a new project,  I first have to understand the requirements,  which involves talking to product managers,  UX folks, and other engineers.  Once I have an understanding, I write a design document  where I detail the approach I want to take,  why I'm choosing that approach,  how I'll go about doing it,  and the other approaches I considered  and why I didn't choose them.  These documents are often very long and technical.  Then I send them out for review  and go through a few rounds of comments,  sometimes in meetings and sometimes asynchronously.  Once the design is approved,  I'll start working on the project,  but I'll often run into unforeseen issues  that require me to revise the design.  Sometimes I'll even have to start from scratch.  As I'm designing the system,  there are a lot of things that I have to keep in mind.  I have to write tests  and make sure that the code is well covered.  I have to worry about logging and monitoring  and security and privacy.  I have to make sure that errors are recorded  and that the right people are notified as needed.  I have to make sure that the system is fault tolerant  so that it can recover from bad scenarios.  And all of the code that I write has to be clean,  concise, well-documented,  and in conformance with the company style guide  so that other engineers who have to read and modify my code  will have an easier time doing so.  All of this stuff, especially the design,  is the real meat of software engineering.  A lot of this stuff just doesn't come up  when you're working on a small personal project  or hacking away at something for a hackathon.  If this all sounds a bit intimidating to you, don't worry.  When you first start a software engineering job,  you'll mostly just be doing programming.  The first few months are dedicated to ramping up,  learning about the company's internal tools  and best practices,  as well as the code base and product  that you'll be working on.  As you gain more expertise,  the other pieces of software engineering  will be introduced slowly but surely.  For your first project,  you'll probably be given a fairly straightforward feature  to implement that requires little exploration.  But for your second project, there may be some uncertainty,  so you'll have to make a decision  and justify it in a design doc.  And slowly but surely, the other stuff will come in.  As you gain seniority on your team  and become an expert in certain areas,  you may find that your teammates,  and perhaps even people outside of your team,  will come to you with questions,  and you may even find that you're able to answer them.  You'll start to guide or influence your teammates' work.  You'll ask more relevant questions in meetings,  poke more holes in designs, and so on and so forth.  It's a gradual process.  You don't wake up one day  and realize you've become a tech lead.  You just notice over time  that you're becoming more independent,  making the right decisions quicker and more often,  and providing more value.  It's a great feeling.  And that just about catches us up to today.  I've been at Google for almost two years now,  and I'm looking forward to delivering  the first version of our product this year.  I also work on Finale on occasion,  though the app is pretty mature and feature-rich,  so there isn't much to do these days.  And I have some really exciting projects in the works,  so definitely stay tuned for them.  My plans for the future are a bit hazy.  I don't have any immediate plans to leave Google,  and I'll probably be here for at least a few more years,  but eventually I want to go off and do my own thing.  I hope that one day I'll have an idea  that I'm really excited about  and that I think could work well as a company,  and then I'll get a group of friends together  to make it a reality.  I'm confident that this will happen one day.  After sitting down to write this all out,  I realized just how much I've grown over the past 10 years  since I created this YouTube channel.  I've learned many languages and frameworks,  built many projects, big and small,  participated in a lot of events,  met incredible people, and grown so much as a person.  There are lots of projects and experiences  I didn't even get to mention  because this video is long enough as it is,  but I think you get the idea.  Before I end this video, I have a lot of people to thank.  First, my family, especially my parents and grandparents,  who have supported me throughout my entire life  and enabled me to reach this point.  I distinctly remember my grandparents on my dad's side  got me a copy of Multimedia Fusion 2  after I had used it at the summer camp.  My grandparents on my mom's side  got me a MacBook Pro in 2011 that I used for seven years  to build many of the projects I've discussed in this video.  Both sets of grandparents helped me enormously  in paying for college.  And of course, my parents always encouraged me  to pursue my interests by giving me access to technology,  signing me up for tech camps,  and being the first and only users  of the silly applications and games  I made in the early years.  I love you all so much.  Next, my friends who have supported me and enriched my life.  I keep in touch with friends from all stages of my life,  and many of the experiences I've reflected on in this video  were made more meaningful by the friends  who were there with me.  There are too many names to name individually,  but you all mean the world to me, and I love you all.  Next, all the people who I've worked with,  whether in a programming competition, a hackathon,  a project, a class, an internship, or my job.  I've learned so much and become a better programmer  and software engineer because of them.  I want to give special shout outs  to my high school computer science teacher, Tom,  who has continued to run CodeLM with me every year,  and my former manager at Google, Irfan,  who has helped me grow so much as an engineer  over the past almost two years.  And finally, everyone who has watched my videos  over the years.  I was inspired to make this video  because of all of the incredibly moving comments  that people have left on my videos over the years,  saying that they started programming because of my videos  and that they were now finding success.  I made this video partially to serve  as a sort of time capsule for myself,  but also so that I could try and impart some wisdom  that I've learned over the years.  I hope you found this video interesting,  enjoyable, and maybe even helpful.  Stay tuned to this channel  because although I don't post often,  you can expect some cool new videos in 2023.  Thank you so much for watching,  and I'll see you all in the next one.  Bye for now.  ♪ Hey ♪ 