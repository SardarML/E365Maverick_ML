 Hallo und herzlich willkommen zum Infovideo Skalieren und Deskalieren in der Analogwertverarbeitung.  Die absoluten Basics der Analogwertverarbeitung habe ich bereits im Video Grundlagen Analogwertverarbeitung erläutert.  Hier noch einmal das Wichtigste in der Zusammenfassung.  Wir benötigen eine analoge Eingabebaugruppe, die die Daten aufnimmt, eine CPU zur Verarbeitung und eine analoge Ausgabebaugruppe, um sie wieder auszugeben.  Damit sind wir beim klassischen EVA-Prinzip, Eingabe, Verarbeitung, Ausgabe.  Die analogen Daten werden zum Beispiel von einem Sensor geliefert.  Dabei könnte es sich zum Beispiel um einen Tachogenerator handeln.  Diese Sensoren liefern üblicherweise Werte zwischen 0 und plus 10 Volt, zwischen minus 10 und plus 10 Volt oder als Stromsensoren zwischen 0 bzw. 4 mA und 20 mA.  Dieser elektrische Wert wird von der analogen Eingabebaugruppe aufgenommen und kodiert, d.h. in ein 16-Bit-Datenwort überführt.  Dieses Datenwort liegt, sofern der Sensor nur Signale in seinem Nennbereich liefert, zwischen 0 und plus 27648 bzw. bei Sensoren, die auch negative Spannungen liefern können, bei minus 27648 bis plus 27648.  Wie bereits im Video Grundlagen Analogwertverarbeitung näher ausgeführt, gibt es noch Übersteuerungsbereiche, auf die möchte ich hier jedoch nicht näher eingehen.  Die CPU nimmt diesen 16-Bit-Dualwert nun auf und es kann vom Programmierer eine Skalierung, eine Verarbeitung und eine Deskalierung durchgeführt werden.  Ohne Verarbeitung macht natürlich die Messwerterfassung gar keinen Sinn, d.h. die wird immer ein fester Bestandteil der Analogwertverarbeitung sein.  Das Skalieren und Deskalieren erleichtert einfach dem Programmierer und gegebenenfalls auch dem Anwender, der z.B. über ein Operatorpanel die Werte handeln muss, die Verarbeitung.  Sollte im Laufe der Verarbeitung auch ein analoger Ausgabewert notwendig werden, so gibt die CPU über den Rückwandbus wieder eine 16-Bit-Dualzahl zwischen den genannten Werten an das analoge Ausgabemodul  und diese wandelt diese Dualzahl wiederum in ein elektrisches Signal um, das in den genannten Größen liegt, z.B. als analoge Ansteuerung für einen Frequenzumrichter, um eine Drehzahl einzustellen.  In diesem Video soll es jetzt vor allem darum gehen, wie die Skalierung und Deskalierung innerhalb der CPU erfolgt.  Ich erläutere das ganz gern anhand eines Zahlenstrahles.  Der Sensor erfasst ja eine physikalische Größe, z.B. Temperatur, Druck oder eben eine Drehzahl.  In unserem Beispiel zwischen 0 und 2800 Umdrehungen pro Minute.  Dies ist ein für dieses Beispiel willkürlich gewählter Zahlenwert.  Der Sensor wandelt diese physikalische Größe in ein elektrisches Signal um.  In meinem Beispiel sollen es von 0 bis plus 10 Volt sein.  Die analoge Eingabebaugruppe macht daraus den digitalen Nennwert, wie bereits erläutert liegt er zwischen 0 und 27648.  Da für die weitere Betrachtung in der CPU das elektrische Eingangssignal keine Rolle mehr spielt, möchte ich dieses an der Stelle etwas ausblenden.  Nun stellt sich die Frage, wenn beispielsweise in der CPU ein digitaler Nennwert von 21216 ankommt, welcher Drehzahl entspricht denn das?  Wollen wir die Drehzahl beispielsweise auf einem HMI, also einem Display darstellen, so interessiert ja der digitale Nennwert kein bisschen.  Ich brauche den Messwert in der physikalischen Größe, die eben erfasst wird und für den Benutzer relevant ist, in dem Fall Umdrehungen pro Minute.  Am Zahlenstrahl können wir das relativ einfach schon mal abschätzen.  Wir sagen, na gut, die Hälfte zwischen dem digitalen Nennwert 0 und 27648, das ist 13824 und das müsste natürlich 1400 Umdrehungen entsprechen.  Da unser Nennwert von 21216 davon noch relativ weit empfand ist, halbiere ich den rechten Teil einfach noch einmal.  Das heißt, wir liegen bei 20736, was einer Drehzahl von 2100 Umdrehungen Minuten entspräche.  Und jetzt sehen wir schon, der gewünschte Nennwert von 21216 liegt nur knapp oberhalb von 20736,  das heißt, wir müssten auf unserem Zahlenstrahl ungefähr hier eine Markierung anbringen und das würde dann einer Drehzahl entsprechen, die so circa zwischen 2150 und 2200 läge.  Natürlich kann man das über einen Dreisatz auch ganz einfach selbst bestimmen.  Die 10 Volt entsprechen ja den 2800 Umdrehungen pro Minute, das heißt, man rechnet das einfach runter und sieht, der exakte Wert wäre 2148,6 Umdrehungen pro Minute.  Diese Dreisatzrechnung müssten wir jetzt bei jeder Analogwertanwendung, wo wir eine Skalierung durchführen wollen, selbst durchführen.  Weil dies relativ häufig vorkommt, nimmt uns das TIA Portal diese Aufgabe ab.  In einem Projekt, das wir vorliegen haben, legen wir einfach mal einen neuen Baustein an.  Wir brauchen den vom Typ FC und nennen ihn Skalierung.  Nun holen wir aus der Liste der einfachen Anweisungen unter Umwandler und dem Unterordner Legacy den Baustein Scale hervor.  Er bietet vier Anschlüsse an den Eingängen, die zwingend belegt werden müssen.  Highlimb und Lowlimb sind meine physikalischen Grenzen, die ich messtechnisch erfassen kann.  Das heißt, bei mir waren das 0 Umdrehungen bis 2800 Umdrehungen.  Am Eingang IN muss ich den Kanal hinterlegen, wo das analoge Eingangssignal von der Signalbaugruppe eingelesen wurde.  In meinem Fall war das das Eingangswort 2, das ich bereits mit einem Namen versehen habe, nämlich digitaler Nennwert.  Der bipolar Eingang ist nun wichtig, um dem Baustein Scale mitzuteilen, wie groß der Eingangswert, der digitale Nennwert, überhaupt sein kann.  Ich hatte schon erwähnt, dass er von minus 27648 bis zum entsprechenden positiven Wert gehen kann, oder eben von 0 bis zum positiven Wert 27648.  Soll nur ein positiver Wert erwartet werden, so trage ich an dieser Stelle ein False ein.  An den Ausgang Return Value muss irgendeine Variable in Wortgröße angefügt werden, da hier ein Fehlercode ausgegeben werden kann.  Beispielsweise, wenn der IN-Eingang oberhalb von 27648 oder unterhalb von 0 liegt, sind wir im Über- bzw. Untersteuerungsbereich und dann wird an Return Value eine Zahl als Fehlercode ausgegeben.  OUT ist nun der Wert, den wir eigentlich haben wollen. In unserem Fall war das die Drehzahl, die wir berechnet haben.  Sie erinnern sich, wir hatten den Vorgabewert 21216 als digitalen Nennwert und haben uns gefragt, welcher Drehzahl dies entspricht.  Diese Drehzahl, die wird vom Baustein Scale am Ausgang OUT ausgegeben.  Ich möchte dies in einem Datenbaustein speichern und zwar unter der Variable physikalische Größe.  Natürlich muss dieses Skalierungsbaustein nun im Main OB1 noch aufgerufen werden und anschließend können wir das Ganze an die Simulations SPS übertragen.  Nachdem das Projekt an die Simulations SPS übertragen wurde, lege ich eine Force-Tabelle an.  Mit dieser Force-Tabelle kann ich den analogen Eingang simulieren.  Man sieht hier, ich habe diesen Eingang digitaler Nennwert, wo mein Analog-Signal ja eingelesen werden soll, bereits angelegt.  Beobachte ich nun den Skalierungsbaustein, so erkenne ich zunächst, dass beim digitalen Nennwert 0 natürlich am Ausgang OUT auch eine 0 ausgegeben wird.  Ist klar, der kleinste Eingangswert entspricht einer Drehzahl von 0 Umdrehungen.  Nun force ich meinen Eingang beispielsweise auf 10.000, d.h. ich gebe einen digitalen Nennwert von 10.000 vor.  Man erkennt, dass der Ausgang unmittelbar folgt und eine Drehzahl von rund 1.000 Umdrehungen ausgibt.  Gehe ich auf den Maximalwert 27.648 und schicke den in den Baustein.  So erkennt man, dass tatsächlich eine Drehzahl von 2.800 ausgegeben wird.  Nun zu unserem Beispiel. Wir hatten als digitalen Nennwert ja eine Größe von 21.216 vorgegeben.  Und wenn wir diesen übernehmen, so sehen wir, dass am Ausgang tatsächlich eine Drehzahl von 2.148,6, genau wie bei uns berechnet, ausgegeben wird.  Eine interessante Frage, die ich meinen Schülern immer stelle ist, was würde denn geschehen, wenn ich den Eingang bipolar aus Versehen falsch beschalte,  nämlich statt einem false ein true Signal vorgeben würde.  Auch dies können wir uns in der Simulation einmal durchspielen.  Wir haben wieder unseren Zahlenstrahl. Sie sehen am linken Rand, diesmal wurde der Bipolareingang mit true beschaltet.  Natürlich messen wir die gleiche physikalische Größe. Es hat sich am Motor und der zur Verfügung stehenden Drehzahl ja nichts verändert.  Das elektrische Eingangssignal bleibt auch gleich, spielt aber hier keine Rolle, weil wir uns ja schon in der CPU befinden.  Der zu erwartende digitale Nennwert kann aufgrund des mit true beschalteten Bipolareingangs nun aber zwischen minus 27.648 und plus 27.648 liegen.  Das heißt, wenn ich den Zahlenstrahl wieder in der Mitte halbiere, liege ich nun beim digitalen Nennwert 0 und man erkennt bereits, dies entspricht natürlich einer Drehzahl von 1.400 Umdrehungen pro Minute.  Teile ich den rechten Bereich jetzt nochmal in zwei Teile, lande ich beim digitalen Nennwert von rund 13.800, was einer Drehzahl von 2.100 entspräche.  Um zu dem vorgegebenen Nennwert von 21.216 zu kommen, muss ich den ganz rechten Bereich noch einmal halbieren.  Nun sieht man schon, dass unser Zahlenwert ja knapp neben der grünen gestrichelten Linie liegen müsste.  Das heißt, auch die Drehzahl muss sich natürlich rechts davon befinden und wäre damit so ungefähr bei 2.500 Umdrehungen pro Minute.  Schauen wir uns das Ganze nochmal im TIA Projekt an.  Ich beende einmal die Online-Verbindung und trage hier fehlerhafterweise den Wert true ein.  Nun muss ich den Baustein natürlich nochmal an die Simulations-SPS übertragen und anschließend wieder in den Beobachtungsmodus schalten.  Und Sie sehen bereits, am Eingang liegt immer noch unser vorgegebener Nennwert von 21.216 an und nun erscheint am Ausgang tatsächlich die falsche Drehzahl 2.474,3 Umdrehungen pro Minute.  Das heißt, die Wahl des richtigen Wertes am bipolar Eingang ist ungemein wichtig, weil der Scale-Baustein am Ausgang sonst immer Werte liefert, die aber eigentlich völligen Unsinn darstellen und damit eine nur schwer identifizierbare und handelbare Fehlerquelle darstellen.  Wenn wir in unserem Projekt gearbeitet haben und mit den Drehzahlen zum Beispiel etwas programmiert haben oder ein Benutzer über ein HMI eine Drehzahl vorgegeben hat, möchten wir diese ja auch wieder an einen Ausgang weitergeben.  Das heißt, wir müssen diese physikalische Größe, mit der wir im Projekt gehandelt haben, umsetzen in einen digitalen Nennwert, mit dem die analoge Ausgangsbaugruppe etwas anfangen kann.  Auch hier könnte man natürlich über eine Dreisatzrechnung das selbst umrechnen.  Einfacher geht es aber, wenn wir einfach den Unscale-Baustein verwenden.  Sie sehen bereits, er ist ganz ähnlich aufgebaut wie der Scale-Baustein.  In diesem Fall müssten wir natürlich die vorgegebene physikalische Größe, ich nehme jetzt der Einfachheit halber mal die gleiche, die ich bereits oben beim Ausgang habe, und schalte sie hier wieder auf den Baustein drauf.  Highlimb und Lowlimb entsprechen natürlich dem Wert, mit dem ich handhaben möchte.  Zum Beispiel, wenn der Benutzer eben eine Drehzahl wählen kann zwischen 0 und 2800 Umdrehungen, so werden hier die entsprechenden Werte einzutragen.  Und ich muss vorgeben, ob der Benutzer nur positive oder auch negative Werte aussuchen darf.  In unserem Fall sollen es natürlich nur positive Werte sein, denn die Drehzahl, wie sie an Low und Highlimb vorgegeben ist, legt dies natürlich nahe.  Als Return Value muss wieder irgendeine Wortvariable vorgegeben werden.  Da ich nicht vorhabe, diese Fehlercodes auszuwerten, kann ich hier die gleiche Adresse verwenden wie bereits beim Scale-Baustein.  Ja, und am Out-Ausgang muss ich natürlich einen Analog-Ausgang eintragen, wo der entsprechende Aktor angeschlossen ist.  Ich habe hier bereits eine symbolische Adresse angelegt, der bei mir beim QW4 hinterlegt ist.  Damit ist es mir eben möglich, mit dem Scale- und dem Unscale-Baustein sowohl digitale Nennwerte einzulesen, in Form einer physikalischen Größe im Programm zu arbeiten,  den Benutzer damit auch interagieren zu lassen und diese physikalische Größe für die Ausgabe wieder umzurechnen in einen digitalen Nennwert,  den die analoge Ausgabe-Baugruppe weiterverarbeiten kann.  Abschließend möchte ich nicht versäumen, Sie darauf hinzuweisen, dass diese Bausteine Scale und Unscale natürlich im Ordner Legacy untergebracht sind.  Daran erkennen Sie schon, dass Siemens diese Bausteine eigentlich für veraltet ansieht und die zukünftige Verwendung dieser beiden Bausteine nicht mehr empfiehlt.  In sämtlichen Altprojekten, besonders der 300er und 400er CPU-Familien, sind aber nur diese zwei Bausteine bisher zum Einsatz gekommen, weil es keinen Ersatz dafür gab.  Zukünftig sollen statt Scale und Unscale die Bausteine Scalex und Normex verwendet werden.  Diese präsentiere ich Ihnen aber in einem weiteren Infovideo.  Bis dahin! 