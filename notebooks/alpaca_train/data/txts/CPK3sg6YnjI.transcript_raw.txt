 The year is 1992, and Wiprosoft Windows 96 is in the dawn of its development, but suddenly  you are approached by Gilbate, the chairman of Wiprosoft at the time, and he requests  that you recreate the ever-popular Wiprosoft Paint, brand new from scratch, for the brand  new operating system.  Answer Gilbate's wishes, and begin creating this program, which will allow users to paint  little pictures for Wiprosoft Windows.  And so far it's going pretty great, you open a window and make it so you can left-click  to paint pictures, and right-click to erase.  But suddenly Gilbate's come sliding back, and he says to you, don't forget that paint  should also have the pencil tool, the eraser tool, the spray tool, the text tool, and the  one that lets you draw many different shapes in that.  That's quite a lot of stuff.  So you create a bunch of buttons for these tools, and immediately think about how you  can actually implement them all, given that right now, only the paint tool is supported.  Looking at what you've already done, which was create a function for the paintbrush tool,  you realise that you could just create a function for the other tools as well.  But first of all, you create an enum for the tooltypes, containing a constant for each  one that you wish to implement.  And then using the buttons from the toolbar from earlier, you make it so that when you  click one of the buttons, it switches to a tooltype, depending on which button you clicked.  And then inside of the if statement, which checks if the left mouse button is being pressed,  we can have a switch statement for the different tooltypes.  And it's from here where the different tooltype functions will be called from.  Now all that was left to do was implement the rest of the tooltypes, such as the paintbrush,  which was already made, the pencil tool, the spray tool, and the fill tool, all of which  are getting called from the same giant switch statement, which is starting to look a little  bit messy by this point, and maybe even a little bit unmaintainable.  But despite all this, you go to the test set, you run the program, and you see it's all  working perfectly fine, so you know, the bad code's not so much of a big deal, right?  Yeah, no, this is pretty bad actually, let's take a close look at the code so we can really  understand why this is, and then why the strategy design pattern can save the code.  So first of all, this is the code that checks if a button is clicked, and then changes the  tool that the user is using.  While this code isn't that bad, it is quite repeated, and so there's probably a better  way to do this.  The switch statement here calls the different functions for the different tooltypes, depending  on which one the user is currently using.  For now there's only 5 cases, but what if we added a lot more tools, then this would  just become ridiculously long and unmaintainable.  We then have the square tool and the line tool, and these require knowing where the  left mouse button was first clicked on the canvas, and then where the left mouse button  was then released on the canvas.  Furthermore, they both require you to sort of draw a preview of the line or square before  they're actually drawn onto the canvas.  As of this, the implementation of these tools is sort of split between two places, the first  place being where the functions for these different tooltypes is actually called from,  and the second place being where the preview of the line and the square is actually drawn.  And this is bad, because it means if you want to find the implementation of these tooltypes,  then it means you have to go to two completely different locations in the code.  The final main reason why this code is not so good is because it's basically just one  giant multi-level nested switch statement, which eventually will just become to be very  unreadable.  But now for the question, what exactly is the strategy design pattern, and how can it  improve this code?  The basic idea is it just allows you to select an algorithm during the runtime of a program  that fit the needs of whatever's going on with the current time.  How this works is you have some base class or interface known as a strategy, which is  then used by some other part of the program.  And then classes will implement the strategy interface, of which is able to be used by  the main program, as well as switch between during runtime.  For example, at the start of the program they might be using strategy 1, and then they  might use strategy 2, strategy 3, and then they might go back to strategy 1 a bit later.  In terms of the paint program, the strategy would be any tooltype, and this would be used  by the main program like in the previous example.  And then the different implementations of the strategy would be the different tooltypes  like the paint tool, the fill tool, or the spray tool.  These different strategies would be switched between as the user clicks on the different  tool buttons on the toolbar.  For instance, clicking on the paintbrush button would switch the program to begin using  the paintbrush strategy, or clicking on the spray can button would switch the program  to begin using the spray can.  So now that the strategy pattern is hopefully understood, let's actually begin implementing  it in the code.  To begin with the implementation, I created a tooltype strategy base class which would  act as an interface for the different tooltypes.  These were pure virtual functions for handling the different mouse events such as clicking  or moving, as well as a function for rendering a preview as needed, for example the line  and square tools.  To follow up, I created a bunch of classes for the different tooltypes where each one  would implement the functions of the interface.  I then wrote the file for each tooltype, and then moved the implementation of each one  from the main file into their respective strategy class implementation.  After each tooltype was neatly organised into their own file, it meant I could begin cleaning  up the main file, starting by getting rid of the tooltype functions as these had now  been moved.  However, in order to actually use the new tooltype implementations, I first have to  create an object of type tooltype strategy, which is the interface that they all implement.  And it's from this object that I will be able to call the different functions from such  as handling the mouse being moved, or the mouse being clicked.  And by default it's just going to be using the paintbrush strategy.  And then to change the strategy, clicking on the buttons in the toolbar no longer changes  an enum, but rather changes the strategy class the current tool object currently is.  So now that I have this strategy class object, it means that code that previously looked  like this can now be shortened to code that looks like this, where the function called  to handleMouseMove would use whatever strategy the object currently is using, thanks to polymorphism.  And the code that was previously for rendering the preview of the line and square tool that  used to look like this, now looks like this instead, which is a lot shorter and a lot  more readable.  And when you go to actually run the program, test it out, you'll notice that it's just  exactly the same as it was before.  And that's because the logic of the code hasn't really changed, it's just been better organised.  So anyways, that is the strategy design pattern, and I hope you enjoyed the video!  Quick shoutout to my Patreon supporters, thank you Killo Crazyman, Hayden, Timothy Gibbons,  Timo Schrader, Alan Fernandez, Michael Kirsch, Lucas Starenberger, Neil Blakely Milner, and  Nate Brown.  Thank you all very much for the support.  Anyway, again, thank you for watching, link to the source code and other links are in  the description below, and goodbye! 