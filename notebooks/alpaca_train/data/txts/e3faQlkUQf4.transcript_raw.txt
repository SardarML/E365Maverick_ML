 And we are live, hello and welcome everybody to the state of React ecosystem.  So excited to have some of our amazing panelists here today and some amazing updates.  We're going to have some really awesome conversations about React, and I'm going to go ahead and  share my slides really quickly.  Oh, it's funny.  Hello.  Okay.  There we go.  I'm looking at my slides on the screen, but like not my actual slides.  I'm confused.  All right.  So state of React ecosystem.  I'm going to be talking about some amazing things.  I want to thank my team over at the thought labs.  We're about a 50% consultancy.  It's pretty exciting.  But, you know, if my team wasn't enabling me to do all the things I love, which is basically  everything related to community, definitely would not be able to do all the great things  we're able to do for the community.  We have a lot of amazing clients.  So that's always exciting.  Everybody's looking for new and interesting work.  So if you're hiring, let us know.  Also we have an amazing team that's growing, so if you want to come hang out, email me.  That's how I make friends.  I do still do all the screenings.  We just released a really cool open source project that you can not only contribute to,  but also something that we wanted to release to help people figure out what technologies  to use.  Because I think everybody's experienced the paralysis of figuring out what on earth to  use, what libraries to compare, et cetera, et cetera.  So reactangularinview.framework.dev.  You can check them out.  Submit a PR if you hate it, issues.  And then, Tom, I don't know if you monitor this, but, you know, yell at Tom.  Just kidding.  I'll probably review your PRs if you contribute.  So go ahead and contribute.  Yes.  We have a lot of really interesting events coming on.  So next week is JavaScript Marathon, where Michael will actually also be presenting.  Kent has presented in the past before as well, where, you know, it's basically a week of  free training.  So check that out.  Starts July 18th.  State of Hello CMS is coming up as well.  State of Vue is happening.  And then we have State of Web Components happening as well.  Woman in Tech Monthly Mentoring.  That's just my favorite.  We had it yesterday as well.  Just like coming and hanging out with a bunch of women for like an hour and talking.  Doesn't matter what level you are.  But, you know, just hanging out.  Hanging out privately in a little Zoom.  State of Web Performance as well happens August 23rd.  So yeah.  Check those things out.  I'm excited about those.  My name's Tracy.  You can follow me on Twitter at Lady Leet.  I'm the CEO of the Sutt Labs.  And then Tom is my co-host.  Hi, Tom.  Hello.  Happy to be here.  And Tom is the master of amazing shirts.  So whenever you see Tom, if you see a person in a Hawaiian shirt, like, it's like, is that  that Tom guy?  Like, it is.  I need to update my little avatar there where I'm in a suit.  Because I'm never in a suit.  It's always Hawaiian shirts.  It's true.  I was about to say, that picture feels very misleading.  I made that illustration before I was in tech, when I had to actually dress a certain way  in an office.  Never again.  That's so funny.  Yeah.  So reason to join tech.  You can wear whatever you want.  I feel that.  Amazing panelists here today.  I'm going to go ahead and just have everybody do a quick, like, 10-second intro.  And then we'll move on to, like, you know, kind of a roundabout of updates.  But Shruti, do you want to go ahead and introduce yourself?  Sure.  Hey, everybody.  My name is Shruti Kapoor.  I am a software engineer at Slack.  And my title is a lead member of technical staff.  So instead of going with that title, I just say software engineer.  Hi, everyone.  Nice to be here.  Excited to talk about React.  You can follow me on Twitter at ShrutiKapoor08.  Thank you.  Hi.  I'm Mark Erickson.  I'm a senior frontend engineer at Replay, where we're building a time-traveling debugger  for JavaScript.  And also I do a few things related to Redux.  Hi.  I am Paige Niedringhaus.  I'm a staff software engineer for an IoT startup called Blues Wireless.  And I am also a co-host of the React Roundup podcast and the author of modernizing enterprise  React apps for Newline.  Hello.  I'm Kent C. Dodds.  And I have a cut on my chin.  So that's what the bandaid is all about.  I'm the co-founder and director of developer experience at Remix.  I created testing JavaScript.com and Epic React.dev.  And I really like JavaScript, React, and Remix.  Hi.  My name is Dominik.  You can find me online as tkdodo almost everywhere.  I work as a frontend tech lead at Adverity, but I guess I'm here because I maintain the  popular open source library React Query, as you can see on my T-shirt.  Hello.  Hello, everyone.  My name is Michael Leando.  I'm a developer advocate over at AWS, specifically on the Amplify team.  You can find me online at MTLeando.  And I typically rant about all things AppSync, GraphQL, frontend, et cetera.  Pretty much putting your frontend application on the cloud.  Cool.  I love it.  Well, thanks so much all for being here again.  And let's go ahead and move on to...  Well, thank you for joining.  Let's go ahead and move on to quick updates.  I'm just going to go like this and say, Dom, do you want to go first?  Give us an update on TanStack.  Yes, definitely.  So I'm very sad that Tanner can't be here today to talk about all the amazing things  that he's done to the TanStack and the various libraries that are in it.  But what I can share with you, if I can share my screen, I hope that works.  Oops.  Okay.  Let's share this one here.  So what we've been working on, and also I've been working on a lot lately,  is the new version of React Query version 4.  For the last, let's say, half year, a bit longer than that,  this has been in the makings.  And as you can see, this is a blog post that's not yet live.  So this is a preview.  It has been renamed to TanStack Query.  Like all the other libraries that Tanner has created, or most of the libraries,  we have TanStack Table now, there's TanStack Virtual,  and there will also be TanStack Query as the next major version.  And first of all, I also want to apologize to people if they try to access  the old docs, because if you go to the old docs,  we have already redirected them to the new docs,  which has caused a bit of confusion because you can't actually install  it the way as it's been described here,  because we're still actively working on that.  Got a bit of a delay because vacations,  I've been on vacation for the last two weeks,  Tanner is on vacation right now,  so we're just trying to find the time to sync up  and then actually roll out the release.  It's going to happen very, very soon.  I know I've said that in the past before, but last minute, we said,  okay, let's add React 18 support.  And then it took some time.  And again, last minute, we also said,  let's make it the agnostic one with the TanStack Query.  We don't want to do this a bit later, but feature-wise,  it's actually been complete for quite some time.  And what we have as new features is a new way to support offline mode.  So that means React Query or TanStack Query doesn't have any implications  or assumptions about the network anymore.  So you can really, it has evolved to an aging state manager.  You can use it to produce a promise however you want.  It doesn't have to be over the wire,  and it will also work if you're offline.  If you don't have a network connection,  it will give you a new paused state that you can then check  and provide a better UX for your users.  The other thing are the stable persisters.  They have been experimental for quite some time.  It's a way to take the query cache and persist it somewhere else.  For example, local storage, or if you're using React Native,  you can use aging storage to give an even faster startup time  by reading if the user has already loaded it there.  We're providing two persisters, a sync storage persister  and an aging storage persister,  but you can also write your own on top of it.  As I already said, we have put support for React 18 in there.  Version 3 just has a support  in a way that it doesn't break with peer dependencies,  but it doesn't really have support  for the new concurrent features of React 18.  We've done that in version 4 by using the using external store hook.  And we have some smaller changes to the APIs  that we try to streamline  because they have accumulated over time with lots of flags.  We try to make that better  and also try to choose better default values  that we think will make the user experience  and developer experience even better.  So yeah, I can't say come check it out right now  because it's not there yet,  but you can check out the beta version if you want of React Query  and then very soon we will launch  the 10-stack branded version of it.  And then obviously, like the other libraries,  we can go agnostic.  So there will be adapters for Vue, Svelte, and likely Solid.  For Vue and Svelte, I know they already exist  as community packages,  and we're going to integrate them into the 10-stack,  into the monorepo.  Yeah, that's all I have.  Thank you. I appreciate it.  Who wants to go next?  I can go next.  Yay.  Yeah, so I don't have any sort of presentation  or anything to share my screen,  but I can say that over here at Remix,  we've been working on a couple of really cool things.  So for one, we had our conference this last May,  and we haven't officially announced this yet,  so this is the first place you're hearing this,  but we are going to be holding RemixConf.  Well, okay, so we did announce  that we're holding RemixConf 2023.  We announced that at the conference.  But as far as like when, we just said sometime in May.  So now you know, I can tell you that RemixConf  is going to be the week of May 7th,  and it's going to be a two-day conference,  one day of workshop.  And so, yeah, block out the week of May 7th  on your calendar to come to RemixConf 2023.  It's going to be bigger, badder, better.  Not badder, it'll be better.  Bigger and better and awesomer than ever.  And then as far as the technology itself,  Remix is very soon going to have,  or we're going to finish the work  on remixing React Router,  so we're bringing a lot of features from Remix  into React Router.  We could also call that unreacting React Router,  because like the TAN stack,  we are taking all of the cool things  from Remix and React Router  and framework agnosticizing it.  And so you will relatively soon  be able to use Remix  with whatever UI library that you want.  We will build official support for Vue and Preact,  and then you could build your own thing  for a solid and a svelte  or whatever else you want to.  So that is exciting work.  And we're also working on the streaming APIs.  So you can currently use React 18 streaming with Remix.  Remix didn't need to change anything  for you to be able to do that.  When React 18 came out,  but we are taking advantage of the streaming APIs  with our deferred API.  And we actually just shipped yesterday  one of the pre-release of React Router  with the deferred API built into the router,  because the new version of React Router  is also a data management library as well.  And so, yeah, we built,  added the deferred API to that,  and then we're going to very soon  ship the deferred API to Remix  so you can stream from the backend.  And it's amazing, but I've been talking too long,  so I'm not going to talk any more about that.  So look forward to that.  It's going to be really cool.  We've got a couple other really cool things coming  and we're experimenting with.  And yeah, we can talk about that more later.  Cool.  Do you guys publish your roadmap  or stuff anywhere?  Yeah, so all of our discussions,  with the community,  happen on the GitHub discussions on our repo.  We don't really have a public roadmap per se,  and maybe eventually we'll put one together.  But yeah, we just haven't done that.  Too stressful anyway.  Yeah.  We talk a lot.  One unique thing about Remix  is we have our early supporters,  the people who paid when Remix was a paid thing.  There are like 500 people there.  And so we talk a lot with them  to kind of flesh out ideas  before we bring it out into the open.  That way we don't have situations  where we make this announcement of this idea  and then everybody comes up in arms  and it's like, well, it was just an idea.  Like, chill, it's fine.  We're not going to do it, I guess.  Is it a Remix working group?  Yeah, it's kind of like a Remix working group.  Yeah.  I love it.  Cool.  Who wants to go next?  Sure.  Let's see.  So things are sort of quiet over in Redux land right now.  We shipped React Redux version 8 a few months ago.  And actually, that's been very quiet,  which is a wonderful thing.  We've had basically no meaningful bug reports.  I actually just upgraded my work app  to that a couple weeks ago.  I think there were a couple of very,  very minor TypeScript issues.  But given that we kind of swapped the guts of it,  we migrated it to TypeScript and everything else,  the fact that there's no news is really good news.  Congratulations.  Congratulations.  For those of you who don't know,  when I was talking to Mark, it was a 2019 PR, right?  No, that would be Redux version 5,  which I'll talk to in a second.  We did the TypeScript migration last summer.  Actually, the community contributed a lot of that.  And then I worked with Andrew Clark  on fleshing out the new use sync external store hook.  And React Redux version 8  was really the testing ground for that.  So exciting.  We also shipped RTK 1.8 a few months ago,  which has the new listener middleware,  which is intended to be a simpler alternative  for side effects instead of sagas and observables.  And frankly, that's gotten a better reception  than I would have actually expected.  A bunch of folks have said they're using it  and they love it.  Things we have coming down the road.  So we are slowly working on an RTK 1.9.  That's going to be mostly some new options  and tweaks for RTK query.  We're hoping to give the ability to customize  how you generate cache keys and serialize them  and the ability to potentially merge data  into incoming cache entries.  Right now, like if you try to pass in,  I don't know, like a session ID or something,  you probably don't want that as part of your cache key.  So the idea was you would have the ability  to strip that out.  And then right now requests always replace existing data.  And depending on the use case,  you might want to merge into an existing cache entry  when you refetch.  A couple of small TS improvements.  We're going to add a deprecation warning  for the object syntax for the extra reducers option  in create slice.  That just really doesn't work well with TypeScript.  It was a great feature when we first shipped the library,  but we really want to encourage people  to use the builder syntax instead  because it works much better with TypeScript.  While they're not necessarily slated for 1.9,  there's a couple open proof of concept PRs  to have suspense support for RTK query  and the ability to have like multiple queries  being suspended at once.  No strict ETA on this.  We're working on this very slowly,  maybe in the next couple months, hopefully.  And then once we do ship that,  we hope to turn around and work on RTK2,  which would have really no new meaningful features,  but instead be a cleanup  and breaking changes kind of a thing,  dropping support for IE11,  rethinking some of our build output file formats  using the export field in package JSON  for ESM compatibility,  dropping the emmer ES5 compat shim,  and then getting to what Tracy said.  If you look at the Redux repo,  we converted it to TypeScript in 2019  and never shipped it.  So eventually that needs to be Redux version five,  and it would make sense to ship a Redux five  that is built in TypeScript  together with RTK 2.0 at the same time.  Hopefully that won't break things too badly,  and we'll find out when we get there.  I'm calling all TypeScript experts.  Go talk to Mark on Twitter.  He could use some help.  Cool. Thank you, Mark. Appreciate it.  Who wants to go next?  I can go.  Sure.  Let me see if I can share my screen.  Maybe.  Possibly.  Maybe not. I'm getting that,  hey, we need permission to share.  That's okay.  We're going to bypass that.  A couple of things on the AWS Amplify side.  So for those of you that are unaware,  AWS Amplify is a way for front-end developers  to get up to speed on AWS.  I think there's no shortage of folks  with the understanding that AWS has traditionally  been super hard for a front-end developer to access  just because of the sheer amount of services that we offer,  back-end tailored infrastructure and other tooling,  but AWS Amplify is kind of here to solve that.  So two new features that we have going on.  The first one is going to be Amplify Studio,  is our graphical user interface  that folks can use to drag and drop their applications  if you use Netlify, Vercel, et cetera, to host your apps.  Very similar in that regard.  The one added benefit, though,  is that you can now design your files in Figma,  take that link that you would typically share  with your other designer friends,  and instead paste that into Amplify,  and we will generate all of the React components for you.  So it's a pixel-perfect one-to-one,  and it stays in sync in the sense that  if your designer were to modify the colors  and the spacing, et cetera, they press sync,  and then the developer can pull those down,  and it's all managed via Amplify Studio.  Pretty cool.  The thing that I think folks really like about that  is the components.  They're modifiable.  They're human-readable.  It's not that sort of long syntax of code  that gets minified and unable to be read,  but we take it a step further,  and we also now have a GA support  for our UI components themselves.  So how we scaffold out those components  ends up getting bundled up and created  inside of a UI library,  and folks can now install that inside of their application.  So if you don't use Figma, all good.  Amplify also has its own Chakra UI,  theme UI-style library  that you can check out over at our docs.  It's great, and it's sort of easy to use  if you're coming from those other realms  of front-end development.  So that's what we got on the front-end side.  I'll pass it off.  That's really exciting.  I'm so glad that I've been seeing  a lot of really great hires  and people focused on AWS education  and documentation for front-end developers  because I feel like most of us have been  screaming for it for a few years now.  So very excited about that.  PagerFace is like, yes, yes.  Yeah, it's such...  AWS is one of the first platforms  that I really got started with,  but it's such an intimidating one  because there are so many potential pitfalls  and bells and whistles to uncover  that any documentation and people  who are helping to spread that knowledge  is, you know, thumbs up in my book all around.  It's like sighs of relief.  Every time I see somebody like joining AWS  to help on developer education,  I'm like, this is the best thing ever.  Thank you.  So no, we're excited, Michael, obviously.  Paige, since you're unmuted,  do you have any updates for us?  Sure.  So for anybody who isn't familiar,  last fall, I wrote and released a course  with a company called NewLine  that is all about modernizing  enterprise React applications  because they're big,  they're long-lived usually,  and they might not be following  all the best practices  that include things like unit testing,  end-to-end testing,  using design libraries,  going from components that are stateful  to functional components and using hooks.  So since the new hooks  and React 18 has come out,  I have not done any updates  that are available for users yet,  but it is something  that I'm definitely working on,  potentially some new modules  and some updates to the existing course.  So just stay tuned  because there will be things coming  in the future for that.  That's definitely exciting.  I feel like we actually just did a podcast  on Modern Web.  For those of you who listen  to Modern Web Podcast,  it will be coming soon with Jay Phelps.  And we were talking about, you know,  the new React, the modern React.  It's funny that we call it modern,  whereas like, you know, five years ago,  it was like, oh, look, it's the modern web.  So it's just been really interesting  from a React perspective  to kind of try and like figure out  what the new best practices are  and how to do it the right way now  with all these new features and everything.  Speaking of which,  Shruti was very involved in that  with the React 18 Working Group.  Shruti, do you have any quick updates for us?  Sure.  Hey, everyone.  So for React 18 Working Group,  those of you who don't know,  React team spun up a working group,  which is a group of people  from the community, educators, library builders,  who got together to understand  the new updates of React  and help other people in the community  kind of also understand it.  While React 18 was in alpha stage and beta stage,  we were going through  what the updates are going to be,  posting questions.  There were some really cool threads  that came out of those discussions.  All of those discussions are available on GitHub.  If you just Google React 18 Working Group,  you'll find them out.  Right now, we're kind of in a sleeping mode.  React 18 has been released,  and so the working group is now just chilling.  That's great.  Chilling is good.  Chilling is good.  You know, go help Mark on the TypeScript.  Cool. Awesome.  Well, I wanted to go ahead  and pass it off to my co-host, Tom,  who will be starting the panel discussions.  Thank you, folks on YouTube  who have been putting in a few different questions.  We'll get to them shortly,  but, Tom, I wanted to let you kick it off.  Thanks, Tracy.  So, the first question I have,  I think it really overlaps well  with one that CBEE in chat asked.  So, what has you really excited?  What are you really loving  in the React ecosystem right now?  What's, you know, other than your old things,  which you've given excellent updates on, of course.  And I'd also ask, on the flip side,  what's kind of driving you nuts?  The things that are like,  I can't believe it's been this many years in React,  and we still haven't figured out a thing.  So.  Yeah.  Yeah.  We still have to figure it out.  Thing.  So.  Open it up to all of you.  Silent.  No one's excited.  No one's dreaming.  Okay, I will go first.  I just, I'm a little troubled.  Like, other than your own library,  it's like literally all I'm doing ever is using this.  So, but I can say that suspense  for data fetching and streaming in React 18  has been really awesome.  You put together a nice API with Remix,  and it makes it easy to use,  but just the concept itself  has proven to be really, really helpful.  In particular, what Remix gives you  is just this really nice API to use it,  and what it allows you to do  is to easily switch between the trade-offs  of time to first byte and content layout shift.  So if you have a really great time to first byte,  but you have like a slow backend or something,  then you're gonna be showing loading spinners, right?  And then you have content layout shift  when that finally comes in.  But if you focus on, you know,  let's get rid of the content layout shift,  then it could be a slow time to first byte  because that's slow backend.  Now, of course, the solution is  make that backend not slow.  And then you can have good on both of these things.  But if for some reason you can't do that  or it's like computationally expensive, whatever,  then what suspense for data fetching and streaming  allow you to do is get the best of both worlds,  or at least like move this lever on those trade-offs  to find the thing that's the best.  And in particular, what streaming allows you to do  is normally if you're just doing client-side stuff,  you have to get all the JavaScript on the page  and everything running and hydrated  before you trigger the requests for the data.  And so you get this waterfall.  But with streaming, you actually trigger the request  to get the data from the server.  And so as soon as the user requests the document  or starts the transition to the next page,  we instantly can start going to get that data.  And we're squishing things over to the left  in the network temp.  And so not only does it give you a better control  over that time to first byte versus content layout shift,  but it also speeds up the entire process of loading that data.  So that is one thing that I am particularly loving  at the moment from React.  I finally have had a chance  to actually at least get my feet wet with suspense  within the last few weeks.  So the app that I work on, Replay,  is like the polar opposite of the kind of the app  that Kent just described.  Our app is basically the Firefox DevTools  as an app in the browser.  So it's a very long-lived single-page application.  But we do a lot of data fetching from the backend  over the course of the app.  And one of my teammates is Brian Vaughn,  who used to be on the React core team  and did a lot of work with the React DevTools.  And over the last couple months,  we've been doing a lot of work to try to figure out  how to throw away a lot of our legacy code  and rebuild it because it's a pain to work with.  And Brian and I have both been going off  and doing some prototyping work.  And Brian is used to working with suspense  and this idea of a suspense cache  for managing data fetching.  And so he started building some prototype,  like miniature versions of pieces of our app  and writing these suspense caches  for managing the data fetching.  If you've seen any of the previous React team demos  of this idea, the idea is that in your component,  you just say like const data equals mySuspenseCache.read  or some similar-looking function call.  And if the data isn't there,  magic happens that I'm going to skip over.  Eventually, React re-renders your component  when the data is there,  and now it looks to your component  like that data always existed.  And in the meantime,  it floats up to the nearest suspense boundary  and you can show a loading spinner or whatever.  So it's been interesting for me watching Brian  try to write some of these suspense caches  because the concept isn't really documented at all yet.  And so a couple weeks ago,  I actually went through and tried to write a suspense cache  that was backed by RTK query  for doing the actual data fetching  and then wrapping a suspense cache around it  for use in a React component.  I actually got it working.  Like I'd always thought it was possible,  but I didn't have proof until I tried.  So I'm still just sort of trying to learn  how this stuff works myself,  but I can definitely see a lot of the potential  involved in it.  I think I should mention that even inside of Remix,  it's not just about that initial page load,  but also about transitions between different routes  on a long-lived app.  So it is exciting just in general, for sure.  I can go next.  I think something that I'm really loving at the moment,  it's not one particular library.  It's this acceptance of, hey, CSS is tricky,  but I'm noticing that there's this larger movement  towards putting out amazing articles  on how to get started with raw CSS.  Libraries have integrations  on how do you put in Tailwind or Chakra or Amplify.  Sorry, I shouldn't have plugged my own stuff there.  And all of this stuff into your applications.  And I love seeing it  because front-end developers were always sort of,  yeah, I work on the front end.  I just don't make it look pretty.  And now it's like, no, no, no.  This is actually a part of our job.  And we have this huge community  that has already been here forever  of people developing great CSS content  that we can now take advantage of.  That part is what I love.  I love seeing it.  I love working with all the different UI libraries  that are out here.  And then on the other side of things,  to answer the question of what is driving me crazy,  it's the whole single page versus multi-page.  I thought multi-page was just what we called things  in the before anyways.  And I keep thinking,  these PHP devs just have to be laughing at us  because one day we're gonna figure it out  and they're gonna be like,  yeah, that was 20 years ago that we had that.  So getting on that page where, no pun intended,  of everybody just saying,  yeah, this is the way  that we are going to make our applications.  I don't care which one it is personally.  I really don't.  And I think our customers don't either.  So once we get to that level of,  okay, this is what it is.  And then we're just going to roll with that  is a day that I'm honestly  and earnestly looking forward to.  Dude, you gotta try Remix.  I've tried Remix and Remix is great,  but it's one of the many options out there.  And sometimes you get into another set of problems.  Everyone's like, I found the perfect solution  and no shame on Remix.  Again, I love it.  But then there's another library  that also does similar things.  And so I'm still trying to like,  well, then which is the library?  Oh my gosh.  But like, which is the library?  React, Angular, Vue, Solid, Svelte?  And then you pick one and you're like,  all right, that's great.  But what is the framework now?  So it's like.  So funny.  Well, I mean, like I said,  we're going to support any of those UI libraries  in the near future.  So the framework is Remix,  the UI library is whatever.  Oh my gosh.  You're going to hear folks,  debate is over, debate is over.  You're giving me these softballs.  Sorry, I got to relay.  But Kent, you also have to be able to support  the non-JS frameworks.  You need to be able to support Hugo.  You need to be able to support Jekyll.  You need to be able to support some of these other ones  that are still there, Eleventy.  Yeah, you know,  actually I'm more interested in supporting use cases  than technologies.  And so I think that as neat as it is  that Remix will support these other frameworks,  it's more like just happening naturally.  And it was never really a huge priority for us,  except that we did hire somebody  who really liked Vue a lot.  And so he pushed us to do this,  but I mean, like, we're glad that we're doing it,  but yeah, I'm much more interested in like,  let's think about the use cases  and a lot of the preexisting solutions  aren't really necessary anymore  because the problem doesn't exist  when you're using the Remix.  Not to call out any particular solution,  but yeah, a lot of problems are just eliminated.  And so when somebody comes to you and says,  well, you know, they've been riding a horse  and you're showing them a car  and they start asking you like,  where's the pooper scooper?  It's like, that problem doesn't exist with this thing.  We've got other problems,  but that problem doesn't exist with this one.  That's a great analogy.  Okay, so what I wanted to say  that kind of relates a bit to this  is a library that I've been,  well, not really using yet,  but I have heard really great things about it.  And yesterday there was a stream from Theo  with the creator, Alex,  and that library is trpc.  In case you haven't heard of it,  it's a library that basically allows you  to write a function on the backend  and then call it on the front end  to give you the data that this function returns.  And all of this gives you end-to-end type safety  without having to write any schemas  or any code generations,  compilation step in between.  The demos that I've seen,  they were really stunning.  And from version 10 that they're going to release  really soon,  they're also going agnostic,  which is also a big move at the moment, I think,  which I also love.  Obviously the 10 stack is doing it,  Remix is doing it,  and TRPC is doing it as well.  So that's something that I'm really looking forward  to trying out and also encouraging everyone else  to try out.  Yes, the React layer is made with React Query,  and that might be why I also like it,  but it's generally a really, really good tool to have.  Yeah, that front or back-to-front type safety is nuts.  And we just added some very similar type of functionality  of type inference across the network layer  to Remix that'll be released next week.  And it is like when you add Prisma to this,  where Prisma gets you type safety from the database,  and then you can go all the way to the front end with that.  This is the stuff that have people salivating over GraphQL  and Apollo and all that stuff.  And now we can have that with a little less complexity,  I think, which is pretty exciting.  I think that's really the key,  is that all of the complexity that used to have to be part  of setting up any project or maintaining projects  is really going away.  You don't have to manage your own Webpack configs anymore.  You don't have to necessarily worry about your TS configs  or your TS lints.  All of that stuff that makes it so hard  and makes it take longer to get to the actual building  of the application that you want to make  is being taken care of for us.  That's probably one of the most exciting things  about all the stuff that's coming out now  is that it works really quickly right out of the box,  and you don't have to do a whole lot of setup  or know all about the intricacies of everything  to get it to that point.  And also that actually...  Oh, sorry.  Go ahead, Ken.  I was just going to say now we have ES build  and it's like crazy fast.  We don't have to use Webpack anymore.  That actually reminds me  that one of the things that I'm loving at the moment  is actually no library at all,  but it's actually the development environment  that we have at Slack.  So this is my first month at Slack,  so I'm still starting to understand how it's working.  But one of the things that I love is  in order to run your development environment  or get anything set up,  there's literally just one line of code you write  in your terminal,  and it starts your VS code.  It pulls down everything.  It sets up a dev environment,  and it opens up your VS code  with all of the settings that you need.  So as soon as you start typing code,  your remote dev environment is updated,  and it's so fast.  You feel like you're working on local,  but it's actually on the dev environment.  And the coolest thing I found yesterday was  if somebody else,  like if your coworker wants to work with you,  they can connect to your environment,  and you can see their changes in real time  in your code environment  without having to do any kind of Git pull or anything.  It's amazing.  Wow, I want that at my work.  I know.  It's so cool.  That's awesome.  Well, yeah, so many exciting things happening.  Tom, I'll let you keep going on with the panel questions.  Sure.  Let's see.  What would be a good...  Well, we talked a little bit about this,  but I'd like to get maybe a broader view of it.  We all complained a bit about having Webpack configs to set up  and figuring out those sorts of build steps.  I remember getting started years ago.  I could not learn React until after Create React came out  because every time I tried,  I would try to set up a Webpack config  from some blog post somewhere,  and it never worked, ever.  So I was very grateful when they came out with that.  But we're also starting to see more tools,  aside from Webpack ES build.  We've got Vite.  We've got all of these other things.  And in the same way,  I think we're starting to see some decoupling,  like with PanStack, like with Remix,  where things are not hooked just into React.  Are we also going to be seeing more of a decoupling  from some of these tools,  where not only does it not matter  whether you're using Webpack or Vite or whatever,  but you don't even need to know?  How do all of you see this unfolding?  To me, that seems like the...  I think that's the way that it's going to go, honestly.  Because like I was saying earlier,  I don't think that there's a whole lot of developers  who really enjoy that part of the process.  So the less that I have to do on my own  the more that I can just depend on another...  a framework, a library, somebody else  to make most of those decisions for me  so that I can actually get to the point of writing code  and seeing things on the screen.  That is totally fine with me.  And I know that there's a lot of cases  where you won't be able to use what's right out of the box.  But I think for the vast majority of developers  and the vast majority of use cases,  that will be something that is possible.  So I'm happy with that kind of magic.  Let me get to building cool components  and writing new pages and doing fun stuff in the browser.  And I'll let somebody else deal with the underlying things  that make it work and make it magic.  But I don't need to know exactly how they're doing it.  Yeah, I 100% agree with Paige.  I was talking about it a little bit earlier  with these UI libraries coming together  to expand on that a little bit.  At AWS, we call it undifferentiated heavy lifting,  which is all of the hard stuff that doesn't matter.  So as long as you can push it off to a framework,  a library, a tooling, a really cool dev environment  like Shruti has set up,  then it makes your life that much easier  and it just accelerates what it is  that you're actually trying to build.  I think back in the day, we spent so much time  trying to get React even set up  that it took away from our experience  of what we were trying to build in the first place.  So I love seeing all the consolidation  in the ecosystem these days,  and it's only going to get better.  So maybe a tangential question,  but maybe a little bit related from chat.  Thoughts on Bunn,  the new runtime package manager, Swiss Army Knife.  Seems like it's blowing a lot of people's minds,  Kents included.  I haven't had a chance to actually try it yet,  but just watching the amount of effort  that the creator, Jared Sumner, is putting into it,  he's put a crazy amount of attention to detail  in identifying things that are slow,  such as copying files  and extracting them during installation  or WebSocket message handling  or HTTP request serving and things like that,  and has done a ton of optimization work  to make that stuff fast.  Does this guarantee that the tool  is going to be a massive success?  No, and the fact that it is a one-person effort so far  is a little bit scary,  but the fact that someone actually has taken the time  to put in that much effort  to try to make a new alternative  JavaScript runner, bundler, transpiler,  package installer, Swiss Army Knife,  is really very impressive,  and it has a lot of potential.  I mean, we've been talking over the last couple minutes  about how ES Build is a lot faster than Webpack,  and I've seen some people like Sunil Pai talk about  when your bundler is that fast,  it changes the way you do development,  and if Bun can potentially make  a lot of other operations faster,  it could also have a similar effect  on development process.  Yeah, so Bun is not so fast,  and what's neat about that is you can compile on request,  and in the future,  I mean, we already have Deno,  and it's much faster than Node,  and it supports TypeScript,  and so you could have  a build-less thing with Deno,  and they released their fresh thing  that is zero build.  Ryan has been experimenting with  what a zero build remix would be like,  and the cool thing about zero build  is you can deploy in 10 seconds.  It's just how long it takes to upload the new files.  It's awesome,  so I'm really excited about the zero build thing,  and with Bun, it's even faster.  One of our engineers, Jacob,  put together Bun deployed in a Docker container on fly  running remix,  and you'd get response times of 20 milliseconds.  That's outrageous.  When it's less than 200 milliseconds,  it actually doesn't matter,  but what's cool about that is it means that  you can handle more traffic with less resources,  and so, yeah, Bun, I am very excited about it.  I love how fast it installs dependencies.  It would be like a marked improvement  on my development life,  so, yeah, super here for Bun.  Also, a little concern that it's only one person,  but I think it's only possible  to accomplish what he has so far  because it was one person.  No meetings, no arguments,  and he just does everything, whatever he wants,  and he can get things done really fast.  Eventually, if we want to build on it into the future,  then we probably are going to need  to have some of those arguments and meetings,  but for right now,  I think having it be just one person  is the reason why it's as great as it is.  Remix really takes the 90s seriously.  You could copy some files on an FTP,  and it would just work.  Yeah.  Not only from the technologies,  but it sounds really amazing,  the zero bundling and deployment.  I was also excited about Bun.  I haven't tried it yet.  I was on vacation for two weeks,  and there's the old joke  when you come back from vacation two weeks later,  nothing is the same  in the JavaScript front-end environment,  but I really love to try it out.  I was also excited about RoamTools  when they said they were going to give you  this one-stop shop of things  that you could use very fast.  I don't know what happened to Roam.  I haven't really heard a lot lately,  but Bun really sounds like  it's also picking up from there a bit  and pushing it over the edge.  The fact that it's just one person,  I think I've read a tweet from him  where he said that he has everything  in his head right now,  which is amazing.  There must be so much code,  but knowing all the dependencies,  the architecture,  and it's getting to a point  where he really also needs to offload  to other people.  Now that there is an initial release,  I think lots of people  will happily contribute to that endeavor.  I had made the mistake  of subscribing to the Bun repo  while all the notifications,  while it was still in early private release.  The day that it went live,  it went from five issues a day  to 75, and I had to unsubscribe.  I love that.  It's just so exciting to me.  I feel like 2020,  I was like, what's new?  What's new?  What's new?  What's new?  In the past year or so,  we're just seeing so much excitement  and so much new innovation  and just fresh love and excitement  and innovation happening  within our community,  which is just very, very, very exciting,  and I'm so happy for it.  Well, we have a few other questions.  Tom, did you want to choose another one?  Me too.  Feel free, Tracy.  I've been given all the questions.  Oh, that's okay.  Go ahead.  I like the hook question.  You can go.  Go ahead.  Choose it.  I've got one for Paige specifically asking  if you've made updates to your course  for React 18 and the changes that that brought.  I mentioned this a little bit earlier,  but not yet.  The course originally came out back in,  I think, October or November of this past year,  so it's six or seven months old at this point,  and then React 18 got finalized in March,  so there are things that I'm working on.  I just haven't gotten anything updated  and finalized and pushed out yet,  but there will probably be some new modules  around some of these new hooks  that have become available,  maybe some of the server-side rendering options  that are now part of components.  Just haven't gotten to it quite yet,  but yeah, it's definitely in the works,  but a lot of what my course teaches  is not necessarily specific  to a particular version of React.  It's also about the larger best practices  for building long-lived, reliable web applications.  It's things like how to add in unit testing  and automation.  It's how to work with component libraries.  It's how to set up your development environment  so that you've got the right tools  like linting and prettier and code formatting  and all the things like that.  While it is tailor-made for React  and going from stateful components  to stateless and using hooks,  there's a lot of other stuff  that is more generically appropriate  and still really relevant to today's software methods.  That's excellent.  I might have to check out that course myself  because it's always good to see a great overview  of the entire app lifecycle  that isn't just narrowed down on one specific,  like here's a Medium article  for that one thing you wanted to do  and the rest, good luck.  Yeah.  So we recently had a debate  in our Slack channel at this dot  that generated 111 replies.  So it got interesting.  But what kicked it off  was a code snippet found in a library  that was a use something.  It doesn't really matter.  It was a hook.  But when you read it,  is it really a hook?  It didn't do hook things.  It was just somebody had been reading React code  and was like, oh, everything starts with the word use.  So I guess my function should start with the word use.  And we got on the topic of,  well, what really makes a hook a hook?  How do you know that your hooks are hooks,  that they're doing hook things?  It seems like something that someone new to React  could easily get confused around.  So how would all of you try and explain something like this  to someone who's less well-versed in React?  Kent, let's raise his hand.  I've got a very simple definition for what a hook is.  A hook is a function that uses other hooks.  That's it.  Somewhere in that call stack,  it needs to call one of the actual hooks built into React.  It might be through some other custom hook.  But if it doesn't ultimately result  in at least one hook from React being called,  it's not actually a hook.  I think it's comparable to how a component  at the end of the day needs to render  one of the primitives of React,  like a div or a button.  On top of that,  that's just components and abstractions  that you make on purpose.  And that's like the custom hooks that you make.  And if you expand it,  at the end of the day,  it's all just divs and buttons and whatnot.  And then the hooks that are built in,  useState, hopefully not useEffect,  but maybe even useEffect, and so on.  Even though I have to admit,  I have also at least once created a function  that started with use and didn't use a hook underneath it  because I think I wanted it to be limited  to be used in functional components  because I anticipated I was going to need  a use memo or something a bit later on.  So I wanted to make that refactoring  that comes later a little bit easier.  But it's definitely not something  that you do on a daily basis, I guess.  Yeah, and to kind of add on to that,  if you find yourself reusing the same set of hooks  or kind of trying to mimic the same functionality  from one component into another in React,  that's probably a good use case for a hook.  You can extract that function out  into its own custom hook  and then be able to just call it wherever you need it,  and it'll do essentially the same things.  But from my experience,  a lot of times when you see people  kind of creating custom hooks before they need to,  a lot of that is business logic or just application logic  that probably doesn't necessarily need to be in a hook.  It just needs to be in a utility function somewhere  that any part of the application could call,  regardless of if it's running React hooks  or if it's maybe on server side or somewhere else.  It's probably worth a second look  if it really needs to be a custom hook or not at that point.  Ah, yes, the ever-popular utils.js.  Yeah.  What about returning something from the hook?  Do you think that's a necessary condition for it to be a hook?  I would say yes.  It doesn't necessarily need to be a lot.  It could just be some Booleans.  It could be some really simple state information.  It could be just an array or an object.  But I would say yeah.  I mean, that's generally what most of the React hooks do  in some way, shape, or form.  No, I disagree.  You could have a hook that updates the document title,  for instance, and you just pass it  what you want the document title to be.  You don't need anything back from that.  Or like a use persist or something like that.  But I think that is one of the difficult parts about hooks  is that you don't actually know what they're going to do  unless they are super well-named or you look into them.  A hook could be just an effect that updates the title  and does nothing else.  Or it could be something that continuously re-renders  your component for some reason  because it's a subscription to something else.  So kind of the difference,  if you know React Query,  there's useQuery and useQueryClient.  useQuery creates a subscription.  useQueryClient just gives you something,  reads from React context, never triggers a re-render.  So you don't really know what a hook does  just by calling the hook.  There's no recipe for what a hook is eventually going to do.  And I think that makes it a bit hard to understand  when is it a hook or what's the hook going to do.  I always find it interesting that  one of the core concepts of hooks  is just understanding functions.  And a lot of the same principles still apply.  Good practices there.  Having the use, whatever it is, be well-named.  Having it encapsulate a core set of logic here.  And like Paige was saying, if it's reusable,  maybe it doesn't even need to be a hook.  Maybe it could be extracted  into a separate function altogether.  But to circle it back to what Kent was saying,  if it has a hook inside of it,  then it's a hook.  It's a custom hook.  But oftentimes when educating folks  on what the principles and the rules are with hooks,  we typically just have a larger conversation  around JavaScript as a whole.  Because that typically brings in  some kind of other conversation  where they can be educated on  just some of the basic principles.  Veering very slightly off this,  I want to put in a plug for two articles  that I find myself very frequently linking to people.  to explain this stuff.  One is Tyler McGinnis wrote a post  that is hosted on UI.dev  called Why React Hooks?  And it talks about the problems that we had  dealing with class components.  Why the React team invented hooks in the first place  and what problems they're meant to solve.  And then Sean Swicks Wong  did a blog post and a talk a while back  called Getting Closure on React Hooks.  And he builds a miniature working version  of React Hooks live in a 30 minute talk.  And if you've ever wondered  what are hooks?  How do they work internally?  Why do they have some of these rules  that I have to follow?  That talk and post are very, very informative.  Awesome.  There's so much to talk about here  and I wish we could keep talking forever.  But unfortunately we are at time.  This has been really amazing.  There's so many questions that haven't been answered.  But everybody, besides Kent.  But Kent, you just know his Twitter handle anyway.  So he doesn't need to put it there.  But no, everybody's Twitter handles is here.  So feel free to continue the conversation on Twitter.  If you're not on Twitter and you're in tech,  highly recommend just joining Twitter.  And you have, what, six, seven, eight friends  that will say hi to you already.  So yeah, I mean, Twitter is a great place  to continue these conversations.  All these folks here also have really amazing projects  that they're working on.  So definitely check out some of the open source projects  or some of the different projects  that these folks are generally involved in.  And come hang out in open source.  Yeah.  And Swix is amazing too.  So people have been saying in chat  how to actually spell Sean's name.  Sean's Twitter handle.  So you can follow him at Swix for some amazing stuff as well.  Thank you again for everyone who's listening.  And if you want to find out more about these events,  you can always sign up to this.co slash newsletter  to find out about our events.  Or this Meetup event is specifically posted  on reactjsmeetup.com.  So you can check that out too.  All right.  See y'all very soon.  Thank you. 