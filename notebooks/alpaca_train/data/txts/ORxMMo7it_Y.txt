[00:00:00 -> 00:00:02]  Databases are a critical part of an application.
[00:00:02 -> 00:00:05]  But the big question that arises all the time
[00:00:05 -> 00:00:07]  is, how do you pick a database?
[00:00:07 -> 00:00:10]  Which database makes sense for your use case?
[00:00:10 -> 00:00:13]  What are the different types of databases?
[00:00:13 -> 00:00:15]  Well, stay with me in this video because I
[00:00:15 -> 00:00:17]  will answer most of those questions
[00:00:17 -> 00:00:22]  and give you a framework to pick a database for your use case.
[00:00:22 -> 00:00:24]  Now, real quick, what is a database?
[00:00:24 -> 00:00:27]  It's really a place to store your data
[00:00:27 -> 00:00:31]  so that the application can easily access it when needed.
[00:00:31 -> 00:00:33]  Now, there are two broad categories
[00:00:33 -> 00:00:35]  of databases to choose from.
[00:00:35 -> 00:00:39]  There's relational databases, which are also
[00:00:39 -> 00:00:42]  called SQL databases.
[00:00:42 -> 00:00:45]  And then there is non-relational category,
[00:00:45 -> 00:00:51]  which is also referred to as NoSQL databases.
[00:00:51 -> 00:00:54]  Now, in relational databases, the information
[00:00:54 -> 00:00:59]  is stored in tables, in rows and columns.
[00:00:59 -> 00:01:04]  And they can talk to each other through specific keys.
[00:01:04 -> 00:01:06]  They're connected to each other.
[00:01:06 -> 00:01:09]  And because of this fixed structure,
[00:01:09 -> 00:01:13]  it's typically used for data that does not change very often
[00:01:13 -> 00:01:15]  because you need to decide this schema.
[00:01:15 -> 00:01:20]  And the data can just be added in the same schema over time.
[00:01:20 -> 00:01:25]  But you can't really change the schema very often.
[00:01:25 -> 00:01:28]  Now, SQL, or Structured Query Language,
[00:01:28 -> 00:01:31]  is typically used for interacting with this database.
[00:01:31 -> 00:01:35]  So you would, say, select all users
[00:01:35 -> 00:01:41]  that purchased this product under this promo.
[00:01:41 -> 00:01:46]  Now, relational databases offer ACID consistency model.
[00:01:46 -> 00:01:52]  What that means is it's atomic, consistent, isolated,
[00:01:52 -> 00:01:54]  and durable.
[00:01:54 -> 00:01:55]  What does that mean?
[00:01:55 -> 00:01:59]  By atomic, it means all operations in a transaction
[00:01:59 -> 00:02:03]  succeed or every operation has to roll back.
[00:02:03 -> 00:02:05]  We'll see a little bit more with an example.
[00:02:05 -> 00:02:09]  Now, consistent means on the completion of a transaction,
[00:02:09 -> 00:02:12]  the database is structurally sound.
[00:02:12 -> 00:02:15]  Now, isolated means that the transactions are not
[00:02:15 -> 00:02:18]  competing or contending with one another,
[00:02:18 -> 00:02:21]  and the transactions appear to run sequentially.
[00:02:21 -> 00:02:24]  And durable means that the result
[00:02:24 -> 00:02:27]  of applying a transaction are permanent,
[00:02:27 -> 00:02:29]  even in the presence of a failure.
[00:02:29 -> 00:02:32]  Now, because of these properties,
[00:02:32 -> 00:02:34]  relational databases are used in applications
[00:02:34 -> 00:02:39]  that require high accuracy and for transactional queries that
[00:02:39 -> 00:02:43]  require consistency, such as financial and retail
[00:02:43 -> 00:02:44]  transactions.
[00:02:44 -> 00:02:46]  Now, think about an example.
[00:02:46 -> 00:02:50]  In banking, when a customer makes a fund transfer request,
[00:02:50 -> 00:02:54]  you want to make sure that the transaction is possible,
[00:02:54 -> 00:02:57]  that there's actually funds in the bank account,
[00:02:57 -> 00:03:01]  and it actually happens on the latest, most up-to-date data,
[00:03:01 -> 00:03:03]  which is the account balance.
[00:03:03 -> 00:03:07]  In this case, an error and resubmitting of that request
[00:03:07 -> 00:03:12]  is sometimes fine, but a wrong transaction is not fine.
[00:03:12 -> 00:03:15]  So that's what we mean by consistency.
[00:03:15 -> 00:03:18]  Now, in Google Cloud, there are two databases
[00:03:18 -> 00:03:21]  that fall into the relational category.
[00:03:21 -> 00:03:26]  There is Cloud SQL and Cloud Spanner.
[00:03:29 -> 00:03:32]  For more details on each of these,
[00:03:32 -> 00:03:35]  I'm going to put the documentation links below.
[00:03:35 -> 00:03:36]  But broadly speaking, if you have
[00:03:36 -> 00:03:39]  a large amount of relational data,
[00:03:39 -> 00:03:42]  more than, say, 10 terabytes or so,
[00:03:42 -> 00:03:45]  and you need global scale and global consistency,
[00:03:45 -> 00:03:47]  you're going to pick Spanner.
[00:03:47 -> 00:03:50]  But for any other general purpose relational database
[00:03:50 -> 00:03:53]  requirements, Cloud SQL should suffice.
[00:03:53 -> 00:03:58]  Now, non-relational databases or NoSQL databases
[00:03:58 -> 00:04:01]  store complex, unstructured data.
[00:04:01 -> 00:04:08]  Now, in relational databases, as we saw,
[00:04:08 -> 00:04:10]  this is more structured data.
[00:04:10 -> 00:04:13]  You know what you're storing, and you
[00:04:13 -> 00:04:15]  know how it's organized.
[00:04:15 -> 00:04:20]  In non-relational, here, it's not really tabular in nature.
[00:04:20 -> 00:04:23]  You can store data in different formats.
[00:04:23 -> 00:04:28]  It could be a document format.
[00:04:28 -> 00:04:31]  It could be key-value pairs.
[00:04:34 -> 00:04:39]  It could be graph, which is data connected to one another.
[00:04:41 -> 00:04:46]  It could be data in memory, so like cache.
[00:04:50 -> 00:04:55]  And it could also be data in wide columns.
[00:04:55 -> 00:04:57]  Now, non-relational databases are often
[00:04:57 -> 00:05:02]  used when you have large quantity of data,
[00:05:02 -> 00:05:04]  so large data sizes.
[00:05:04 -> 00:05:10]  Complex in nature, diverse data, and it needs to be organized.
[00:05:10 -> 00:05:13]  Now, unlike relational databases,
[00:05:13 -> 00:05:16]  the non-relational databases are faster
[00:05:16 -> 00:05:18]  in delivering the query response.
[00:05:18 -> 00:05:21]  And that's because they don't have to join the tables
[00:05:21 -> 00:05:25]  or look through the entire data set to give you the answer.
[00:05:25 -> 00:05:28]  They can just look through that portion of the document
[00:05:28 -> 00:05:31]  and respond back quickly to the query.
[00:05:31 -> 00:05:35]  And this makes them ideal for storing data
[00:05:35 -> 00:05:38]  that may change frequently or for applications that
[00:05:38 -> 00:05:41]  handle many different kinds of data.
[00:05:41 -> 00:05:42]  Now, let's consider an example.
[00:05:42 -> 00:05:45]  You might have an apparel store, which
[00:05:45 -> 00:05:49]  has a database of all the shirts that you are selling.
[00:05:49 -> 00:05:53]  Now, the shirts could be categorized,
[00:05:53 -> 00:05:58]  and you're saving the shirt data with the size, the brand,
[00:05:58 -> 00:05:59]  the color.
[00:05:59 -> 00:06:04]  And you want to have room for additional parameters
[00:06:04 -> 00:06:09]  to add later, such as, say, sleeve size or collars
[00:06:09 -> 00:06:10]  and et cetera.
[00:06:10 -> 00:06:15]  Now, if you saved this data in a relational database,
[00:06:15 -> 00:06:18]  it's a lot of work to expand those columns.
[00:06:18 -> 00:06:20]  But in a non-relational database,
[00:06:20 -> 00:06:24]  you can just add new parameters or new key value
[00:06:24 -> 00:06:27]  pairs to that data set that already exists.
[00:06:27 -> 00:06:32]  Now, a little more on how NoSQL databases are actually faster.
[00:06:32 -> 00:06:35]  Now, the first thing is they follow
[00:06:35 -> 00:06:40]  what is called as basic structure, meaning
[00:06:40 -> 00:06:49]  basically available, soft state, and eventual consistency.
[00:06:49 -> 00:06:52]  Now, this really means is that it's basically available,
[00:06:52 -> 00:06:56]  meaning it's considered to be available all the time.
[00:06:56 -> 00:06:58]  And availability is more important.
[00:06:58 -> 00:07:03]  Soft state means it doesn't have to be write consistent.
[00:07:03 -> 00:07:08]  And eventual consistency really means that at some later time,
[00:07:08 -> 00:07:13]  you can assume that the database will be fully consistent.
[00:07:13 -> 00:07:17]  But in every current moment, it's
[00:07:17 -> 00:07:19]  more important for it to be available
[00:07:19 -> 00:07:21]  than to be consistent.
[00:07:21 -> 00:07:23]  Now, because of these properties,
[00:07:23 -> 00:07:26]  non-relational databases are really
[00:07:26 -> 00:07:31]  used when you require reliability, availability,
[00:07:31 -> 00:07:35]  and your data changes can be frequent.
[00:07:35 -> 00:07:38]  Because here, you can't really change the schema of the data
[00:07:38 -> 00:07:39]  very often.
[00:07:39 -> 00:07:42]  And they can scale very easily horizontally.
[00:07:42 -> 00:07:47]  What that means is you can add machines to scale
[00:07:47 -> 00:07:51]  the database horizontally, while here, the scaling
[00:07:51 -> 00:07:55]  has to really be by changing the size of the machine.
[00:07:55 -> 00:07:59]  So this scales vertically.
[00:07:59 -> 00:08:07]  And in non-relational databases, you can scale horizontally,
[00:08:07 -> 00:08:10]  which also means that distributed relational
[00:08:10 -> 00:08:15]  databases are harder to manage, while distributed unstructured
[00:08:15 -> 00:08:20]  databases are easier and better to manage.
[00:08:20 -> 00:08:23]  Now, as we saw here, choosing a relational or non-relational
[00:08:23 -> 00:08:27]  database largely depends on your use case.
[00:08:27 -> 00:08:32]  Broadly, if your application requires ACID transactions
[00:08:32 -> 00:08:36]  and your data is not going to change much,
[00:08:36 -> 00:08:38]  select relational databases.
[00:08:38 -> 00:08:42]  If your data may change later and if the scale
[00:08:42 -> 00:08:45]  and availability is a much bigger requirement
[00:08:45 -> 00:08:49]  than consistency, then non-relational databases
[00:08:49 -> 00:08:50]  are a preferred choice.
[00:08:50 -> 00:08:52]  Also, you could say that if you're
[00:08:52 -> 00:08:57]  dealing with transactional data use cases,
[00:08:57 -> 00:09:00]  then online transactional processing use cases
[00:09:00 -> 00:09:03]  are usually handled in relational databases,
[00:09:03 -> 00:09:07]  while the analytics processing use cases are usually
[00:09:07 -> 00:09:11]  handled in non-relational databases.
[00:09:11 -> 00:09:14]  Although, for processing, you also
[00:09:14 -> 00:09:19]  have to deal with a whole different set of tools,
[00:09:19 -> 00:09:22]  such as data warehousing and data management
[00:09:22 -> 00:09:25]  and processing, which I'll cover in a separate episode
[00:09:25 -> 00:09:27]  because it's not about databases.
[00:09:27 -> 00:09:30]  It's more about the pipelines and how you analyze data.
[00:09:30 -> 00:09:32]  Now, when it comes to Google Cloud
[00:09:32 -> 00:09:37]  in non-relational databases, you have multiple options.
[00:09:37 -> 00:09:41]  So in-memory database, you have Memory Store.
[00:09:42 -> 00:09:48]  For graph database, you can use Genys Graph with Bigtable.
[00:09:48 -> 00:09:54]  For key value store, you can use Bigtable.
[00:09:54 -> 00:09:57]  For document store, you can use Firestore.
[00:10:00 -> 00:10:07]  And for right column, again, Bigtable.
[00:10:07 -> 00:10:09]  Now, this should give you a broad overview
[00:10:09 -> 00:10:11]  of the difference between relational
[00:10:11 -> 00:10:16]  and non-relational databases and even the options within them.
[00:10:16 -> 00:10:18]  When you are going to make that final decision,
[00:10:18 -> 00:10:20]  I do recommend that you dive deeper
[00:10:20 -> 00:10:23]  into that specific database a bit more
[00:10:23 -> 00:10:25]  and understand any other nuances that
[00:10:25 -> 00:10:29]  might be specific or relevant to your use case.
[00:10:29 -> 00:10:31]  If you like this video, give it a like
[00:10:31 -> 00:10:32]  and let me know what your thoughts are
[00:10:32 -> 00:10:35]  in the comments below so I can cover the topics that
[00:10:35 -> 00:10:36]  can help you the most.
[00:10:36 -> 00:10:38]  Thank you.
[00:10:39 -> 00:10:41]  Bye.
