 What's gucci everyone, it's AJ here again. And today I want to talk about another data structure that's similar to a  binary tree, but it has some kind of some different rules and some different quirks. But I really like it because it's  simple. And I feel I can explain it well. So without ado, let's get into the heap data structure. So as you can see  here, a heap looks a lot like a binary tree if you know what that is. But but a heap is classified by its order. And  what a heap does is it retains two rules. One is that the parent is always greater than the child, and that it's  always a complete tree. And so by complete tree means every single row is filled. Every row is filled just like like  the first row is filled, the second row is filled, except for the last row, but the last row must have its nodes  going from left to right. So for instance, all the nodes are filled here, when you start at left, and then the  emptiness starts at the rightmost side. So that's a complete tree. But also what I said, the parent must always be  bigger than the child. In this example, that is not true. But that is what I mean by that is that the parent must be  greater than child relative to the child. So this would be called actually a min heap, because I am saying the  minimum element is the greatest element has the greatest power, you can also have a max heap, which we'll see in a  second, is where the maximum element has the most power. So as you can see, 100 is the root of the node, which is, which  is what I want. And then see, as you can see, 19 is greater than 17, and three, and then the two children of two and  seven are less than 17. And as you can see, this again is a complete tree, well, two and seven all the way to the left,  and then the other children's of these nodes are incomplete. So another thing about heaps is they can be  represented in an array, you know, if you're going to make a heap, you want to just use an array, you don't need you  don't, you can you can use generics, but really, you don't want to use a tree structure, you just want to use an array.  And the reason because it's going to be how you're switching around the tree. So for instance, here, I have five, nine, and  11. And you'll notice I have the zero in the beginning. And that's because in this example, I am not using position zero  position zero is kind of just like a null value. It's a blank value that we're not really using. It's just a holder value. And  we're never going to touch that. But I have 5, 9, 11, 14, 18. And if you can see here, these nodes are going from top to  bottom left to right. So for instance, five is the first element, then nine, then I go right 11. Now I go to the next row,  which is all the way on the left 1418 1921 3317 27. And the thing that's special about this array is that, I mean, yes,  this array is that heap has a special property and how you can find the children. So for instance, let's look at five here,  it's childs are 11, or sorry, it's childs are nine and 11. And the way to find a child is to simply take the position of  what of whatever node you have, and times it by two, and if you times it by two, that will always be the left child. And  then if I did two and plus one, so take the position, times two plus one, that will give me my right child. And you can try  this on anything else, for instance, on nine, that position to two times two is four, which is the left child 14 at  position four, and then two times two plus one is five, which is 18, which is my right child. So that always works. And  then kind of oppositely, let's say I wanted the shot the parent of 27. So 27 doesn't have any children, but it does have a  parent. So the way to do that is simply take the position and do n divided by two. So n divided by 210 divided by two is five,  which is 18, which is my parent. And this works for the left and right child, for instance, 19, right here is not a right  child 21, seven. So if I do seven divided by two, that's 3.5. But I'm going to round it down to three, always round it down, I  round it down to the integer like in computing, and I'm going to get 11, which is my parent. So that so that's a simple way to  kind of that's the way I can exchange or switch elements in the array as we'll show. So now we're going to talk about  insertion. So insertion really is pretty easy. And what we do is simply what you want to do is you want to add it to the slot, you  want to first of all start, you want to insert it at the empty slot, which in the complete tree is the next empty slot going from  left to right. So for instance, right here in the source heap on the left here, we're going to try to we're going to insert  negative two, right here, we're going to insert it to the as the right child of six. And then what I'm going to do is no matter  what element is, I'm going to look at the parent by doing my n divided by two in the array and say, okay, does that child need to  be moved up? In the case of inserting negative two in a min heap, it does need to be moved up. So I'm going to flop six and  negative two, I'm going to flop six and negative two. So now negative two is right here. And six is right here. And so then I'm  going to try I'm going to keep on doing this until I get stopped. So then I'm going to do okay is negative two greater than one. In  this case, it's a min heap. So yes, it is. So then I switch that and you get you get what you get on the right negative two is now the  root. And now I'm done with that. So that's pretty cool. And now we're going to talk about another thing called deletion. And  so deletion is usually kind of the hardest thing with a tree. So really, the thing in deletion, though, is you don't delete any  node, you you just delete the root because in a min and max heap, you really use it only because you want the minimum or  maximum of your data structure. You don't really want care about any other elements, you just care about the minimum or  maximum. So maybe you just care about the high point of a statistical analysis. But that's all you're going to care about in the  heap. So you can you only really have a remove a remove root method, which could be your minimum or maximum position depending on  what type of heat you have. So right there. So right now, what you want to do is you want to remove your root, just like here, I want to  get rid of four. And what I want to do is I want to replace that with my bottom rightmost element. So what is you know, what is the  rightmost bottom list on the complete tree? And the way so in this case, that's eight. So I'm going to push that to eight. And then  what I'm going to do here is I am going to, I'm going to shuffle eight down. And I what I'm going to switch, I'm going to bring eight  down, and I'm going to purposely, you know, make the tree right again, because now that I moved eight down, and this is a min heap, eight is  not the minimum element. So that cannot be the root five is. So what I'm going to do is I'm going to look at my two children, I'm going to  look at my two children, and I'm going to swap with which element is the greatest element. So that way I bring up the greatest element. So  now my greatest element is now the new root node and everything is fine. In this case of a min heap, five, the smallest number has the  most power is the most powerful. So I'm going to swap with five. And then as you can see right here in my bottom in this bottom, in  this bottom picture, that that array is now fine, I have now removed that I have now cut the heap is now following the right order  five is the lowest element has the most power six, and then eight, and then nine. So it still fits the rules that five, five is less  than six and eight, and nine is less than six. Well, guys, I hope you enjoyed this video. And I hope you guys have a great day. 