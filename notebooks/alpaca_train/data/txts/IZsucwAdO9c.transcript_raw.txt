 Where were you in 2001?  2001, I was a sophomore.  Sophomore, high school.  I'm starting to date you guys.  Anybody not in high school in 2001?  Where were you?  Fifth grade.  Fifth grade.  OK, that's more what I was expecting.  All right, fifth grade, 2001, 12 years ago,  I am in this classroom.  Not here, somewhere else, but I'm in this classroom.  I'm a fresh-faced junior in college.  Don't have too many juniors, do we?  How many juniors?  Oh, good, more juniors than usual.  You guys are the TAs for next year's class.  I'm a junior.  I'm taking this class.  I don't know really much about computer science.  I've taken a couple of classes.  I'm interested in operating systems.  I've heard that this class is really hard.  And I'm interested in the challenge.  So I'm in this classroom.  And 12 years later, I'm up here.  So this is my warning to you about this class.  This class may turn you into me.  And you have the semester to decide  if that's a good thing or not.  So my name's Jeff Chalen.  And I'm here because of this class you're about to take.  That's why I'm standing in front of you today.  That's why I got a PhD in computer science.  That's why I teach computer science.  I really like this stuff.  And I hope that this class likes you and that you like it.  Again, I took this class.  I was a physics major.  Margo Seltzer taught me operating systems  12 years ago at Harvard.  I started building computer systems.  I TA'd this class a number of times.  And computer systems was really my portal  into computer science.  I like building things.  I like making stuff.  I'm not the brightest person, so programming  is a good fit for me, because I can bang my head against it  until I get it to work.  And I eventually went to graduate school,  eventually decided I want to be a professor.  This all happened very slowly.  And again, 2001, I never thought I'd  be teaching this class to you guys,  but I'm very excited about that.  This course makes me very, very excited and very, very happy.  And I'm glad you guys are all here.  So that's me.  So why are you guys here?  How many people are here because they have to take this class?  How many people are here because they have to take this class,  and they waited till senior spring to take this class?  All right, yeah, this is the group  that's not going to like me by the end of the term.  How many people are here because you have an interest  in computer systems?  How many people are here because you  want to be a better programmer?  How many people are here because you  heard that this class was terrible and exhausting?  All right, there we go, gluttons for punishment.  Maybe those are the two people that will be happy  with me at the end of the term.  All right, so unfortunately, for you guys who are seniors,  we've waited four years before doing two important things.  One is we waited four years, I would argue,  to really teach you how to program.  This course will try to make up for some of that lost time.  The other thing we've waited four years to do  is to really teach you how your computer works.  And we're going to try to rectify that in this class as well.  So let me start off.  Today is going to be kind of a dry day.  I want to talk a little bit about what an operating system is.  I'm going to try to convince you that this is a useful course  to take, despite the fact that you're already here.  So it's somewhat too late.  But I want to convince you because I  think it's exciting stuff, and I think  you guys should be excited about it.  And there's some really great reasons  that we study these 50, 60-year-old computer programs  called operating systems.  We'll talk about that in a sec.  And then we'll go over the course structure and logistics  and blah, blah, blah.  Please stop me along the way at any time.  I'm always happy to take questions.  It's a big class.  It's a nice room.  Actually, I'm really glad to be in here because I like to wander.  And there's a lot more space in here to wander around.  OK, great.  So the first thing I want to point out  is an operating system is a computer program.  How many people have written a computer program before?  Everybody in this class should have your hand up.  You've all written computer programs before, right?  And an operating system is no different  than the other computer programs that you've written.  It is a sequence of instructions that modifies the machine.  It's written in what was a high-level language in the 1970s.  And it performs functions, right?  So there's nothing really fundamentally super mysterious  about operating systems, right?  It's a computer program.  So hopefully, that serves to demystify it slightly, right?  And you guys are going to write one and significant pieces  of one, right?  It's a computer program that on your machines  and on probably billions of different devices  all over the world, whether it's smartphones, servers,  desktops, embedded devices that are in your cars,  in this room somewhere, there's probably  several of them in here.  It performs a couple of useful functions  in the operation of a computer system, right?  That's why we call them operating systems.  The first one is it multiplexes hardware resources.  Who can take a stab at what this means, right?  These are the things that we're going to spend  all semester talking about.  What does it mean to multiplex something?  When people don't volunteer, I start calling at people.  What does it mean to multiplex something?  Yeah?  OK, you're on to something, multiprocessing.  What do I do when I'm doing multiprocessing?  Over here, guy who's on his laptop,  I'm not paying attention.  AUDIENCE MEMBER 2.  It's like a switchboard, like when you put the supplier  hardware or something like that.  PROFESSOR 1.  OK, it's like a switchboard.  How is it like a switchboard?  Let's go down the row.  AUDIENCE MEMBER 3.  I think the way that it's kind of addressed  is you can handle all of them.  PROFESSOR 1.  So we're getting closer here, right?  Does someone want to take us the rest of the way?  Yeah?  AUDIENCE MEMBER 4.  There's a bunch of hardwares that you can figure out  which one to choose.  PROFESSOR 1.  Which one to choose?  OK, now we're getting a little colder.  Yeah?  AUDIENCE MEMBER 5.  Multiple users have their own hardwares  which can access one hardware resource.  PROFESSOR 1.  Right, and how do we do that?  I want multiple users to be able to access one hardware resource.  How do I do that?  Does anybody know?  Good, because that's what this class is about.  But I want to take a small set of resources  and divide them up, multiplex them,  effectively share them between multiple users.  How many of you guys have ever logged  into some sort of time-shared multiprocessing system?  I think everybody here, if you've ever  submitted anything on Timberlake,  or even if you've used your own personal computer, right?  All these computers take a small set of resources  and make them available to a large number of users.  Doing that effectively is one of the major goals  of the operating system, and doing it safely.  And we're going to talk about both those things this semester.  The second thing is operating systems  implement useful abstractions.  What's an abstraction?  Yeah?  You can use something without knowing how it works.  Right, so layer of abstraction means  that there are details about the thing  that you are using that are hidden from you, right?  And normally, why are those details hidden?  Or why are they abstracted away?  Why do I do this?  Yeah?  They're a little too complex for a typical user  to worry about.  Yeah, there's something wrong with them, right?  They're complex.  They're ugly.  They're weird, right?  I mean, how many people have used files, right?  A file, again, this is like an exercise in group arm  exercises, all right?  Just raise your hand, right?  You guys have all used files.  Files are an abstraction, right?  How many people have ever accessed raw disk blocks  as part of your application?  All right, you're, yeah, we'll talk later.  You're weird.  No, no, no.  Most people don't do that, right?  Because files are nice, right?  Because disk blocks, it's like, which disk blocks are mine,  and which disk blocks are yours?  And if the file grows, you need to find new ones.  So yes, abstractions try to take details  about the underlying hardware and make them go away, right?  The details that we don't like, right?  Things about it that are wrong, or things about it  that can be hidden.  And some of that has to do with multiplexing as well, right?  Details of hardware that emerge because we're  trying to share, right?  That we don't want other things to know, right?  Right, so we just did this, right?  Multiple people use the same set of hardware resources, right?  Safely and efficiently, right?  Those are both major goals of the operating system.  And then we're going to talk about a series  of operating system abstractions over the semester, right?  So different types of constructs that the operating  system is responsible for creating and maintaining  that allow us to use the hardware effectively, right?  And hide some of the details from programmers  and make the device easier to program, right?  So the operating system is really  the first creator of abstractions, right?  I mean, when I took this class years ago,  my advisor used to use the matrix analogy, right?  Which I think we used on posters for the class last year, right?  This is, you know, we're giving you guys the red pill, right?  This is really how the machine works, right?  I would probably argue now that there's  lots of different matrices within matrices  inside your machine, right?  The Java VM is another little virtual world, right?  But this is the first one, right?  This is the lowest level.  And to some degree, the stuff below the operating system  is as real as it gets, right, in a computer system.  OK, so why do you guys, like, why, you know,  you're here because it's a required class, right?  OK, so that's a fair answer.  But why is this class required?  Like, why do we still study operating systems, right?  How many people, let's see, how many of you  have already participated in some sort of operating system  development?  Like, you're a BSD hacker.  You've contributed code to Linux.  You know, you use these, like, power tools  to poke around inside your Windows systems  and find out things they didn't want you to do.  How many people do that?  OK, one, right?  That's kind of what I expected.  Probably two, all right?  So we're averaging between one and two, right?  All right, so that's not a reason to take this class.  How many of you regularly program  in low-level languages that access operating system  abstractions directly?  How many people have ever used the C interface,  like the low-level system call interface, right?  How many people have done that?  OK, now we're getting a couple of hands up, right?  But this is 2013, right?  If you're doing this, you better have a good reason, right?  Otherwise, I would say you should  write your stuff in Python or Java  or something that makes your life a lot easier, right?  So again, why are we studying this stuff, right?  None of you guys are going to go out there  and write operating systems for a living.  Very few of you, I should say.  Hopefully, maybe a couple, right?  And none of you guys use these things directly.  So what's the point of this class?  What do you guys think?  Yeah?  AUDIENCE MEMBER 2 Yeah, it's worth everything else  if you write another one.  Yeah, so OK, so that's fair.  So there's this.  One of the reasons is this is how the world really works,  right?  This is how your computer actually works.  And if you're a computer scientist,  it might behoove you to know a little bit  about how your computer actually works, right?  Sometimes, the less you know, the better, right?  But to some degree, to be a scientist,  like this is how the world actually works, right?  This is kind of like the moment where, if you're a physicist,  you start studying quantum mechanics  and everything gets weird, right?  This is that moment.  And the reason we teach you it is  because this is how we've done things, right?  This is how we've built the systems  that you guys actually use, right?  What else?  Any other reasons?  What's true about operating systems  compared to other types of computer programs?  AUDIENCE MEMBER 3 It's just a program.  It's just a program, but how long have operating systems  been around?  How long have people been working on them?  It's at least the 60s, right?  Yeah, like 70 years, right?  60, 70 years.  These are old systems, right?  So who cares, right?  All the problems have been solved.  It's all done.  This is like another reason not to study them, right?  Why would you study something that someone,  a bunch of smart people, had been developing and improving  for 60 years?  AUDIENCE MEMBER 4 Probably to write a retract book.  Yeah, there you go.  These are really mature systems that a lot of smart people  have thought about a lot.  A lot of people have contributed to.  There is still active development  going on in these areas.  Don't get me wrong.  But these are really, really mature systems, right?  And there's a lot of really important intelligence  about how to build things that's embedded in operating systems,  right?  You know, if you want to learn how to paint,  study the great masters, right?  You don't study the person who's been out  of art school for two years, right?  You go and you look at traditions  that have lasted for hundreds of years  and produce really, really amazing stuff, right?  I don't know whose phone that is,  but I would like it to stop ringing.  Thanks.  All right, so we got to the first one, right?  This is how your computer really works, right?  This is it, right?  What else did I say before?  There's another reason here that, you know,  just about operating systems and about learning  about the concepts of operating systems.  How many different operating systems are there?  I mean, who can name an operating system?  Maybe we should start with that question.  OSX, OK.  Is Ubuntu an operating system?  Linux, OK.  What else?  Windows?  You guys think I don't like Windows?  You're trying not to make me mad.  Yeah, Windows, yeah.  Windows is an operating system.  What else?  FreeBSD, OK.  What else?  OK, now we're getting sketchy here.  Yeah, OK, fair enough.  But look, there aren't that many operating systems out there,  right?  There's a handful of operating systems.  And when you start looking at them carefully,  you see that they share a lot of the same abstractions.  Part of that's because those abstractions  have been developed over such a long period of time  that they're really mature and useful, right?  So again, that goes back to our previous point.  But how many devices out there run an operating system?  Ballpark estimate.  In the universe.  100%?  Yeah, I mean, actually, it's probably  not quite 100%, but it's pretty close, right?  Even these little, tiny little sensor moats  that I used to program in graduate school  ran an operating system, right?  It's kind of a made-up operating system.  But everything out there, even these little 8-bit  microcontrollers, run some kind of operating system, right?  So there's a lot of operating systems out there.  So there's this ubiquity thing, right?  Also, as a programmer, you are probably, at some point,  going to encounter the limitations  of the underlying hardware, right?  Java and Python are great at making things look magical,  right?  Like, wow, this device, like, you know,  I can just create these endless lists of objects,  and everything just works and goes away when I want it to.  And then at some point, when you start  to write things that get big enough and gnarly enough,  like, you start to realize that your machine doesn't  have an infinite amount of memory, right?  And the operating system is doing its best to manage it,  but some of these things run out of steam.  And how many people have ever had that experience where,  you know, they realize that the computer,  they realized something about the computer  they didn't want to know because they pushed it too hard?  All right, good, a couple of you.  So that's another reason.  And then, again, I think there is this sense  that operating systems, to the degree that operating systems  and applications and programs can be beautiful,  operating systems are beautiful, right?  Like, we have been beautifying them for 60 years, right?  And they are really very, very mature and elegant pieces  of code, right?  And I think that looking at them and studying them  will help you design your own code, right?  Things that aren't operating systems,  but have to deal with a lot of the same problems  that operating systems have to deal with, all right?  All right, so there's two parts to this class, right?  There's this conceptual part that we do in here  Monday, Wednesday, Friday.  And then there is a series of programming assignments  that you do for, you know, 40 or 50 other hours per week,  right?  So why are we making you go through that, right?  Why do we make you program operating systems  as part of learning about them, right?  Why not just have this class, and we'll  take a couple of exams and call it a day?  Some of you guys are going to like that option  once we get to the end of the semester.  Yeah, anybody?  I'm going to start calling on people.  Why do you guys think, this corner of the room,  this is like the corner that's farthest away from me.  I feel like this part filled up first.  Why do you think we program operating systems?  So you can't learn if you don't program it.  That's true.  And what about, what do you guys have a feeling?  I mean, you don't know this yet, because most of you  haven't done it, right?  But what do you feel like is likely  to be true about programming operating systems?  What's that?  It's difficult. Why is it hard?  Well, OK, I'm going to take this off, right?  So it is hard, right?  And one of the reasons it's hard is,  how many guys have ever used a program called a debugger,  or an integrated development environment, or whatever?  Those are programs that run on top of the operating system.  So how do you debug the operating system?  Not very easily, all right?  And operating systems, again, are these big, mature, gnarly  pieces of code.  Starting off with them can be very difficult, right?  So there's a degree of difficulty  here that we use to help you guys grow and learn  as programmers, right?  The point is to give you something that you can't do  and help you do it.  We have a core staff here that's going  to spend a lot of time this semester helping you  guys with these assignments, helping  you guys program and debug.  And when you come out of it, you will be better at it,  I guarantee, right?  The other thing about, so let's say  you're going off for a day hike, right?  How many people go hiking ever, or go out for a walk, right?  Yeah, it's computer programmer, so I know I'm not  100%, right, but a few of you, all right?  How many people have ever gone on like a three or four day  hike, OK?  So when you go out for a day hike,  you're just like, I have some water, maybe.  You know, it's nice outside.  You go out, you walk around, you come home, you have dinner,  you go to bed, right?  When you go off for like a three or four day hike,  is that what you do?  No, right?  Like you might want to think about it a little bit before  you go, right?  You want to be like, do I have enough food?  Do I have enough water?  Do I know where I'm going?  Do people know that I'm going there?  Do I have somewhere to sleep?  Do I have a plan, right?  Am I going to get lost immediately?  So when you take on these big endeavors,  you have to actually plan them a little bit, right?  You know, when you sit down to write a piece of code  that you think is going to take a couple hours,  you don't spend two hours writing a design document  explaining how you're going to do it.  But when you sit down with one of our programming assignments  that are going to take you a couple weeks to complete,  then that's a useful thing to do.  And most people in this class, unfortunately,  despite the fact that we tell you  guys to write design documents at least 60 or 70 times,  don't do a very good job.  And the first time they have to do  in these big programming assignments, they learn, right?  You guys will learn this because you will find yourself  deep in the weeds, unsure of what you're doing,  without a map, without food, without water.  And you know, the TAs will be there to fix things.  This hiking metaphor runs out of steam at some point, right?  Because we don't want you guys lost in the woods  and having to medivac you out of there or whatever.  But anyway, the point is that you guys  will learn how to design, right?  And we'll teach you that.  And we'll encourage you to do it.  And we'll show you how to do it.  And then we'll let you try to do it.  And we'll see how well it goes, all right?  Difficulty, we covered this.  Operating systems are hard to program.  And finally, the debugging is part of this, right?  How many people have used GDB?  All right, that's one of those things.  When you guys finish this class, every hand in this room  is going to be up.  Everyone's going to use GDB.  You do not debug operating systems  in the integrated Eclipse debugger, right?  Nor do you hit Fix All and let it  fix all of your coding issues that it  doesn't understand at all, right?  So this is going to be something you guys are  going to enjoy learning, all right?  So as I alluded to before, there's two parts of this class.  There is a conceptual component.  And there is the programming component, right?  So we talk about things in class at a high level.  The recitations will try to bring some of that stuff  down from the clouds a little bit  and anchor it in your experience of programming the programming  assignments for this class.  And then you guys are going to go out  and do those programming assignments, right?  So we talk about high level stuff here.  I'll use some examples that are drawn from the code  from the class, but I don't feel like I  have to if they don't explain what I want to explain.  And then there's this big programming component, right?  We're going to come back.  We're going to do some different things with each  of these this semester.  So we're going to describe this.  So here's what I want to accomplish, right?  This is my roadmap for this semester.  By the time you're done, I want you guys  to understand the abstractions that  are implemented and supported by modern operating systems.  That's a big part of this class, right?  And abstractions are really powerful.  And these abstractions are very mature and very interesting,  OK?  I want you guys to be able to describe how operating  systems multiplex hardware, right?  This is the other main objective of operating system software.  And I want you guys to know how they do it  and the policies and mechanisms that  are involved in doing it, right?  Because some of those policies and mechanisms  and the sort of ideas that we've come up  for scheduling and different layers of abstraction  are actually pretty useful in other contexts, right?  So this is something that you can take out and apply  to other types of problems, right?  And then finally, we're going to look at operating systems  as kind of this historical progression, right?  We'll talk a little bit about why certain types of abstractions  emerged.  We'll talk about how they change over time, right?  The operating systems of 60 years ago  dealt with machines that are nothing  like anything you guys will ever program or encounter  in your entire life, right?  So there's been huge changes to the underlying hardware  that have gone on.  And there will continue to be huge changes  to the underlying hardware.  Operating systems will continue to adapt to that.  And we're going to talk a little bit about how that's happened,  right?  And how am I going to know that you guys are learning this  stuff, right?  This is important to me, because if you're not learning it,  then I need to do something different, right?  The best and really only way I have right now to know this  is you guys have to come to class, right?  You have to come to class.  You have to participate.  You have to ask questions.  And if you're not doing that, I just  assume that you guys have some clue what's going on, right?  I know that's probably not true, right?  But coming to class, and I try to build a lot of feedback  in the class.  I'll talk about this in a second, right?  And the way that we find out what you've learned  is we give you exams, right?  This is pretty standard stuff, right?  This is some of what we're going to do this semester, right?  This is kind of in order, roughly,  but I don't know how far we'll get.  Last year, we got to virtualization.  My preference is to go more slowly and make sure  you guys understand the material, right?  I don't care about getting all the way  to the bottom of this bullet list.  I'm happy to stop halfway through.  And I would be happier if you guys learned half of it,  than if I cover all of it and no one has  any idea what we're doing, right?  But this is sort of basically what we're going to cover.  I'm not going to go into detail, but you guys,  these slides will be up online, and you guys  can look over this stuff if you're  interested in a roadmap as far as what we're doing, right?  But really what this comes down to is hardware components.  And then for each hardware component, we build up,  and we talk about the abstractions  and the multiplexing techniques that  are driven by that hardware component, right?  So we look at the CPU.  We look at memory.  We look at storage, right?  Each one of those sort of silos has  its own set of policies and abstractions and mechanisms,  and we go over those in detail, right?  And then we get to the point where  we kind of pull back even one more curtain,  and we talk about virtualization, which essentially treats  the whole machine now as a multiplexable resource, right?  And that kind of gets a little bit fun.  And then there is lots of different stuff  that we can talk about at the end of the class  if there's time permitted.  There's a lot of new modern ideas, right?  All right, so my advice for how to learn  the material in this class, right?  First thing, attend class, all right?  I know it's 9 AM, all right?  It's not my fault, all right?  I have complained bitterly several times  about when this class is scheduled, right?  They keep scheduling it at 9 AM, all right?  So I'm going to be here, you know,  bright-eyed and bushy-tailed probably at 8 AM.  But I would really suggest you guys come to class.  We will put lecture videos online, right?  We have them online from last semester  as well, last year when I taught the class.  Some of you guys heard that, and I saw your, you know,  I saw a little smile curl up the corner of your mouth.  Yes, you know, I can set my alarm back one more hour.  Don't do it, OK?  If you guys don't come, I don't know  if you're learning or not.  You can't ask questions.  We can't interact in class.  So I really want you guys to be here.  I will do my best to make 9 AM as entertaining, and interesting,  and interactive as possible.  Your part of it is to just show up, all right?  Just come to class, prepare to be called on from time to time,  but please be here.  Use the online videos as a resource.  Watch them again after class if you  want to slow things down, or speed things up, or view  things.  That's what they're for, right?  But I think if you guys choose not to come to class,  you're really going to be missing out,  and you're going to be reducing your ability to learn stuff,  right?  Please be here at 9 AM.  I get here a little bit before.  If you have questions, it's a good time  to bother me about stuff.  And at 9 AM, what I do every day is  we do a five to 10 minute review.  So we start with the last class.  I turn that into a little bit of a mini quiz.  It's not done in pencil and paper.  We just do it out loud in class.  But it's a way to kind of warm you guys up,  go over the stuff from last class.  It helps me calibrate what's happening.  So if I do a 10 minute review, and no one  knows anything about what we did in the last class,  then maybe I need to slow down and cover  some of that material again, right?  So this is an important part of class.  If you come late, you'll miss it, right?  So please try to be here at 9.  Again, as I said before, I'm very flexible  about how much we get through, right?  And I don't want you guys to feel  like my job is to take that outline and jam it into you,  right?  Like, that doesn't work, right?  If I do that, most people won't learn much, right?  So I would rather do less and have  you guys understand it more.  And a big part of how that happens  is you guys being here and being willing to interact in class,  ask questions, and let me ask you questions,  and things like that.  So that comes back to being in class, all right?  Any questions about this?  I know it's kind of a radical idea.  I went to college, right?  And the idea that someone would ask me to actually show up  in class every day at 9 AM, at Harvard,  they barely even schedule classes at 9 AM.  They knew nobody would come, right?  Here, they schedule recitations at like 8 o'clock.  And I'm thinking, I mean, that's just mean.  So anyway, but I think it would be really great  if you guys came to class, and I'll be here.  So I'll be lonely if no one comes.  All right.  So let's talk about the programming  portion of the class, right?  So these are my goals, right?  When you guys are done, I want you guys  to be able to design and implement  well-structured system software, right?  Well-structured in particular, right?  Hopefully, it will work, right?  But structuring and designing it is really  more than half the battle for this class.  And I want you guys to be able to get there,  and we're going to teach you how to do it and give you  a chance to learn, right?  A big challenge, and this is a little bit more  specific to the material in this class  that we haven't covered yet, but a big challenge  to writing good operating system code that many of you  guys have not encountered yet is dealing  with synchronization, synchronization  in C, synchronization at the operating system level, right?  And there's a set of synchronization primitives  and problems that we'll talk about  that will prepare you to do that.  That's a big part of this class, right?  Because a lot of you guys will end up  writing multi-threaded code, right?  Especially now when we've got like,  now your laptop has a 16 core processor in it, right?  I mean, thinking about synchronization and concurrency  is really becoming more and more important, right?  And operating systems give you a starting point  for learning how to do it.  How many people have done significant sort  of multi-threaded programming before?  All right, a couple of you guys.  By the end of the class, everybody, right?  Debugging.  So multi-threaded stuff also raises the bar for debugging.  And this is a big part of doing well in this class,  is learning how to use the debugging tools, right?  And finally, we do a little bit about performance  in this class.  Performance is really an important part  of operating systems on some level.  You know, operating systems are a piece of code  that it kind of matters if it's right,  but it also really matters that it works quickly.  And in fact, one of the interesting trade-offs  that operating systems designs have made over the last 60  years is they've always sacrificed correctness,  provable correctness, for performance, right?  We're starting to see some improvements on that front.  We'll talk about them maybe toward the end of class, right?  But if your machine takes five minutes to boot,  then you don't care if it's correct or not, right?  Like, you'll go off and buy something  that boots in 10 seconds 99.99% of the time,  and then once in a while it throws up a blue screen, right?  I know that this is true, because people have  been doing it for 30 years, right?  This is why Windows exists, right?  And Windows isn't even that fast.  It's so frustrating.  So how are we going to keep track of you for this part,  right?  You're going to be in class.  You're going to come to recitations and office hours  with questions about the programming assignment.  And we also are going to have a way for you guys  to test your assignments continuously,  and that's basically going to be the grading process.  This semester, I will get to it in just a sec.  All right.  So there are four assignments in this class, all right?  And we'll talk.  Let me just go through each of them.  I think this semester, I'm going to ask you guys to work in pairs  for the whole class.  Last year, we paired up people for assignment 2  and assignment 3.  I think this year, I'm just going  to ask you guys to pair up immediately, maybe  as soon as next week, and just do  all of these assignments together in pairs, right?  I think that's probably a better experience,  and it's a little bit easier for us logistically.  So that said, start looking around the room  and deciding who the person do you want in your 421 foxhole,  right?  Who is someone who you're going to work well with this semester?  So there are four major assignments.  The two at the bottom are really the big mamas.  Those are what's fun.  Those are where you guys learn a lot.  That's where you end up implementing  pretty significant components of a modern operating system.  So the assignment 0 is a code reading and kind  of familiarization assignment.  Helps you get your environment set up, yadda, yadda, yadda.  Just building and running your first kernel, it won't do much,  but we'll walk you through the process  and get you started with some of the development  tools and things like that.  Assignment 1 is about implementing  using synchronization primitives.  The code you write for your operating system  is fairly small and easy.  The code that you write to solve synchronization problems  is maybe more complex and kind of dumb,  but these are toy problems we give you  to help you think about synchronization.  If you don't get them, it doesn't matter.  That stuff doesn't affect the performance of your kernel.  For assignment 2 and assignment 3,  you start actually implementing parts of the operating system  that user LAN programs use.  So the assignment 2 is about implementing the system call  interface.  This is how applications use the operating system.  This is how they get help with things they need to do.  And then for assignment 3, we'll let you  do this on writing a virtual memory manager.  So virtual memory, I think, is my favorite abstraction  and one of the most elegant abstractions that's  supported by operating systems.  And we let you take a stab at writing a big piece of it  and getting it to work in your own little kernel.  So the development environment for this class  is an instructional operating system  that was developed at Harvard.  I was one of the guinea pigs for it.  My year I took the class, it was the first year  that it was ever used.  Some of us were scarred for life by that experience,  but it's been around now for a dozen years,  and it's pretty mature and very well supported.  The goal with this little mini system  is to strike a balance.  So some operating systems classes  are taught using Linux or some mature BSD open source type  operating system.  The problem with that is those systems  are incredibly big and complicated.  And it's like if you're trying to teach somebody English  and you give them Proust or something,  or you give them Shakespeare.  You're not going to get it.  You need to start off with Tom and Jane.  So Linux, I think, is just too deep of a dive  for most people.  And what people end up doing is they say, OK, well,  ignore 99.99% of Linux and just change this one line.  And that's just not that fun.  So you guys get to build big components  of a real operating system.  You don't just get to twiddle with the scheduler on Linux.  And then there are these other operating system frameworks  that are various stages of growth.  Some of them work pretty well.  Others are kind of disgusting.  But OS 161 was designed to kind of try  to find a middle ground.  So it's a complete operating system.  It runs inside an emulator.  This is one of the main reasons we get this to work.  This is, of course, the other big problem.  Until the event of virtualization,  if you were trying to teach someone to write Linux,  it was like, OK, I have a bug in my Linux kernel  and my computer won't boot.  So what do I do?  Running an emulator allows us to hook up a debugger  and give you guys a little bit more visibility  into what the system is doing, which  allows you to fix things and learn  about what your system is doing.  All right, so this also, like I said,  allows us to simplify debugging.  OK, this is a big change for this class for this year.  And I want to talk about it a little bit  and give you guys a chance to wrap your minds around it.  Last year, everything in this class happened very slowly.  And so the programming picked up very, very slowly.  And we ended up trying to jam a lot to the end of the class.  And that was really my fault. It was  because I was trying to design some of the assignments  and rewrite them and find ways for you guys  to submit online, all this stuff.  The great thing is that's done.  And the other great thing is we have an automated tester that  will do the grading for the assignments.  So you submit a patch, we run a program,  and out pops your score.  So what we've decided to do this year  is allow you to submit your assignments for grading  whenever you want.  You think you're done, you send your patch.  This is how it's going to work.  You think you're done, you set your patch in.  A couple hours later, we run it through our tester  and we say, here's the test that we ran,  which you will have access to.  Here's what happened when we ran them.  And based on those results, here's  the score that you would receive on this assignment.  So this is, I think, kind of nice.  But then a whole bunch of things seem  to make more sense to me.  So you guys will know what grade you  have at any given point in time.  There's no mystery here.  You guys send in the patch, we grade it.  We give you a score.  Hey, if you want to see and you're  happy with stuff that doesn't work, then you're done.  Then go on to the next assignment.  Question?  AUDIENCE MEMBER 2 You do the assignments  later on in the program?  You do the assignments.  Every assignment is done in pairs.  For the purposes of this class, two become one.  You guys are in a pair, and that pair  receives the same grade for, I think,  now I've made up my mind, for all four assignments.  So again, you can stop when you're done.  You're happy with your grade, move on.  And finally, there are no deadlines  for the programming assignments in this class.  None.  Except the end of the semester.  That is the one deadline.  So if I was sitting in, I think some of you guys are like,  great, I'm going to leave it all the last week.  You can do that.  And I am not going to try to stop you.  We are going to try to help you with this.  There's a variety of reasons that I want to try this.  First of all, this is how the real world works.  You work on stuff till it gets done.  So you were just hired at my operating system company.  I'm going to give you a list of requirements  that need to be met by whatever it is, May something.  And then you're done.  You're out there.  You're on your own.  You have a deadline.  It's up to you to plan how to meet that.  I hope that this will allow you to schedule  this work around other classes more easily.  This is a class that's now a wild card  that you can fill in whenever you want.  On the other hand, some of you guys  are going to just fall on this like a sword.  And there's nothing.  I can't do anything to stop you.  I will come in every week, and we  will talk about where people are.  I'll try to find some way for visualizing.  Here's where the class is.  So you can say, hey, I'm like 200 points behind everybody  else.  But I can't make you do these assignments.  Fundamentally, I can't make you do them anyway.  But I'm giving you a big piece of rope.  And I hope that you're going to use it  to make a tire swing or something.  But there are other uses for it.  Yeah?  Will you be letting us know when is the best time  to start doing the assignment?  Yeah, well, I'm going to pace.  Well, I'll give you guys some pacing hints.  So I will say in class, this would be a good time  to be at this point with assignment one.  And then I'll put up the graph showing where people are.  And then I'll be like, well, OK.  Some of you guys will get ahead.  That's fine.  I mean, if you want to blow through this in three weeks  and just nail it, get it done, I don't care.  You guys can be finished with the programming components  and just coming to class and enjoying life and having fun  and acing the rest of your classes.  But this is how this is going to work this semester.  So you will always know what your grade is  on the programming components of the class.  You will always know that.  Right now, it's a zero.  And I know where the finish line is.  You guys will know that, too.  So you will always know what grade you have.  Questions about this?  All right.  A couple, yeah.  What's a good amount of time to have each of these, like,  assignments?  Yeah, again, I'll sit down today and just lay it out.  The first couple assignments, I think  you can do together in a month.  And I would probably allocate maybe a month for assignment  two, and then as much of the rest of the semesters,  you can stand for assignment three.  Assignment three is really the heavy lift, right?  Assignment two, I think, is doable  in a reasonable amount of time.  Assignment three is, again, assignment three  is the most fun, but it's kind of the top of the mountain.  Yeah?  Nick?  So the grades all fit in for a semester?  I think it's two hours.  Yeah.  How long is two hours?  A couple of hours.  Yeah, so, OK.  We don't want you to bang on the grader, OK?  Just, like, this is not a testing kit, right?  You can run the test.  Like, we're not secretive about the test we're going to run.  The tests we're going to run are user-land programs  that run inside your kernel that you can run locally, right?  And in fact, at some point, maybe we'll  just give you the testing suite, and you  can run on your own local machine, right?  That's even better for us, because then we  don't have to waste server cycles, right?  The testing suite is, again, not supposed to be like, well,  let me try this.  Test it.  Didn't work.  Let me try switching those two lines around.  Test it.  Didn't work.  You'll never get done if you do that, right?  Just let me warn you.  There's no way.  You guys are going to be writing, like, probably  4,000 or 5,000 lines of code by the time  you're done this semester, right?  And you'll be rewriting most of those at least 10 times, right?  There's just the design space is too large for you  to just whack the grader and try to get a better result.  It won't work.  I don't think it'll work.  The nice thing about the grader is it is kind of slow, right?  And I don't feel, like, super inclined to fix that,  just because that's fine, you know?  I won't bore you with the details.  It's basically dripping characters into a terminal,  pretending that it's you typing very slowly.  That's how we do it.  So yes, so again, because you're doing these assignments  in pairs, this is a conversation you  need to have with your partner when  you select that lucky person, right?  If you want an A in this class, don't  pick a partner who's satisfied with a C on the assignments,  right, because you won't give, right?  You guys need to be committed about how much effort  you're willing to put in, right?  Because you'll need to decide when to stop together, right?  And finally, and this is something else that  makes me even more happy, we're not  going to distribute solution sets.  The assignments in this class are cumulative,  and you'll just keep working, right?  So again, when you decide that you're  done with an assignment, you can go on  and start working on components of the next assignment.  But we will keep testing those pieces, right?  And if they don't work, they don't work.  All right, I need to speed up a little bit  to get through the rest of this.  So this is my simple guide to collaboration, right?  If you're talking to somebody, anybody in the class,  and you're describing a design, and you're  talking in English, right, or your language of choice,  your natural language of choice, right, that is not cheating.  That's fine, right?  As soon as you start exchanging code,  talking in code, which hopefully people aren't  training themselves to do, or emailing code around,  or cutting and pasting code, then  this starts to become an issue, right?  Cheaters, right?  I have a terrible visceral reaction  to cheating that I will try to restrain while the camera is  on.  But it's not because I'm a vindictive mean person, right?  It's because there's some of you  in this class who are going to work really hard this semester  and are going to do your best.  And you're still going to do OK in the class, right?  And I have a huge amount of respect for you guys, right?  What I don't respect is the beep who  steals the assignment online and turns it in and gets an A,  right?  That person I have zero, zero talent and zero respect for,  right?  So the cheating policy in this class  is designed to protect the people who  are here who are willing to do their best, right,  and take the grade that they earn, right?  Some of you guys would do better than others, right?  But if you guys play fair, then again, my hats are off to you.  We did this last year, and it worked quite well, right?  There's an online similarity, code similarity checker.  We will run every submission that you put into the system  through this, right?  If this picks up large degrees of similarity,  we will have the TAs investigate those.  And if you submit plagiarized code,  we will fail you for the class, right?  This is the CSE department policy, OK?  And I don't soften it.  So you guys submit plagiarized code, you fail, right?  Not an assignment, you're done.  And does anyone have any questions about that?  It's pretty simple.  We compare your assignment against everything  we can get our hands on, right?  This tool is so fantastic, right?  The first time I ran it, it completed like this.  And I was like, is it broken?  And no, it's just that good, right?  It runs really rapidly.  So we can take hundreds of assignments,  like anything we can locate on the internet from last year,  from this class, we will run that tool against.  Like, every match will be investigated by hand, right?  By one of the TAs or me.  But this is how we do it.  Yeah, question?  AUDIENCE MEMBER 2 No, there's not many false positives.  PROFESSOR NELSON No.  No, no, no, there are not many false positives, right?  Last year, there were six people that this tool caught cheating,  and they failed the class.  So I don't want you guys to be in that group, right?  But don't test us, because we will win, all right?  This tool is too good, and you guys  are going to write too much code, right?  If these assignments were 10 lines,  then there'd be only one or two ways of doing it, right?  But they're not.  And so the design space becomes so huge,  and so plagiarism just sticks out like a sore thumb, right?  I mean, the things we caught last year were ugly, ugly.  And there were no questions in any case  of where the material came from, all right?  Also, something I want to emphasize this year,  when you submit work in a pair group,  you and your partner are jointly responsible for the work  that you submit.  If we find that a piece of your assignment is plagiarized,  both of you will fail the class, OK?  You both are going to be working on these assignments  together, right?  So what does that mean?  Find a partner you trust, right?  And you guys need to be involved in all aspects  of the assignments, right?  Clearly, you're not going to write every line of code.  But if you are worried about your partner's behavior,  you need to approach us immediately, right?  Because if you submit something that we find out  is plagiarized, and then a week later, you're like, oh, yeah,  he was acting a little fishy or whatever,  then the more time goes by, the more you own that, right?  You own that with them, right?  So find someone that you can work effectively with  and work together so you know what each other are doing.  And if you're worried about it, come talk to us right away,  OK?  Is this clear?  Also, the assignments are very clear  about how you can divide them up, right?  There are certain divisions that are not acceptable, right?  Asking one part of your group to do all the coding  while you write the design document is not OK, right?  If we find out that you did that and you didn't tell us about it,  we'll fail you and your partner, right?  Maybe just you, actually.  All right.  So the only, you know, I'm not going to go over this too much.  But for the assignments, get started early, work on them,  test them, work together with your partner.  This is pretty basic stuff, right?  But this is how you do well on these assignments, right?  Come to our office hours, which there will be many of,  and work close by the course staff,  work close by each other.  There were students that came in last year whose model was,  they would come and they would ask the course staff a question.  They would go program for half an hour  and then they would come back with another question.  Those students did well, right?  And they got a lot of help.  And it was fun, right?  I like that.  I don't know if all of you guys were upstairs  in the hallway next week working on assignment zero,  I would think that would be awesome, right?  And we'd order pizza.  All right.  I need to get through this really fast, unfortunately.  I'm running a little bit of time.  There are two parts of this class, right?  There's a conceptual portion and there's a programming portion,  right?  If you look here, both of those add up to 100, right?  So how am I going to combine these grades, right?  My goal is, in my opinion, these parts are not substitutable,  right?  If you do really well on the programming assignments  but decide to fail the exams, I don't  think you deserve a passing grade.  If you do, more likely, if you come and ace the exams  and just totally blitz out on the programming assignments,  then I don't think you deserve a passing grade either, right?  So here's what we're going to do.  Your grade is now two variables, right?  It's a programming component, which, again, you  will be able to find out at any point based on the submissions  that you've made.  And it's a conceptual component, which is, again,  allocated through the exams, right?  At some point during the semester,  we will start to assign these grades to regions, right?  I don't know how these are going to look.  These are circles, right, clearly.  Maybe they'll be other, more complicated shapes, right?  The idea is that this will determine your grade.  So this is how, you know, and depending  on where you are on this curve, right, again,  notice that this guy, right, who, again,  apparently came to class.  Maybe he already knew the material, nailed the exams,  but then bugged out on the programming assignments,  did not do well in the class, right?  So you have to be able to program and understand  the concepts to pass this class, to do well in this class,  all right?  I'll put this up online.  I'm sure people are curious about it, right?  All right, if you want a reference,  there's a book by Andrew Tannenbaum  called Modern Operating Systems.  It's not at the bookstore, but you  can find it online for a third of the price.  But anything in lecture and the code in this class,  those are really the text of this course, right?  Also, if your C programming is rusty or nonexistent,  you may want to pick up a C programming reference, right?  OK.  So we are going to have our own dedicated room  for this course for TA office hours.  It's Davis 303, all right?  It's right next to the TA room for every other class, right?  But you guys are special.  You get your own TA room, right?  And you guys can go in there and hang out or whatever.  I mean, it's pretty much going to be open,  so I'm hoping that this is a place where you guys can come  and get help and congregate and work together  and engage in a more communal atmosphere, right?  The people in this room are one of your best sources of help,  OK?  I think that good classes come through this course together,  right?  They help each other.  There's a nice group spirit that emerges.  And I'm very supportive of that, right?  Like I said, you guys come in.  You're looking over each other's shoulders.  You're helping each other debug.  That's awesome, right?  That is not cheating.  That's great, right?  And I want to support that.  So this is how this is going to work.  We'll have more details on this later.  There's one more thing I want to get to.  So there'll be a website.  Everything will be up on the website.  I know I'm speeding up.  But it's because I want to introduce the TAs.  Zhe is in the back here.  You stand up.  She has the distinction of being the only TA who  took the class with me, right?  So she did all these assignments, right?  So she knows more about them than I do at this point,  probably, because she did them last year  and I did them 10 years ago, right?  So she will be a great source of support and help for you.  Anudipa is here.  So you may not see much of Anudipa,  but she might be doing some back end stuff  with grading and other things.  So Guru, wow, it's almost hard to recognize you.  You look great.  Freshly shaven and cut.  So Guru will be helping out.  He's a really nice guy, really strong programmer.  And Aditya, all right, the most sporty, the most  styling of RTA staff.  Yeah.  All right, one thing I want to cover.  I'll get back to questions.  I'm going to be outside after class for as long as I need  to be if you guys have questions about anything  that we talked about today.  I know I kind of sped up and accelerated towards the end.  On Wednesday, we have the first exam of class, right?  This exam is worth eight free points if you come and take it.  If you don't come and take it, we'll  just scale your other exam scores appropriately,  so you don't have to come and take it.  I would appreciate if you come and take it.  It's a background exam that gives me  an idea of what you know, and it's  important for us to benchmark this class  and understand what people who are coming to it learn.  Again, you come in, you sign your name,  you fill it out, eight points towards the conceptual portion  of your grade, right?  If you don't come, then we'll just scale the other points.  We're in the process of sort of transitioning  some of the online materials over to a new website.  That hopefully will be done by the end of the week,  and our goal is to have the environment and everything  ready for you guys to start programming by Monday,  even potentially earlier.  All right?  I will be outside for questions because I  think we're out of time.  And I look forward to seeing everybody on Wednesday. 