 Hello, I'm Justin from Embedded Micro, and welcome to another Chalk Talk.  In this video, I'm going to be talking about the fundamentals of digital logic circuits.  Digital logic circuits are mainly composed of two categories, combinational logic and  synchronous logic.  I'm going to be talking about combinational logic first, and this is actually probably  what you think mostly of when you think of digital logic circuits.  A combinational logic circuit consists of a series of inputs and a series of outputs.  What makes a circuit combinational, as opposed to something else, is that when you apply  a set of inputs, you will get a set output, no matter when you apply those inputs.  For example, if you apply inputs A and you observe output B, then no matter what time  you apply input A, the circuit will produce output B. So if you apply A in a minute, two  minutes, a day, a year from now, the circuit will produce output B. That effectively means  that the circuit is memoryless.  Now you can imagine that a combinational logic circuit could look something like this, where  you have maybe four inputs and one output, and maybe you have a couple AND gates in here,  and the AND gates feed forward into an OR gate, and then that's your output.  So the key word there was feed forward.  Everything in this circuit is going from the inputs to the outputs.  There's no feedback loops or anything like that, because that could create a state and  it could have memory.  Now what if you wanted to design a circuit that has feedback and state, such as something  like a counter?  So to design a counter, we're going to need a circuit that can add one to a number.  And now this is an actual combinational logic circuit, because no matter when you apply  the input number, the output number is always just going to be the input plus one.  So the naive approach to make this into a counter may just be to take the output and  connect to the input.  That way, when the output is one, the input will be one, then that'll add one to it, so  the output will be two, and then three, four, five, and it counts accordingly.  But the first thing you have to realize is that to represent a number, we actually have  to use multiple outputs as multiple bits.  So if we want to have a number that's eight bits wide, say a byte, then we actually have  eight outputs and eight inputs.  And now what'll happen is when you apply a set of inputs, the outputs won't actually  all change at the same time, and depending on how the circuit is actually laid out, they  may toggle multiple times before settling on the correct value.  The only thing you're completely guaranteed with a combinational logic circuit is that  the outputs will eventually settle to their correct value.  But in the meantime, there will be some invalid values.  What that means in this case is that the invalid value at the output is going to propagate  back to the input, so you then have an invalid input, and then that's going to generate more  invalid outputs, which will generate more invalid inputs, and you'll have a cycle until  your circuit's just spitting out garbage.  Now it's actually possible to design circuits with feedback like this, and they're called  asynchronous logic circuits.  However, they get very complicated for small designs, because you have to worry about exactly  when these signals are going to be propagating around.  Fortunately for us, we only have to design synchronous logic circuits.  A synchronous logic circuit relies on a memory element known as the flip-flop.  Some circuits rely on other memory elements, such as latches, but they aren't as common,  and they're actually discouraged for FPGA designs.  So a flip-flop consists of two inputs and one output.  Now one of these inputs is a special input, and it is known as a clock.  A clock, if you're not familiar, is just a signal that goes from low to high, to low  to high, to low to high, over and over again at a set frequency.  And there's actually a special event on this clock, which is known as the rising edge,  and that's when the clock goes from low to high.  The other input on the flip-flop is known as the D input, and the output is known as  Q.  And when the clock transitions from low to high, so on the rising edge, the flip-flop  copies the value from D to the value of Q.  So for example, if Q is 0 and D is 1, so we're inputting 1 and the output is 0 right now,  Q will stay 0 as long as the clock doesn't change.  But the moment the clock goes from low to high, the value of D gets copied to the value  of Q, and Q will transition from 0 to 1.  Now what's great about this then, is Q will stay 1 until the next rising edge of the clock.  So D is free to change and become invalid values.  So we take that back to our counterexample, and we take the plus 1 circuit and feed its  output into the flip-flop, and then put the flip-flop in the feedback loop, then this  circle will actually be well behaved.  So just for a second, assume that the output of the flip-flop is 0.  That means that the input of the addition circuit will be 0, which means the output  will be 1, which means the input of the flip-flop will be 1.  Now on the next clock cycle, on the next rising edge, the output of the flip-flop will then  become the input, so this will be 1.  The 1 will propagate around, and then the input will become 2.  So each rising edge of the clock will cause the output of the flip-flop to increase by  1.  So we have effectively made our counter.  Now this is great, but you may be thinking, well what's the initial value of the flip-flop?  In many circuits, you don't really care what the initial value is, because it somehow gets  initialized just through normal operation.  But in a case like this, where it highly depends on the initial value, there's actually another  input to the flip-flop called reset.  A reset signal is used simply to set the flip-flop to a known value.  Typically all the flip-flops in your design will be connected at the same reset line,  so that when it is reset, your entire design will enter a known state.  Now this is a good example of just a digital circuit in general, but a more general description  is a series of combinational logic blocks separated by flip-flops.  Now you can have more complicated structures where you have the branching and different  things like that, and you can even have feedback from one stage back into the combinational  logic and all kinds of things like that, but the key takeaway point here is that digital  circuits fundamentally are blocks of combinational logic separated by flip-flops or some other  memory element.  I hope this video has given you a basic understanding of digital logic circuits.  Make sure to head over to EmbeddedMicro.com for lots of tutorials.  I'll put links in the description.  Thanks for watching, and I'll see you next time. 